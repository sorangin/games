<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"> <!-- Added user-scalable=no -->
    <title>Color Cascade Game</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            font-family: sans-serif;
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            /* Prevent pull-to-refresh and overscroll effects on mobile */
            overscroll-behavior-y: contain;
        }

        #game-container {
            width: 350px;
            max-width: 100%; /* Ensure it fits smaller screens */
            height: 500px;
            max-height: 100vh; /* Ensure it fits smaller screens */
            background-color: #333;
            border: 5px solid #222;
            border-radius: 10px;
            position: relative;
            overflow: hidden; /* Crucial: Blocks disappear if they go above */
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }

        #game-container:-webkit-full-screen {
            background-color: #333; /* Ensure background covers screen */
            width: 100%;
            height: 100%;
         }
         #game-container:-moz-full-screen { /* Firefox */
             background-color: #333;
             width: 100%;
             height: 100%;
         }
         #game-container:fullscreen {
             background-color: #333;
             width: 100%;
             height: 100%;
         }

        #game-area {
            flex-grow: 1; /* Takes up available space */
            position: relative; /* For positioning blocks */
            background-color: #444;
        }

        #fullscreen-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 30; /* Make sure it's above game elements but below overlays */
            padding: 5px 8px;
            font-size: 10px;
            cursor: pointer;
            background-color: rgba(255, 255, 255, 0.7);
            color: #333;
            border: 1px solid #aaa;
            border-radius: 3px;
            font-weight: bold;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
        }
         #fullscreen-btn:hover {
             background-color: rgba(255, 255, 255, 0.9);
         }
         #fullscreen-btn:active {
            transform: scale(0.95);
         }
        
        #controls {
            height: 60px;
            background-color: #2a2a2a;
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 0 10px;
            border-top: 3px solid #111;
            flex-shrink: 0; /* Prevent controls from shrinking */
        }

        .control-button {
            width: 50px;
            height: 40px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 10px; /* Can add color names if desired */
            color: white;
            transition: transform 0.1s ease;
            box-shadow: 0 3px 5px rgba(0,0,0,0.3);
            /* --- Touch Specific --- */
            -webkit-tap-highlight-color: transparent; /* Remove blue tap highlight on iOS/some Android */
            user-select: none; /* Prevent text selection on hold */
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* IE/Edge */
        }
        /* Style for mouse hover/active */
        .control-button:active {
            transform: scale(0.95);
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        /* Style for JS-simulated active state on touch */
        .control-button.active-touch {
             transform: scale(0.95);
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }


        .block {
            width: 40px;
            height: 40px;
            position: absolute;
            border-radius: 5px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.4);
            /* Start above the visible area */
            top: -50px;
        }

        #score-display {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 1.5em;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            z-index: 10;
        }

        /* Overlay for Start/Game Over */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            z-index: 20; /* Ensure it's on top */
            padding: 20px; /* Add padding for text */
            box-sizing: border-box; /* Include padding in dimensions */
        }
        .overlay h2 {
            margin-bottom: 10px;
        }
        .overlay p {
            margin-bottom: 20px;
        }
        .overlay button {
            padding: 12px 25px; /* Slightly larger buttons for touch */
            font-size: 1.1em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #4CAF50;
            color: white;
            transition: background-color 0.2s ease;
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight */
             user-select: none;
            -webkit-user-select: none;
        }
        .overlay button:hover {
             background-color: #45a049;
        }
         .overlay button:active {
             transform: scale(0.97); /* Add active state for overlay buttons */
        }

    </style>
</head>
<body>
    <div id="game-container">
        <div id="score-display">Score: 0</div>
        <div id="game-area">
            <!-- Blocks will be added here by JavaScript -->
        </div>
        <div id="controls">
            <!-- Buttons will be added here by JavaScript -->
        </div>
        
        <button id="fullscreen-btn">FS</button>
        
        <!-- Start Screen Overlay -->
        <div id="start-screen" class="overlay">
            <h2>Color Cascade</h2>
            <p>Tap the button matching the falling block's color before it hits the bottom!</p>
            <button id="start-button">Start Game</button>
        </div>

        <!-- Game Over Overlay -->
        <div id="game-over-screen" class="overlay" style="display: none;">
             <h2>Game Over!</h2>
             <p id="final-score">Your Score: 0</p>
             <button id="restart-button">Play Again</button>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        document.addEventListener('DOMContentLoaded', () => {

            // --- DOM Elements ---
        const gameContainer = document.getElementById('game-container'); // Already defined
        const fullscreenButton = document.getElementById('fullscreen-btn');
        const gameContainer = document.getElementById('game-container');
        const gameArea = document.getElementById('game-area');
        const controlsDiv = document.getElementById('controls');
        const scoreDisplay = document.getElementById('score-display');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const finalScoreDisplay = document.getElementById('final-score');

        // --- Game Configuration ---
        const colors = ['#FF5733', '#33FF57', '#3357FF', '#FF33A1', '#F1C40F']; // Red, Green, Blue, Pink, Yellow
        const initialFallSpeed = 3; // Pixels per frame (adjust for desired difficulty)
        const speedIncrement = 0.15; // How much speed increases per score
        // const blockGenerationInterval = 1500; // No longer used directly, speed handles interval

        // --- Game State Variables ---
        let score = 0;
        let currentBlock = null;
        let currentBlockColor = '';
        let fallSpeed = initialFallSpeed;
        let gameLoopInterval = null;
        let isGameOver = true;
        let animationFrameId = null; // For using requestAnimationFrame

        // --- Functions ---

        function getRandomColor() {
            return colors[Math.floor(Math.random() * colors.length)];
        }

        function getRandomPositionX() {
            const gameAreaWidth = gameArea.offsetWidth;
            const blockWidth = 40; // Match CSS
            // Ensure block stays fully within horizontal bounds
            return Math.max(0, Math.min(gameAreaWidth - blockWidth, Math.floor(Math.random() * (gameAreaWidth - blockWidth))));
        }

        function createBlock() {
            // Clean up previous block if it exists (safety check)
            if (currentBlock && currentBlock.parentNode) {
                currentBlock.parentNode.removeChild(currentBlock);
            }

            const block = document.createElement('div');
            block.classList.add('block');
            currentBlockColor = getRandomColor();
            block.style.backgroundColor = currentBlockColor;
            block.style.left = `${getRandomPositionX()}px`;
            block.style.top = '-50px'; // Start above the screen

            gameArea.appendChild(block);
            currentBlock = block;
        }

        function isFullscreen() {
                return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
            }

            function openFullscreen(elem) {
                if (elem.requestFullscreen) {
                    elem.requestFullscreen().catch(err => console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`));
                } else if (elem.mozRequestFullScreen) { /* Firefox */
                    elem.mozRequestFullScreen();
                } else if (elem.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) { /* IE/Edge */
                    elem.msRequestFullscreen();
                }
            }

            function closeFullscreen() {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) { /* Firefox */
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) { /* Chrome, Safari and Opera */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE/Edge */
                    document.msExitFullscreen();
                }
            }

            // --- Event Listener for the Fullscreen Button ---
            if (fullscreenButton && gameContainer) {
                fullscreenButton.addEventListener('click', () => {
                    if (!isFullscreen()) {
                        // IMPORTANT: Request fullscreen on the game's main container element
                        openFullscreen(gameContainer);
                    } else {
                        closeFullscreen();
                    }
                });
            } else {
                 console.error("Fullscreen button or game container not found!");
            }

             // Optional: Update button text/icon based on fullscreen state changes
             function updateFullscreenButton() {
                 if (fullscreenButton) {
                     fullscreenButton.textContent = isFullscreen() ? 'Exit' : 'FS';
                 }
             }
             document.addEventListener('fullscreenchange', updateFullscreenButton);
             document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
             document.addEventListener('mozfullscreenchange', updateFullscreenButton);
             document.addEventListener('MSFullscreenChange', updateFullscreenButton);

            // --- Keep all your existing Initialization and other Event Listeners ---
            setupControls();
            // ... (listeners for startScreen, gameOverScreen, etc.) ...

        }); // End of DOMContentLoaded listener

        // Game loop using requestAnimationFrame for smoother animation
        function gameLoop() {
             if (isGameOver) return; // Stop the loop if game over

             moveBlock(); // Update block position

             // Request the next frame
             animationFrameId = requestAnimationFrame(gameLoop);
        }


        function moveBlock() {
            // This function is now just about updating position,
            // the loop calls it repeatedly via requestAnimationFrame
            if (!currentBlock || isGameOver) return;

            let currentTop = parseFloat(currentBlock.style.top || -50); // Use parseFloat for potentially smoother movement
            currentTop += fallSpeed;
            currentBlock.style.top = `${currentTop}px`;

            // Check if block hits the control area (bottom)
            const gameAreaHeight = gameArea.offsetHeight;
            const blockHeight = currentBlock.offsetHeight;

            // Check slightly before the absolute bottom for better feel
            if (currentTop + blockHeight >= gameAreaHeight - 5) {
                endGame();
            }
        }

        // Handles the logic when a color button is pressed (mouse or touch)
        function handleColorSelection(selectedColor) {
            if (isGameOver || !currentBlock) return;

            if (selectedColor === currentBlockColor) {
                // Correct Click/Tap
                score++;
                scoreDisplay.textContent = `Score: ${score}`;
                fallSpeed += speedIncrement; // Increase speed

                // Remove current block visually and logically
                if (currentBlock.parentNode) {
                    currentBlock.parentNode.removeChild(currentBlock);
                }
                currentBlock = null;
                currentBlockColor = '';

                // Create the next block almost immediately
                // Use a tiny timeout to ensure the previous block is fully gone
                // before creating the next one, preventing potential visual glitches.
                setTimeout(createBlock, 10);

            } else {
                // Incorrect Click/Tap
                 flashScreen('#FF0000'); // Flash red on wrong click
            }
        }

        // Handler for the click event (desktop)
        function handleControlClick(event) {
             const clickedColor = event.target.dataset.color;
             handleColorSelection(clickedColor);
        }

        // Handler for the touchstart event (mobile)
        function handleControlTouch(event) {
            // Prevent default touch behavior like scrolling or zooming
            event.preventDefault();

            const touchedElement = event.target;
            const touchedColor = touchedElement.dataset.color;

            // Check if we actually touched a button (not the gap between)
             if (touchedColor) {
                handleColorSelection(touchedColor);

                // Simulate active state for touch devices
                touchedElement.classList.add('active-touch');
                // Use touchcancel and touchend to remove the active state reliably
                const removeActive = () => {
                    touchedElement.classList.remove('active-touch');
                    touchedElement.removeEventListener('touchend', removeActive);
                    touchedElement.removeEventListener('touchcancel', removeActive);
                };
                touchedElement.addEventListener('touchend', removeActive);
                touchedElement.addEventListener('touchcancel', removeActive);
             }
        }

        function flashScreen(color) {
            if (!gameContainer) return;
            gameContainer.style.transition = 'background-color 0.1s ease-out';
            gameContainer.style.backgroundColor = color;
            setTimeout(() => {
                gameContainer.style.backgroundColor = '#333'; // Revert to original
                 // Remove transition after flash
                 setTimeout(() => gameContainer.style.transition = '', 100);
            }, 100);
        }


        function setupControls() {
            controlsDiv.innerHTML = ''; // Clear existing buttons
            colors.forEach(color => {
                const button = document.createElement('button');
                button.classList.add('control-button');
                button.style.backgroundColor = color;
                button.dataset.color = color; // Store color in data attribute

                // Add listener for mouse clicks
                button.addEventListener('click', handleControlClick);

                // Add listener for touch starts
                // Use { passive: false } because we call preventDefault()
                button.addEventListener('touchstart', handleControlTouch, { passive: false });

                controlsDiv.appendChild(button);
            });
        }

        function startGame() {
            score = 0;
            fallSpeed = initialFallSpeed;
            scoreDisplay.textContent = `Score: ${score}`;
            isGameOver = false;
            gameArea.innerHTML = ''; // Clear any leftover blocks
            currentBlock = null;
            currentBlockColor = '';

            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';

            // Stop any previous animation loop
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            createBlock(); // Create the first block

            // Start the game loop using requestAnimationFrame
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function endGame() {
            if (isGameOver) return; // Prevent multiple calls

            isGameOver = true;
            // Stop the animation loop
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            flashScreen('#AA0000'); // Darker red flash for game over

            // Optional: Make the losing block 'stick' visually for a moment
            // if (currentBlock) { /* Maybe stop animation if CSS animations were used */ }

            finalScoreDisplay.textContent = `Your Score: ${score}`;
            gameOverScreen.style.display = 'flex';
        }

        // --- Initialization ---
        setupControls(); // Setup buttons when the script loads

        // --- Event Listeners for Start/Restart ---
        // Using a wrapper function to handle both click and touchstart
        function handleStartAction(event) {
            event.preventDefault(); // Prevent default for both touch and click (like double-tap zoom)
            startGame();
        }

        startButton.addEventListener('click', handleStartAction);
        startButton.addEventListener('touchstart', handleStartAction, { passive: false });

        restartButton.addEventListener('click', handleStartAction);
        restartButton.addEventListener('touchstart', handleStartAction, { passive: false });

        // Prevent scrolling on the whole document - might be too aggressive,
        // but useful if the game area itself might accidentally scroll on mobile.
        // document.body.addEventListener('touchmove', function(e){ e.preventDefault(); }, { passive: false });


    </script>
</body>
</html>

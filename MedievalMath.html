<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Medieval Math</title> <!-- Version Bump -->
    <style>
        /* Basic resets and body setup */
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: 'Verdana', sans-serif; }
        body { display: flex; justify-content: center; align-items: center; background-color: #5d6a5a; color: #eee; }

        /* Game container */
        #game-container { position: relative; width: 95%; max-width: 550px; min-height: 450px; max-height: 98vh; padding: clamp(10px, 3vw, 20px); background-color: #8d7163; border: 5px solid #4b3f31; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.4); text-align: center; overflow-y: auto; }

        /* Fullscreen Button */
        #fullscreen-button { position: absolute; top: 8px; right: 8px; width: 35px; height: 35px; font-size: clamp(1.1em, 3vw, 1.6em); line-height: 33px; text-align: center; background: rgba(75, 63, 49, 0.6); border: 1px solid #eee; color: #eee; border-radius: 5px; cursor: pointer; z-index: 50; }
        #fullscreen-button:hover { background: rgba(75, 63, 49, 0.8); }
        #game-container:fullscreen { max-width: none; max-height: none; width: 100%; height: 100%; border: none; border-radius: 0; overflow-y: auto; }

        h1 { font-size: clamp(1.5em, 5vw, 2.2em); margin-bottom: 15px; color: #fff; text-shadow: 2px 2px #2a231b; }
        #duel-area { display: flex; justify-content: space-around; align-items: flex-end; height: clamp(140px, 25vh, 180px); margin-bottom: 15px; border-bottom: 3px dashed #4b3f31; padding-bottom: 15px; }
        .character { display: flex; flex-direction: column; align-items: center; }
        .sprite { width: clamp(65px, 18vw, 90px); height: clamp(65px, 18vw, 90px); background-size: contain; background-repeat: no-repeat; background-position: center; image-rendering: pixelated; margin-bottom: 5px; position: relative; transition: transform 0.15s ease-in-out, opacity 0.3s ease-in, filter 0.5s ease-out; }
        #knight-sprite { background-image: url('./sprites/Knight.png'); }
        #goblin-sprite { background-image: url('./sprites/Goblin.png'); }
        #knight-sprite.attack { transform: translateX(15px) scale(1.05); }
        #knight-sprite.level-up { filter: drop-shadow(0 0 6px yellow); }
        #goblin-sprite.attack { transform: translateX(-15px) scale(1.05); }
        #goblin-sprite.defeat { transform: rotate(-90deg) translateY(20px); opacity: 0.6; }
        .hp-bar-container { width: clamp(80px, 20vw, 110px); height: 15px; background-color: #555; border: 1px solid #222; border-radius: 3px; overflow: hidden; margin: 0 auto 3px auto; }
        .hp-bar { height: 100%; width: 100%; transition: width 0.3s ease-out; }
        .hp-bar.knight { background-color: #4a90e2; }
        .hp-bar:not(.knight) { background-color: #d0021b; }
        .hp-text { font-size: clamp(0.8em, 2.5vw, 0.9em); font-weight: bold; color: #fff; text-shadow: 1px 1px #111; }
        #status-area { display: flex; flex-wrap: wrap; justify-content: space-evenly; padding: clamp(6px, 2vw, 8px); margin-bottom: 10px; /* Reduced margin */ background-color: #6b4f41; border-radius: 4px; border: 1px solid #4b3f31; font-size: clamp(0.8em, 2.5vw, 0.9em); }
        #status-area span { margin: 3px 8px; font-weight: bold; color: #fff; text-shadow: 1px 1px #111; }
        #sharpen-indicator { color: orange; font-style: italic; }

        /* --- Shop Area --- */
        #shop-area {
            display: flex;
            justify-content: center;
            gap: 15px; /* Space between buttons */
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        #shop-area button {
            padding: 8px 12px; font-size: 0.9em; cursor: pointer;
            background-color: #6a4b3a; border: 2px solid #3b2f21; color: #fff;
            border-radius: 4px; transition: background-color 0.2s, opacity 0.2s;
            line-height: 1.3; /* Improve readability */
        }
        #shop-area button:hover:not(:disabled) { background-color: #5a3b2a; }
        #shop-area button:disabled { background-color: #777; color: #aaa; cursor: not-allowed; opacity: 0.6; }
        /* ----------------- */

        #problem-area { background-color: #6b4f41; padding: clamp(10px, 3vw, 15px); border-radius: 5px; border: 2px solid #4b3f31; margin-bottom: 15px; }
        #math-problem { font-size: clamp(1.4em, 5vw, 1.9em); font-weight: bold; margin-bottom: 10px; color: #fff; text-shadow: 1px 1px #222; word-wrap: break-word; }
        #answer-input { width: clamp(60px, 20vw, 90px); padding: clamp(6px, 2vw, 9px); font-size: clamp(1.2em, 4vw, 1.6em); text-align: center; border: 2px solid #4b3f31; border-radius: 4px; margin-right: 10px; margin-bottom: 5px; -moz-appearance: textfield; }
        #answer-input::-webkit-outer-spin-button, #answer-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        #submit-button { padding: clamp(8px, 2.5vw, 12px) clamp(15px, 4vw, 20px); font-size: clamp(1em, 3.5vw, 1.3em); background-color: #a0522d; border: 2px solid #1a0f0c; color: white; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; vertical-align: top; margin-bottom: 5px; }
        #submit-button:hover:not(:disabled) { background-color: #8B4513; }
        #submit-button:disabled { background-color: #888; cursor: not-allowed; }

        #feedback-area { margin-top: 10px; min-height: 20px; /* Reduced height */ font-size: clamp(0.9em, 3vw, 1.1em); font-weight: bold; }
        .feedback-correct { color: #33FF57; text-shadow: 1px 1px #114411; }
        .feedback-incorrect { color: #FF5733; text-shadow: 1px 1px #441111; }
        .feedback-levelup { color: #ffd700; text-shadow: 1px 1px #443300; }
        .feedback-purchase { color: #87CEEB; text-shadow: 1px 1px #112233;} /* Sky blue for purchases */


        /* Overlay Styles */
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; text-align: center; z-index: 100; padding: 20px; box-sizing: border-box; font-family: 'Verdana', sans-serif; display: none; }
         .overlay h2 { color: #ffd700; margin-bottom: 20px; text-shadow: 2px 2px #553300; font-size: clamp(1.8em, 6vw, 2.5em); }
         .overlay p { margin-bottom: 25px; font-size: clamp(1em, 3vw, 1.2em); line-height: 1.6; max-width: 600px; }
         .overlay button { padding: clamp(10px, 3vw, 14px) clamp(20px, 5vw, 28px); font-size: clamp(1em, 3.5vw, 1.2em); cursor: pointer; background-color: #a0522d; border: 3px solid #1a0f0c; color: white; border-radius: 5px; font-family: 'Verdana', sans-serif; transition: background-color 0.2s; box-shadow: 3px 3px 0px #1a0f0c; }
         .overlay button:hover { background-color: #8B4513; }
         .overlay button:active { transform: translate(2px, 2px); box-shadow: 1px 1px 0px #1a0f0c; }
         #start-screen { display: flex; }

    </style>
</head>
<body>
    <!-- Game Container -->
    <div id="game-container">
        <button id="fullscreen-button" title="Toggle Fullscreen">⛶</button>
        <h1>Medieval Math Duel</h1>
        <div id="duel-area"> <div class="character" id="knight"> <div class="sprite" id="knight-sprite"></div> <div class="hp-bar-container"><div class="hp-bar knight" id="knight-hp-bar"></div></div> <div class="hp-text" id="knight-hp-text">HP: 20/20</div> </div> <div class="character" id="goblin"> <div class="sprite" id="goblin-sprite"></div> <div class="hp-bar-container"><div class="hp-bar" id="goblin-hp-bar"></div></div> <div class="hp-text" id="goblin-hp-text">HP: 15/15</div> </div> </div>
        <div id="status-area"> <span id="level-display">Level: 1</span> <span id="xp-display">XP: 0 / 15</span> <span id="gold-display">Gold: 0</span> <span id="sharpen-indicator" style="display: none;">Sword Sharpened!</span></div>

        <!-- Permanent Shop Area -->
        <div id="shop-area">
            <button id="buy-potion-button">Potion (${POTION_COST}g)<br/>+${POTION_HEAL_AMOUNT} HP</button>
            <button id="buy-sharpen-button">Sharpen (${SHARPEN_COST}g)<br/>+${SHARPEN_BONUS_ATTACK} ATK (Next Turn)</button>
            <!-- Add more shop items here later -->
        </div>
        <!-- End Shop Area -->

        <div id="problem-area"> <div id="math-problem"> Solve: 5 + 3 = ?</div> <input type="tel" pattern="[0-9\-]*" inputmode="numeric" id="answer-input" autofocus> <button id="submit-button">Attack!</button> </div>
        <div id="feedback-area"></div>

        <!-- Overlays moved inside game container -->
        <div id="start-screen" class="overlay"> <h2>Math Duel!</h2> <p>Your Knight faces a fearsome Goblin!...<br>Use Gold for Potions or to Sharpen your blade!<br>Defeat Goblins to gain XP, Gold and Level Up!...</p> <button id="start-button">Begin Duel!</button> </div>
        <div id="game-over-screen" class="overlay"> <h2 id="game-over-title">Defeat!</h2> <p id="game-over-message">The Goblin overcame thy Knight!</p> <button id="restart-button">Try Again?</button> </div>
    </div> <!-- End of game-container -->

    <script>
        // --- DOM Elements ---
        const gameContainer = document.getElementById('game-container');
        const knightSprite = document.getElementById('knight-sprite');
        const goblinSprite = document.getElementById('goblin-sprite');
        const knightHpBar = document.getElementById('knight-hp-bar');
        const knightHpText = document.getElementById('knight-hp-text');
        const goblinHpBar = document.getElementById('goblin-hp-bar');
        const goblinHpText = document.getElementById('goblin-hp-text');
        const mathProblemDisplay = document.getElementById('math-problem');
        const answerInput = document.getElementById('answer-input');
        const submitButton = document.getElementById('submit-button');
        const feedbackArea = document.getElementById('feedback-area');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const gameOverTitle = document.getElementById('game-over-title');
        const gameOverMessage = document.getElementById('game-over-message');
        const levelDisplay = document.getElementById('level-display');
        const xpDisplay = document.getElementById('xp-display');
        const goldDisplay = document.getElementById('gold-display');
        const sharpenIndicator = document.getElementById('sharpen-indicator');
        const fullscreenButton = document.getElementById('fullscreen-button');
        // Shop Buttons
        const buyPotionButton = document.getElementById('buy-potion-button');
        const buySharpenButton = document.getElementById('buy-sharpen-button');

        // --- Game Config ---
        const KNIGHT_MAX_HP_BASE = 20; const GOBLIN_MAX_HP_BASE = 15;
        const KNIGHT_ATTACK_BASE = 3; const GOBLIN_ATTACK_BASE = 2;
        const KNIGHT_HP_PER_LEVEL = 5; const KNIGHT_ATK_PER_LEVEL = 1;
        const GOBLIN_HP_PER_LEVEL = 4; const GOBLIN_ATK_PER_LEVEL = 1;
        const BASE_MAX_NUMBER = 8; const NUMBER_INCREASE_PER_LEVEL = 4;
        const MULTIPLICATION_UNLOCK_LEVEL = 3; const MAX_MULTIPLICATION_FACTOR = 4;
        const MULT_FACTOR_INCREASE_PER_LEVEL = 1;
        const XP_PER_GOBLIN_BASE = 10; const GOLD_PER_GOBLIN_BASE = 5;
        const XP_LEVEL_BONUS_FACTOR = 1.5; const GOLD_LEVEL_BONUS = 2;
        const BASE_XP_TO_LEVEL = 15; const XP_LEVEL_SCALING_FACTOR = 1.5;
        const POTION_COST = 15; const POTION_HEAL_AMOUNT = 10;
        const SHARPEN_COST = 20; const SHARPEN_BONUS_ATTACK = 2;
        const FEEDBACK_DURATION = 2000; // ms for temporary feedback messages

        // --- Game State ---
        let knightMaxHp = KNIGHT_MAX_HP_BASE; let knightAttack = KNIGHT_ATTACK_BASE;
        let goblinMaxHp = GOBLIN_MAX_HP_BASE; let goblinAttack = GOBLIN_ATTACK_BASE;
        let knightHp = KNIGHT_MAX_HP_BASE; let goblinHp = GOBLIN_MAX_HP_BASE;
        let currentProblem = { num1: 0, num2: 0, operator: '+', answer: 0 };
        let isGameOver = true; let processingAnswer = false;
        let playerLevel = 1; let playerXP = 0; let xpToNextLevel = BASE_XP_TO_LEVEL;
        let playerGold = 0;
        let isSwordSharpened = false;
        let feedbackTimeoutId = null; // To clear temporary feedback messages

        // --- Functions ---

        function calculateXpNeeded(level) { /* ... no change ... */ return BASE_XP_TO_LEVEL + Math.floor(Math.pow(level -1, XP_LEVEL_SCALING_FACTOR) * 5); }

        function updatePlayerStatsForLevel(healPlayer = false) {
             knightMaxHp = KNIGHT_MAX_HP_BASE + (playerLevel - 1) * KNIGHT_HP_PER_LEVEL;
             knightAttack = KNIGHT_ATTACK_BASE + (playerLevel - 1) * KNIGHT_ATK_PER_LEVEL;
             if (healPlayer) { knightHp = knightMaxHp; console.log("Knight Healed on Level Up!"); }
             else { knightHp = Math.min(knightHp, knightMaxHp); }
             goblinMaxHp = GOBLIN_MAX_HP_BASE + (playerLevel - 1) * GOBLIN_HP_PER_LEVEL;
             goblinAttack = GOBLIN_ATTACK_BASE + (playerLevel - 1) * GOBLIN_ATK_PER_LEVEL;
             goblinHp = goblinMaxHp;
             console.log(`Stats Lvl ${playerLevel}: K HP=${knightHp}/${knightMaxHp}, ATK=${knightAttack} | G HP=${goblinHp}/${goblinMaxHp}, ATK=${goblinAttack}`);
             updateHpDisplay('knight'); updateHpDisplay('goblin');
             updatePurchaseButtonStates(); // Update buttons as Max HP might change
        }

        function startNewDuel() {
            console.log("Starting New Duel...");
            updatePlayerStatsForLevel(false); // Update stats but DON'T heal

            isGameOver = false;
            processingAnswer = false;
            clearTemporaryFeedback(); // Clear any lingering feedback

            updateHpDisplay('knight'); updateHpDisplay('goblin');
            knightSprite.classList.remove('attack', 'level-up');
            goblinSprite.classList.remove('attack', 'defeat');
            goblinSprite.style.opacity = 1;

            answerInput.value = '';
            submitButton.disabled = false; answerInput.disabled = false;

            xpToNextLevel = calculateXpNeeded(playerLevel);
            updateStatusDisplay(); // Includes button state update
            generateProblem(); displayProblem();

            startScreen.style.display = 'none'; gameOverScreen.style.display = 'none';

            setTimeout(() => { if(!isGameOver) answerInput.focus(); }, 100);
            console.log(`Duel Started. Lvl:${playerLevel}, XP:${playerXP}/${xpToNextLevel}, Gold:${playerGold}, Sharpened:${isSwordSharpened}`);
        }

        function resetGameFull() {
             playerLevel = 1; playerXP = 0; playerGold = 0; isSwordSharpened = false;
             xpToNextLevel = calculateXpNeeded(playerLevel);
             knightHp = KNIGHT_MAX_HP_BASE; // Reset HP on full reset
             startNewDuel();
        }

        function updateStatusDisplay() {
            levelDisplay.textContent = `Level: ${playerLevel}`;
            xpDisplay.textContent = `XP: ${playerXP} / ${xpToNextLevel}`;
            goldDisplay.textContent = `Gold: ${playerGold}`;
            sharpenIndicator.style.display = isSwordSharpened ? 'inline' : 'none';
            updatePurchaseButtonStates(); // Update button states whenever status changes
        }

        function generateProblem() { /* ... no change ... */ let n1, n2, op, ans; let max = BASE_MAX_NUMBER + (playerLevel - 1) * NUMBER_INCREASE_PER_LEVEL; let ops = ['+', '-']; if (playerLevel >= MULTIPLICATION_UNLOCK_LEVEL) ops.push('*'); op = ops[Math.floor(Math.random() * ops.length)]; switch(op) { case '+': n1=~~(Math.random()*(max+1)); n2=~~(Math.random()*(max+1)); ans=n1+n2; break; case '-': n1=~~(Math.random()*(max+1)); n2=~~(Math.random()*(n1+1)); ans=n1-n2; break; case '*': let lfb=Math.max(0,playerLevel-MULTIPLICATION_UNLOCK_LEVEL); const f1=MAX_MULTIPLICATION_FACTOR+lfb*MULT_FACTOR_INCREASE_PER_LEVEL; const f2=Math.max(2,MAX_MULTIPLICATION_FACTOR+~~(lfb/2)); n1=~~(Math.random()*(f1+1)); n2=~~(Math.random()*(f2+1)); if(n1==0&&Math.random()<0.4) n1=1; if(n2==0&&Math.random()<0.4) n2=1; ans=n1*n2; break; } currentProblem = { num1:n1, num2:n2, operator:op, answer:ans }; console.log(`Lvl ${playerLevel} Problem: ${n1} ${op} ${n2} = ? (Ans: ${ans})`);}
        function displayProblem() { /* ... no change ... */ const op = currentProblem.operator === '*' ? '×' : currentProblem.operator; mathProblemDisplay.textContent = `Solve: ${currentProblem.num1} ${op} ${currentProblem.num2} = ?`; }
        function updateHpDisplay(char) { /* ... no change ... */ let cur, max, bar, txt; if(char==='knight'){cur=knightHp;max=knightMaxHp;bar=knightHpBar;txt=knightHpText;}else{cur=goblinHp;max=goblinMaxHp;bar=goblinHpBar;txt=goblinHpText;} const pct=Math.max(0,(cur/max)*100); bar.style.width=`${pct}%`; txt.textContent=`HP: ${Math.max(0,cur)}/${max}`; updatePurchaseButtonStates(); /* Update buttons when HP changes */ }
        function triggerAnimation(el, anim) { /* ... no change ... */ if(el.classList.contains('defeat')&&anim!=='defeat')return; if(el.classList.contains('level-up')&&anim!=='level-up')return; el.classList.remove('attack','level-up'); el.classList.add(anim); let delay=(anim==='level-up')?1000:200; if(anim!=='defeat'){setTimeout(()=>{if(el)el.classList.remove(anim);},delay);} }

        // --- Temporary Feedback ---
        function showTemporaryFeedback(message, typeClass = '', duration = FEEDBACK_DURATION) {
            clearTemporaryFeedback(); // Clear previous message timeout
            feedbackArea.textContent = message;
            feedbackArea.className = typeClass; // Apply class for styling
            feedbackTimeoutId = setTimeout(() => {
                if (feedbackArea.textContent === message) { // Only clear if it's the same message
                    feedbackArea.textContent = '';
                    feedbackArea.className = '';
                }
            }, duration);
        }

        function clearTemporaryFeedback() {
            if (feedbackTimeoutId) {
                clearTimeout(feedbackTimeoutId);
                feedbackTimeoutId = null;
            }
             // Optionally clear text immediately too:
             // feedbackArea.textContent = '';
             // feedbackArea.className = '';
        }

        // --- Purchase Button State ---
        function updatePurchaseButtonStates() {
            if (!buyPotionButton || !buySharpenButton) return; // Safety check

            // Potion Button
            buyPotionButton.disabled = (playerGold < POTION_COST || knightHp >= knightMaxHp || isGameOver || processingAnswer);

            // Sharpen Button
            buySharpenButton.disabled = (playerGold < SHARPEN_COST || isSwordSharpened || isGameOver || processingAnswer);
        }

        // --- Purchase Actions ---
        function buyPotion() {
            if (buyPotionButton.disabled) return; // Extra safety

            playerGold -= POTION_COST;
            const healAmount = Math.min(POTION_HEAL_AMOUNT, knightMaxHp - knightHp); // Heal only up to max HP
            knightHp += healAmount;

            console.log(`Bought Potion. Healed ${healAmount}. HP: ${knightHp}/${knightMaxHp}. Gold: ${playerGold}`);
            showTemporaryFeedback(`Used Potion! +${healAmount} HP.`, 'feedback-purchase');
            updateStatusDisplay(); // Updates gold, calls updatePurchaseButtonStates
            updateHpDisplay('knight'); // Updates HP bar, calls updatePurchaseButtonStates
        }

         function buySharpen() {
             if (buySharpenButton.disabled) return; // Extra safety

             playerGold -= SHARPEN_COST;
             isSwordSharpened = true;
             console.log(`Bought Sharpening. Buff active! Gold: ${playerGold}`);
             showTemporaryFeedback(`Sword Sharpened! +${SHARPEN_BONUS_ATTACK} ATK next turn.`, 'feedback-purchase');
             updateStatusDisplay(); // Updates gold and indicator, calls updatePurchaseButtonStates
         }

        // --- Core Game Logic ---
        function handleSubmit() {
            if (isGameOver || processingAnswer) return;
            processingAnswer = true;
            submitButton.disabled = true; answerInput.disabled = true;
            updatePurchaseButtonStates(); // Disable shop buttons during processing
            clearTemporaryFeedback(); // Clear shop feedback if present
            // feedbackArea.textContent = ''; feedbackArea.className = ''; // Clear main feedback too

            const playerAnswerStr = answerInput.value.trim();
            const playerAnswer = parseInt(playerAnswerStr);

            if (playerAnswerStr === '' || isNaN(playerAnswer)) {
                showTemporaryFeedback('Please enter a valid number!', 'feedback-incorrect');
                processingAnswer = false; submitButton.disabled = false; answerInput.disabled = false;
                updatePurchaseButtonStates(); // Re-enable shop buttons
                answerInput.focus(); answerInput.select(); return;
            }

            let actualKnightAttack = knightAttack;
            if (isSwordSharpened) {
                console.log("Applying Sharpened Sword bonus!");
                actualKnightAttack += SHARPEN_BONUS_ATTACK;
                isSwordSharpened = false; // Use buff
                // Status display updated below or in next duel start
            }

            let outcomeDelay = 500; // Base delay

            if (playerAnswer === currentProblem.answer) { // Correct
                // Show immediate feedback, might be overwritten by level up/win
                feedbackArea.textContent = 'Correct!'; feedbackArea.className = 'feedback-correct';
                triggerAnimation(knightSprite, 'attack');
                goblinHp -= actualKnightAttack;
                // HP display updated after delay

                setTimeout(() => { // Delay updates until after attack animation starts
                    updateHpDisplay('goblin');
                    console.log(`Correct. Knight dealt ${actualKnightAttack}. Goblin HP:`, Math.max(0, goblinHp));

                    if (goblinHp <= 0) { // Goblin Defeated
                        console.log("Goblin Defeated!"); triggerAnimation(goblinSprite, 'defeat');
                        let xpGained = XP_PER_GOBLIN_BASE + Math.floor((playerLevel-1) * XP_LEVEL_BONUS_FACTOR);
                        let goldGained = GOLD_PER_GOBLIN_BASE + (playerLevel - 1) * GOLD_LEVEL_BONUS;
                        playerXP += xpGained; playerGold += goldGained;
                        console.log(`Gained ${xpGained} XP, ${goldGained} Gold.`);
                        showTemporaryFeedback(`Goblin Vanquished! +${xpGained} XP, +${goldGained} Gold.`, 'feedback-correct', 2500); // Longer message

                        let leveledUpThisTurn = checkLevelUp(); // Check AFTER XP gain
                        updateStatusDisplay(); // Update display immediately

                        // Proceed IMMEDIATELY to next duel setup after delay
                        setTimeout(startNewDuel, leveledUpThisTurn ? 1200 : 800); // Longer delay if leveled up
                        // processingAnswer will be reset by startNewDuel

                    } else { // Goblin NOT defeated
                        generateProblem(); displayProblem(); answerInput.value = '';
                        submitButton.disabled = false; answerInput.disabled = false;
                        processingAnswer = false;
                        updatePurchaseButtonStates(); // Re-enable shop buttons
                        setTimeout(() => { if (!isGameOver) answerInput.focus(); }, 50);
                    }
                }, 200); // Short delay matching attack anim


            } else { // Incorrect
                feedbackArea.textContent = `Incorrect! Answer was ${currentProblem.answer}.`; feedbackArea.className = 'feedback-incorrect';
                triggerAnimation(goblinSprite, 'attack');
                knightHp -= goblinAttack;
                // HP display updated after delay

                 setTimeout(() => { // Delay updates until after attack animation starts
                     updateHpDisplay('knight');
                     console.log("Incorrect. Knight HP:", Math.max(0, knightHp));

                     if (knightHp <= 0) { // Knight Defeated
                        setTimeout(() => gameOver(false), 600); // Delay before showing loss screen
                        processingAnswer = false; // Allow restart etc.
                     } else { // Knight NOT defeated
                        generateProblem(); displayProblem(); answerInput.value = '';
                        submitButton.disabled = false; answerInput.disabled = false;
                        processingAnswer = false;
                        updatePurchaseButtonStates(); // Re-enable shop buttons
                        setTimeout(() => { if (!isGameOver) answerInput.focus(); }, 50);
                     }
                 }, 200); // Short delay matching attack anim
            }
        }

        function checkLevelUp() {
            let leveledUp = false;
            while (playerXP >= xpToNextLevel) {
                leveledUp = true;
                playerXP -= xpToNextLevel;
                playerLevel++;
                xpToNextLevel = calculateXpNeeded(playerLevel);
                updatePlayerStatsForLevel(true); // Pass true to HEAL player
                showTemporaryFeedback(`LEVEL UP! Level ${playerLevel}! Knight Healed!`, 'feedback-levelup', 2500); // Longer message
                triggerAnimation(knightSprite, 'level-up');
                // HP display updated inside updatePlayerStatsForLevel
            }
            // Status display updated after this in handleSubmit if needed
            return leveledUp;
        }

        function gameOver(playerWon) { // Only called on player loss
             console.log("--- Game Over --- Player Won:", playerWon);
             isGameOver = true; submitButton.disabled = true; answerInput.disabled = true;
             xpToNextLevel = calculateXpNeeded(playerLevel);
             clearTemporaryFeedback(); feedbackArea.textContent = ''; feedbackArea.className = '';
             updatePurchaseButtonStates(); // Disable shop buttons

             if (!playerWon) {
                 gameOverTitle.textContent = "Defeat!";
                 gameOverMessage.innerHTML = `Alas, the Level ${playerLevel} Goblin overcame thy Knight!<br>Final Stats: Level ${playerLevel}, XP ${playerXP}/${xpToNextLevel}, Gold ${playerGold}.`;
                 gameOverScreen.style.display = 'flex';
             } else { console.error("gameOver(true) called unexpectedly!"); }
         }

        function toggleFullscreen() { /* ... no change ... */ if(!gameContainer)return; try{if(!document.fullscreenElement){if(gameContainer.requestFullscreen)gameContainer.requestFullscreen().catch(err=>console.error(`FS request failed: ${err.message}`,err));}else{if(document.exitFullscreen)document.exitFullscreen().catch(err=>console.error(`Exit FS failed: ${err.message}`,err));}}catch(error){console.error("Error toggling fullscreen:",error);} }

        // --- Event Listeners ---
        submitButton.addEventListener('click', handleSubmit);
        answerInput.addEventListener('keyup', function(event) { if (event.key === 'Enter' && !submitButton.disabled && !processingAnswer) { event.preventDefault(); handleSubmit(); } }); // Added processing check
        startButton.onclick = () => { resetGameFull(); };
        restartButton.onclick = () => { resetGameFull(); }; // Make restart button on loss screen do a FULL reset
        if (fullscreenButton) { fullscreenButton.addEventListener('click', toggleFullscreen); } else { console.error("FS button not found!"); }
        document.addEventListener('fullscreenchange', () => { if (fullscreenButton) { fullscreenButton.textContent = document.fullscreenElement ? '✕' : '⛶'; fullscreenButton.title = document.fullscreenElement ? 'Exit FS' : 'Enter FS'; } });
        document.addEventListener('keydown', function(event) { if (isGameOver && gameOverScreen.style.display === 'flex') { if (event.key === 'Enter' || event.key === ' ') { event.preventDefault(); resetGameFull(); } } }); // Make keyboard restart a FULL reset too

        // Shop Button Listeners
        buyPotionButton.addEventListener('click', buyPotion);
        buySharpenButton.addEventListener('click', buySharpen);


        // --- Initial Setup on Load ---
         window.onload = () => {
             gameOverScreen.style.display = 'none';
             startScreen.style.display = 'flex';
             answerInput.disabled = true; submitButton.disabled = true; isGameOver = true;
             updatePlayerStatsForLevel(true); // Set initial Lvl 1 stats & FULLY HEAL
             xpToNextLevel = calculateXpNeeded(playerLevel); updateStatusDisplay();
             if (!fullscreenButton) console.warn("FS button element not found during init.");
             console.log("Game loaded. Waiting for player to start.");
             // Set initial text on buttons
             buyPotionButton.innerHTML = `Potion (${POTION_COST}g)<br/>+${POTION_HEAL_AMOUNT} HP`;
             buySharpenButton.innerHTML = `Sharpen (${SHARPEN_COST}g)<br/>+${SHARPEN_BONUS_ATTACK} ATK (Next Turn)`;
             updatePurchaseButtonStates(); // Set initial disabled state
         };

    </script>
</body>
</html>

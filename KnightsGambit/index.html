<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Knight's Gambit (Fixed v3)</title>
    <style>
        :root {
             --initial-grid-cols: 8;
             --initial-grid-rows: 10;
            --board-aspect-ratio: var(--initial-grid-cols) / var(--initial-grid-rows);
            font-size: clamp(8px, 1.8vmin, 16px);
            --death-fade-time: 1s;
            --attack-anim-time: 0.08s;
            --move-anim-time: 0.25s;
            --arrow-fly-time: 0.3s;
            --fireball-fly-time: 0.4s;
            --fireball-explode-time: 0.8s;
            --flame-wave-stagger-delay: 50ms;
            --frost-nova-hover-bg: rgba(100, 150, 255, 0.3);
            --frost-nova-hover-border: rgba(150, 200, 255, 0.7);
            --frozen-filter-base: brightness(0.9) sepia(1) hue-rotate(180deg) saturate(5);
            --frozen-filter-shadow: drop-shadow(0 0 2px rgba(150, 220, 255, 0.9));
            --frozen-filter: var(--frozen-filter-base) var(--frozen-filter-shadow);
            --spell-locked-filter: grayscale(80%) brightness(0.6) saturate(3) hue-rotate(350deg) contrast(0.9);
            --spell-used-filter: grayscale(90%) brightness(60%);
            --hover-outline-color-player: yellow;
            --hover-outline-color-enemy: red;
            --heal-color: #50ff50;
            --cell-size: 30px;
            --gold-color: #FFD700;
            --stack-offset-x: 3px;
            --stack-offset-y: -3px;
            --tooltip-bg: rgba(10, 10, 10, 0.70);
            --tooltip-text: #eee;
            --tooltip-border: #555;
            --tooltip-shadow: 2px 2px 6px rgba(0, 0, 0, 0.6);
            --attack-target-bg: rgba(235, 0, 0, 0.1);
            --attack-target-border: rgba(255, 80, 80, 0.8);
            --chest-size-factor: 0.7;
            --chest-sprite-width: 40px;
            --chest-sprite-height: 40px;
        }
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }
        body { display: flex; justify-content: center; align-items: center; background-color: #3a4a3a; font-family: 'Courier New', Courier, monospace; color: #eee; padding: 5px; box-sizing: border-box; position: relative; }
        #game-container { display: flex; max-width: 100%; max-height: 100%; width: 100%; height: 100%; border: clamp(2px, 0.5vmin, 5px) solid #1e281e; background-color: #1e281e; box-shadow: 0 0 15px rgba(0, 0, 0, 0.5); flex-direction: row; align-items: stretch; justify-content: center; padding: clamp(3px, 1vmin, 10px); box-sizing: border-box; gap: clamp(5px, 1vmin, 10px); position: relative; }
        #game-container:fullscreen { padding: 0; border: none; gap: 5px; width: 100vw; height: 100vh; max-width: 100vw; max-height: 100vh; }
        #game-container:fullscreen > #ui-panel { border-left-color: #333; }
        #game-board { border: clamp(1px, 0.3vmin, 2px) solid #1e281e; position: relative; flex-grow: 0; flex-shrink: 1; aspect-ratio: var(--board-aspect-ratio); max-width: 100%; max-height: 100%; box-sizing: border-box; min-width: 160px; min-height: calc(160px / var(--board-aspect-ratio)); overflow: hidden; cursor: grab; user-select: none; -webkit-user-drag: none; }
        #game-board.panning { cursor: grabbing; }
        #grid-content { position: absolute; top: 0; left: 0; display: grid; grid-template-columns: repeat(var(--grid-cols, 8), 1fr); grid-template-rows: repeat(var(--grid-rows, 10), 1fr); image-rendering: pixelated; background-color: #2a3a2a; transform-origin: top left; }		
		#board-feedback-area {
			position: absolute;
			top: 15%;
			left: 50%;
			transform: translateX(-50%);
			min-height: 2.5rem;
			font-size: clamp(1.8rem, 3.5vmin, 2.5rem);
			font-weight: bold;
			color: #fff;
			text-align: center;
			z-index: 40;
			pointer-events: none;
			text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
			width: 80%; /* You might want to adjust this if it looks too wide */
			max-width: 600px; /* Or adjust this */
			transition: opacity 0.5s ease-out;
			opacity: 1;
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 8px;
}
		
        #board-feedback-area .feedback-gold-icon { height: 1.2em; width: auto; vertical-align: middle; image-rendering: pixelated; }
        #board-feedback-area.feedback-levelup { color: #ffd700; text-shadow: 1px 1px #443300, 1px 1px 3px rgba(0,0,0,0.7); }
        #board-feedback-area.feedback-error { color: #ff8888; text-shadow: 1px 1px #550000, 1px 1px 3px rgba(0,0,0,0.7); }
        #board-feedback-area.feedback-gold { color: var(--gold-color); text-shadow: 1px 1px #6b5700, 1px 1px 3px rgba(0,0,0,0.7); }
        #board-feedback-area.feedback-cheat { color: lime; text-shadow: 1px 1px #004400, 1px 1px 3px rgba(0,0,0,0.7); }
        #game-board.fireball-targeting #grid-content { cursor: crosshair !important; }
        #game-board.fireball-targeting .grid-cell:hover:not(.has-obstacle) { background-color: rgba(255, 100, 100, 0.4) !important; box-shadow: inset 0 0 0 2px rgba(255, 0, 0, 0.7); }
        #game-board.flame-wave-targeting .grid-cell:hover:not(.has-obstacle) { background-color: rgba(255, 150, 50, 0.3) !important; box-shadow: none; }
        #game-board.frost-nova-targeting #grid-content { cursor: cell !important; }
        #game-board.frost-nova-targeting .grid-cell:hover:not(.has-obstacle) { background-color: transparent !important; box-shadow: none; }
        #game-board.frost-nova-targeting .grid-cell.frost-aoe-preview:not(.has-obstacle) { background-color: var(--frost-nova-hover-bg) !important; box-shadow: inset 0 0 0 1px var(--frost-nova-hover-border); z-index: 2; }
        #game-board.heal-targeting #grid-content { cursor: help !important; }
        #game-board.heal-targeting .unit.player:not(.dead):not(.acted):not(.frozen):hover { filter: drop-shadow(0 0 3px var(--heal-color)); box-shadow: 0 0 0 2px var(--heal-color); }
        .grid-cell { border: 1px solid rgba(60, 80, 60, 0.25); background-image: url('./sprites/tile_grass.png'); background-size: cover; background-position: center; position: relative; display: flex; justify-content: center; align-items: center; transition: background-color 0.2s, box-shadow 0.2s; box-sizing: border-box; image-rendering: pixelated; min-width: 1px; min-height: 1px; overflow: hidden; width: var(--cell-size); height: var(--cell-size); }
        .grid-cell.valid-move:not(.has-obstacle) { background-color: rgba(170, 234, 170, 0.3); opacity: 0.8; }
        .grid-cell.valid-attack-target:not(.has-obstacle) { background-color: var(--attack-target-bg); box-shadow: inset 0 0 0 1px var(--attack-target-border); z-index: 1; }
        .grid-cell.has-obstacle, .grid-cell.has-item { background-color: rgba(255, 255, 255, 0.1); }
        .grid-cell.has-obstacle { cursor: not-allowed !important; background-image: none; }
        .obstacle, .item, .unit, .projectile, .fireball-explosion, .damage-popup, .freeze-popup, .heal-popup { position: absolute; pointer-events: none; image-rendering: pixelated; box-sizing: border-box; background-size: contain; background-repeat: no-repeat; background-position: center; transform-origin: center center; }
        .unit { left: calc((var(--unit-x) - 0.5) * var(--cell-size)); top: calc((var(--unit-y) - 0.5) * var(--cell-size)); transform: translate(-50%, -50%); border-radius: 3px; display: flex; justify-content: center; align-items: center; font-weight: bold; z-index: 10; transition: filter 0.2s, box-shadow 0.2s, width 0.1s, height 0.1s, opacity var(--death-fade-time) ease-in-out, background-image 0.1s ease-in, transform var(--move-anim-time) ease-out, left var(--move-anim-time) ease-out, top var(--move-anim-time) ease-out; background-color: transparent; width: calc(var(--cell-size) * 0.8); height: calc(var(--cell-size) * 0.8); opacity: 1; filter: none; }
        #grid-content .unit { pointer-events: auto; }
        #grid-content .unit:not(.dead):not(.fading-out):not(.selected):not(.is-moving):hover { z-index: 12; cursor: pointer !important; }
        #grid-content .unit.player:not(.dead):not(.fading-out):not(.selected):not(.is-moving):not(.frozen):hover { filter: drop-shadow(1px 0px 0 var(--hover-outline-color-player)) drop-shadow(-1px 0px 0 var(--hover-outline-color-player)) drop-shadow(0px 1px 0 var(--hover-outline-color-player)) drop-shadow(0px -1px 0 var(--hover-outline-color-player)); }
        #grid-content .unit.enemy:not(.dead):not(.fading-out):not(.selected):not(.is-moving):not(.frozen):hover { filter: drop-shadow(1px 0px 0 var(--hover-outline-color-enemy)) drop-shadow(-1px 0px 0 var(--hover-outline-color-enemy)) drop-shadow(0px 1px 0 var(--hover-outline-color-enemy)) drop-shadow(0px -1px 0 var(--hover-outline-color-enemy)); }
        .unit.is-moving { z-index: 15; transition: filter 0.2s, box-shadow 0.2s, width 0.1s, height 0.1s, opacity var(--death-fade-time) ease-in-out, background-image 0.1s ease-in, left var(--move-anim-time) ease-out, top var(--move-anim-time) ease-out; }
        .unit.selected { box-shadow: 0 0 0 clamp(1px, 0.5vmin, 3px) yellow; z-index: 13; }
        .unit.selected:not(:hover) { filter: drop-shadow(0 0 3px yellow); }
        .unit.acted:not(:hover):not(.is-moving):not(.frozen) { filter: grayscale(50%) brightness(80%); }
        .unit.frozen:not(.is-moving) { filter: var(--frozen-filter); }
        .unit.selected.frozen:not(.is-moving) { filter: var(--frozen-filter) drop-shadow(0 0 3px yellow); box-shadow: 0 0 0 clamp(1px, 0.5vmin, 3px) yellow; }
        .unit.unit-hit-flash { animation: simple-hit-flash 0.2s ease-out; } @keyframes simple-hit-flash { 50% { filter: brightness(1.8); } }
        .unit.dead { z-index: 5; pointer-events: none !important; filter: none !important; box-shadow: none !important; opacity: 1; transition: opacity var(--death-fade-time) ease-in-out, left 0.1s, top 0.1s, transform 0.1s; transform: translate(-50%, -50%) !important; }
        .unit.fading-out { opacity: 0 !important; }
        .obstacle { left: calc((var(--obs-x) - 0.5) * var(--cell-size)); top: calc((var(--obs-y) - 0.5) * var(--cell-size)); transform: translate(-50%, -50%); width: var(--cell-size); height: var(--cell-size); z-index: 2; transition: width 0.1s, height 0.1s, left 0.1s, top 0.1s, transform 0.1s; }
        .obstacle.rock { width: calc(var(--cell-size) * 0.8); height: calc(var(--cell-size) * 0.8); background-image: url('./sprites/rock.png'); }
        .obstacle.wall_rock { background-image: url('./sprites/wall_rock.png'); }
        .item { left: calc((var(--item-x) - 0.5) * var(--cell-size)); top: calc((var(--item-y) - 0.5) * var(--cell-size)); transform: translate(calc(-50% + var(--stackIndex, 0) * var(--stack-offset-x)), calc(-50% + var(--stackIndex, 0) * var(--stack-offset-y))); width: calc(var(--cell-size) * 0.6); height: calc(var(--cell-size) * 0.6); z-index: 6; transition: width 0.1s, height 0.1s,
            opacity 0.3s ease-out,
            left 0.1s, top 0.1s,
            transform 0.3s cubic-bezier(0.45, 0.05, 0.55, 0.95),
            background-position 0.2s steps(1); opacity: 1; --stackIndex: 0; }
        .item.gold-coin { background-image: url('./sprites/gold.png'); }
        .item.chest { background-image: url('./sprites/chest.png'); width: calc(var(--cell-size) * var(--chest-size-factor)); height: calc(var(--cell-size) * var(--chest-size-factor)); background-size: 200% 100%; background-position: 0 0; z-index: 7; }
        .item.chest.opened { background-position: 100% 0%; }
        .projectile { z-index: 22; }
        .projectile.arrow { width: 26px; height: 7px; background-image: url('./sprites/arrow.png'); transition: left var(--arrow-fly-time) linear, top var(--arrow-fly-time) linear; }
        .projectile.fireball-projectile { background-image: url('./sprites/sFireball1.png'); width: 72px; height: 72px; transition: left var(--fireball-fly-time) linear, top var(--fireball-fly-time) linear; z-index: 23; }
        .fireball-explosion { width: 120px; height: 120px; background-image: url('./sprites/fireball_explode.png'); background-repeat: no-repeat; background-position: 0 0; z-index: 25; pointer-events: none; image-rendering: pixelated; transform: scale(0.75) translate(-50%, -50%); transform-origin: center center; animation: fireball-explode-anim var(--fireball-explode-time) steps(8) forwards; }
        @keyframes fireball-explode-anim { from { background-position: 0 0; } to { background-position: -960px 0; } }
        .damage-popup, .freeze-popup, .heal-popup { font-weight: bold; animation: moveUpFadeOut 1s forwards; z-index: 50; pointer-events: none; transform: translateX(-50%); }
        .damage-popup { color: red; font-size: clamp(1.2rem, 2vmin, 1.8rem); text-shadow: 1px 1px white; }
        .freeze-popup { color: #aadeff; font-size: clamp(1.2rem, 2vmin, 1.6rem); text-shadow: 1px 1px #112233; animation-duration: 0.8s; }
        .heal-popup { color: var(--heal-color); font-size: clamp(1.2rem, 2vmin, 1.8rem); text-shadow: 1px 1px #003300; }
        @keyframes moveUpFadeOut { 0% { opacity: 1; transform: translateY(0) translateX(-50%); } 100% { opacity: 0; transform: translateY(-30px) translateX(-50%); } }
        #ui-panel { width: clamp(180px, 28vmin, 240px); flex-shrink: 0; max-height: 100%; padding: clamp(0.5rem, 1vmin, 1rem); background-color: #4a5a4a; border-left: clamp(1px, 0.4vmin, 3px) solid #1e281e; display: flex; flex-direction: column; overflow-y: auto; font-size: 1.4rem; box-sizing: border-box; position: relative; }
        #top-bar-ui { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.8rem; gap: 5px; flex-wrap: wrap; }
        #level-gold-container { display: flex; flex-direction: row; align-items: center; gap: 0.8rem; flex-grow: 1; flex-wrap: wrap; }
        #level-display, #actions-left-display, #gold-display-ui-panel { text-align: center; margin-bottom: 0; font-weight: bold; background-color: #5a6a5a; padding: 0.3rem 0.5rem; border: 1px solid #1e281e; border-radius: 3px; font-size: 1.4rem; white-space: nowrap; flex-shrink: 0; }
        #level-display { color: #ffd700; } #actions-left-display { color: #eee; } #gold-display-ui-panel { display: none; color: var(--gold-color); text-shadow: 1px 1px 1px #6b5700; }
        #menu-button { margin-left: auto; }
        .ui-button { padding: 3px 5px; background-color: rgba(30, 40, 30, 0.6); border: 1px solid #7a8a7a; color: #eee; font-size: 1.6rem; line-height: 1; border-radius: 3px; cursor: pointer; z-index: 55; transition: background-color 0.2s; min-width: 25px; min-height: 25px; display: inline-flex; justify-content: center; align-items: center; user-select: none; -webkit-tap-highlight-color: transparent; }
        .ui-button:hover:not(:disabled) { background-color: rgba(60, 80, 60, 0.8); } .ui-button:disabled { opacity: 0.5; cursor: not-allowed; }
        #unit-info { background-color: #5a6a5a; padding: 0.8rem; margin-bottom: 1rem; border: 1px solid #1e281e; border-radius: 3px; min-height: auto; display: flex; align-items: center; gap: 10px; }
        #unit-portrait { width: 48px; height: 48px; border: 1px solid #333; background-color: #444; background-size: contain; background-repeat: no-repeat; background-position: center; image-rendering: pixelated; flex-shrink: 0; border-radius: 2px; opacity: 0; transition: opacity 0.2s; }
        #unit-portrait[style*="url"] { opacity: 1; }
        #unit-details { display: flex; flex-direction: column; flex-grow: 1; font-size: 1.2rem; }
        #unit-info h3 { margin: 0 0 0.4rem 0; border-bottom: 1px solid #7a8a7a; padding-bottom: 0.3rem; color: #eee; font-size: 1.3rem; }
        #unit-info p { margin: 0.2rem 0; color: #ddd; line-height: 1.3; white-space: nowrap; }
        #unit-status { color: #aadeff; font-style: italic; min-height: 1.3em; }
        #spell-area { margin-top: auto; margin-bottom: 1.5rem; padding: clamp(0.5rem, 1vmin, 1rem); background-color: #5a6a5a; border: 1px solid #1e281e; border-radius: 3px; min-height: auto; display: grid; grid-template-columns: repeat(2, 1fr); gap: clamp(8px, 1.5vmin, 15px); place-items: center; align-content: center; }
        .spell-container { display: flex; flex-direction: column; align-items: center; text-align: center; width: 100%; }
        .spell-icon { position: relative; display: inline-block; width: clamp(30px, 4.5vmin, 40px); height: clamp(30px, 4.5vmin, 40px); border: clamp(1px, 0.3vmin, 2px) solid #333; border-radius: 4px; background-color: #444; background-size: contain; background-repeat: no-repeat; background-position: center; margin-bottom: 3px; transition: border-color 0.2s, box-shadow 0.2s, filter 0.2s; image-rendering: pixelated; vertical-align: middle; filter: none; cursor: default; box-shadow: none; overflow: hidden; }
        .spell-icon .hotkey-display { position: absolute; top: 0; left: 0; font-size: clamp(0.8rem, 1.3vmin, 1rem); font-weight: bold; color: var(--gold-color); background-color: rgba(0, 0, 0, 0.6); padding: 1px 3px; line-height: 1; border-bottom-right-radius: 3px; text-shadow: 1px 1px #332200; }
        #fireball-spell { background-image: url('./sprites/sFireball1.png'); } #flame-wave-spell { background-image: url('./sprites/flame_wave.png'); } #frost-nova-spell { background-image: url('./sprites/sFrostbolt1.png'); } #heal-spell { background-image: url('./sprites/heal.png'); }
        .spell-label { font-size: clamp(0.9rem, 1.5vmin, 1.1rem); font-weight: bold; color: #eee; text-shadow: 1px 1px #111; line-height: 1.2; }
        .spell-icon.locked { filter: var(--spell-locked-filter); cursor: not-allowed; border-color: #600; } .spell-icon.locked+.spell-label { color: #a85858; }
        .spell-icon.used { filter: var(--spell-used-filter); cursor: not-allowed; border-color: #555; } .spell-icon.used+.spell-label { color: #aaa; }
        .spell-icon.available { filter: none; cursor: pointer; border-color: #888; } .spell-icon.available:hover { border-color: #eee; } .spell-icon.available+.spell-label { color: #eee; }
        .spell-icon.selected { filter: none !important; cursor: pointer; border-color: yellow !important; box-shadow: 0 0 8px yellow !important; } .spell-icon.selected+.spell-label { color: #eee; }
        .spell-icon.cheat-available { border-color: lime !important; box-shadow: 0 0 5px lime !important; } .spell-icon.cheat-available+.spell-label { color: lime; }
        #end-turn-button { padding: 1rem 1.5rem; background-color: #a0522d; border: 2px solid #1e281e; color: white; font-family: 'Courier New', Courier, monospace; cursor: pointer; font-size: 1.4rem; border-radius: 3px; text-align: center; transition: background-color 0.2s; width: 100%; box-sizing: border-box; margin-top: auto; }
        #end-turn-button:hover:not(.disabled) { background-color: #8B4513; } #end-turn-button.disabled { background-color: #888; cursor: not-allowed; color: #bbb; }
        #end-turn-button.next-level-mode { background-color: #4CAF50; } #end-turn-button.next-level-mode:hover:not(.disabled) { background-color: #45a049; }
        #end-turn-button .hotkey-e { color: var(--gold-color); font-weight: bold; }
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: none; flex-direction: column; justify-content: center; align-items: center; color: white; text-align: center; z-index: 100; padding: 20px; box-sizing: border-box; } .overlay.visible { display: flex; }
        .overlay h2 { color: #ffd700; margin-bottom: 2rem; font-size: clamp(2rem, 6vmin, 2.5rem); } .overlay p { font-size: clamp(1.2rem, 4vmin, 1.5rem); line-height: 1.6; margin-bottom: 2rem; }
        .overlay button, #menu-overlay .overlay-button-like, #level-select-screen button { padding: clamp(0.8rem, 3vmin, 1rem) clamp(1.5rem, 6vmin, 2rem); font-size: clamp(1.2rem, 4vmin, 1.6rem); cursor: pointer; background-color: #a0522d; border: 2px solid #1e281e; color: white; font-family: 'Courier New', Courier, monospace; border-radius: 3px; margin-top: 1rem; }
        .overlay button:hover:not(:disabled), #menu-overlay .overlay-button-like:hover:not(:disabled), #level-select-screen button:hover:not(:disabled) { background-color: #8B4513; }
        #menu-overlay { background-color: rgba(0, 0, 0, 0.92); } #menu-overlay h2 { margin-bottom: 1.5rem; }
        #menu-overlay-content { display: flex; flex-direction: column; align-items: center; gap: 1rem; background-color: rgba(40, 50, 40, 0.7); padding: clamp(1.5rem, 4vmin, 2.5rem); border: 2px solid #7a8a7a; border-radius: 8px; width: 80%; max-width: 350px; }
        #menu-overlay #gold-display { color: var(--gold-color); text-shadow: 1px 1px 1px #6b5700; margin: 1rem 0; font-size: 1.5rem; font-weight: bold; text-align: center; background-color: rgba(30, 40, 30, 0.6); padding: 0.5rem 1rem; border: 1px solid #7a8a7a; border-radius: 3px; display: inline-flex; align-items: center; justify-content: center; }
        .gold-icon-menu { width: 1.2em; height: 1.2em; vertical-align: middle; margin-right: 6px; image-rendering: pixelated; }
        #menu-overlay #menu-buttons-container { display: flex; flex-direction: column; gap: 0.8rem; width: 100%; align-items: center; }
        #menu-overlay .menu-ui-button { padding: 8px 15px; font-size: 1.6rem; background-color: rgba(30, 40, 30, 0.8); border: 1px solid #7a8a7a; color: #eee; border-radius: 3px; cursor: pointer; min-width: 150px; text-align: center; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center; gap: 8px; width: 80%; box-sizing: border-box; }
        #menu-overlay .menu-ui-button:hover:not(:disabled) { background-color: rgba(60, 80, 60, 0.9); } #menu-overlay .menu-ui-button:disabled { opacity: 0.5; cursor: not-allowed; } #menu-overlay #close-menu-button { margin-top: 1.5rem; }
        #leaderboard-overlay ul { list-style: none; padding: 0; max-height: 60vh; overflow-y: auto; width: 80%; max-width: 400px; margin-bottom: 1rem; }
        #leaderboard-overlay li { background-color: rgba(255, 255, 255, 0.1); padding: 8px 12px; margin-bottom: 5px; border-radius: 3px; display: flex; justify-content: space-between; font-size: clamp(1rem, 3vmin, 1.3rem); } #leaderboard-overlay li span:first-child { font-weight: bold; color: #eee; } #leaderboard-overlay li span:last-child { color: var(--gold-color); }
        #level-select-screen { background-color: rgba(0, 0, 0, 0.9); }
        #level-select-container { display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; margin-top: 1.5rem; max-width: 400px; }
        #level-select-container button { min-width: 80px; padding: 10px 15px; font-size: 1.4rem; }
        #unit-tooltip { position: fixed; background-color: var(--tooltip-bg); color: var(--tooltip-text); border: 1px solid var(--tooltip-border); padding: 6px 10px; border-radius: 4px; font-size: 1.2rem; line-height: 1.4; z-index: 110; pointer-events: none; white-space: nowrap; opacity: 0; transition: opacity 0.15s ease-in-out; box-shadow: var(--tooltip-shadow); transform: translate(12px, 18px); }
        #unit-tooltip.visible { opacity: 1; } #unit-tooltip b { color: #f0e68c; display: block; margin-bottom: 3px; } #unit-tooltip span[style*="color:#aadeff"] { font-style: italic; }
        @media (max-width: 700px), (max-aspect-ratio: 1/1) {
            #game-container { flex-direction: column; justify-content: flex-start; align-items: stretch; }
            #game-board { width: 100%; height: auto; margin: 0; min-height: calc(160px / var(--board-aspect-ratio)); aspect-ratio: var(--board-aspect-ratio); }
            #board-feedback-area { top: clamp(5px, 2vh, 15px); bottom: auto; font-size: clamp(1.6rem, 3vmin, 2rem); width: 90%; }
            #ui-panel { width: 100%; height: auto; flex-grow: 1; flex-shrink: 1; border-left: none; border-top: clamp(1px, 0.4vmin, 3px) solid #1e281e; min-height: 100px; max-height: 40vh; font-size: 1.3rem; }
            #top-bar-ui { flex-wrap: nowrap; }
            #level-gold-container { flex-grow: 1; gap: 0.5rem; flex-wrap: nowrap; overflow: hidden; justify-content: flex-start; }
            #level-display, #actions-left-display, #gold-display-ui-panel { margin-bottom: 0; padding: 0.2rem 0.4rem; font-size: 1.2rem; }
            #menu-button { font-size: 1.4rem; padding: 2px 4px; min-width: 22px; min-height: 22px; margin-left: auto; }
            #unit-info { flex: 0 1 auto; margin-bottom: 0.5rem; font-size: 1.1rem; gap: 5px; padding: 0.5rem; }
            #unit-portrait { width: 36px; height: 36px; } #unit-details { font-size: 1.1rem; } #unit-info h3 { font-size: 1.2rem; } #unit-info p { font-size: 1.1rem; }
            #game-container:fullscreen > #ui-panel { border-top-color: #333; }
            #spell-area { grid-template-columns: repeat(4, 1fr); }
            .spell-icon { width: clamp(28px, 4.5vmin, 40px); height: clamp(28px, 4.5vmin, 40px); } .spell-label { font-size: 1.0rem; }
            .spell-icon .hotkey-display { font-size: 0.9rem; padding: 0 2px; }
            #unit-tooltip { font-size: 1.0rem; }
            .projectile.fireball-projectile { width: 60px; height: 60px; }
            :root { --flame-wave-stagger-delay: 75ms; }
            #menu-overlay #menu-overlay-content { width: 90%; max-width: 90%; } #menu-overlay .menu-ui-button { min-width: 80%; width: 90%; }
            #level-select-container { max-width: 90%; } #level-select-container button { min-width: 60px; font-size: 1.2rem; }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-board">
            <div id="grid-content"></div>
			<div id="board-feedback-area"></div>
        </div>
       
        <div id="ui-panel">
            <div id="top-bar-ui"> <div id="level-gold-container"> <div id="level-display">Level: 1</div> <div id="actions-left-display">Actions Left: 0</div> <div id="gold-display-ui-panel">Gold: 0</div> <button id="menu-button" class="ui-button" title="Menu">☰</button> </div> </div>
            <div id="unit-info"> <img id="unit-portrait" src="" alt=""> <div id="unit-details"> <h3 id="unit-name">Unit Info</h3> <p id="unit-hp">HP: -/-</p> <p id="unit-atk">ATK: -</p> <p id="unit-mov">MOV: -</p> <p id="unit-rng">RNG: -</p> <p id="unit-status"></p> </div> </div>
            <div id="spell-area"> <div id="fireball-container" class="spell-container"> <div id="fireball-spell" class="spell-icon locked" title="Unlock at Level 4"><span class="hotkey-display">1</span></div><span class="spell-label">Fireball</span></div> <div id="flame-wave-container" class="spell-container"> <div id="flame-wave-spell" class="spell-icon locked" title="Unlock at Level 8"><span class="hotkey-display">2</span></div><span class="spell-label">Flame Wave</span></div> <div id="frost-nova-container" class="spell-container"> <div id="frost-nova-spell" class="spell-icon locked" title="Unlock at Level 12"><span class="hotkey-display">3</span></div><span class="spell-label">Frost Nova</span></div> <div id="heal-container" class="spell-container"> <div id="heal-spell" class="spell-icon locked" title="Unlock at Level 16"><span class="hotkey-display">4</span></div><span class="spell-label">Heal</span></div> </div>
            <button id="end-turn-button" title="End Player Turn (E)"></button>
        </div>
        <div id="start-screen" class="overlay visible"> <h2>Knight's Gambit</h2> <p>Defeat all Goblins to advance levels.</p> <button id="start-button">Begin Conquest!</button> </div>
        <div id="game-over-screen" class="overlay"> <h2 id="game-over-title">Defeat!</h2> <p id="game-over-message"></p> <button id="restart-button">Restart Level</button> </div>
        <div id="level-select-screen" class="overlay"> <h2>Select Level</h2> <div id="level-select-container"> <button class="level-select-button" data-level="1">Level 1</button> <button class="level-select-button" data-level="2">Level 2</button> <button class="level-select-button" data-level="3">Level 3</button> <button class="level-select-button" data-level="4">Level 4</button> <button class="level-select-button" data-level="5">Level 5</button> <button class="level-select-button" data-level="10">Level 10</button> <button class="level-select-button" data-level="20">Level 20</button> <button class="level-select-button" data-level="30">Level 30</button> </div> <button id="back-to-start-button" class="overlay-button-like">Back to Title</button> </div>
        <div id="leaderboard-overlay" class="overlay"> <h2>Leaderboard</h2> <p>(Placeholder - requires server storage)</p> <ul id="leaderboard-list"> <li><span>Sora Ngin</span> <span>Level 99 - Gold: 9001</span></li> <li><span>HeroKnight</span> <span>Level 10 - Gold: 125</span></li> <li><span>GoblinMan</span> <span>Level 8 - Gold: 100</span></li> <li><span>Archmage</span> <span>Level 5 - Gold: 90</span></li> <li><span>Sir Reginald</span> <span>Level 2 - Gold: 75</span></li> </ul> <button id="close-leaderboard-button" class="overlay-button-like">Close</button> </div>
        <div id="menu-overlay" class="overlay"> <div id="menu-overlay-content"> <h2>Menu</h2> <div id="gold-display"> <img src="./sprites/gold.png" alt="Gold" class="gold-icon-menu"> <span id="menu-gold-amount">0</span> </div> <div id="menu-buttons-container"> <button id="restart-level-menu-button" class="menu-ui-button" title="Restart Current Level">🔄 Restart Level</button> <button id="leaderboard-button" class="menu-ui-button" title="Leaderboard">🏆 Leaderboard</button> <button id="mute-button" class="menu-ui-button" title="Toggle Sound (M)">🔊 Mute Sound</button> <button id="fullscreen-button" class="menu-ui-button" title="Toggle Fullscreen (F)" disabled>&#x26F6; Fullscreen</button> <button id="quit-to-level-select-button" class="menu-ui-button" title="Quit to Level Select">🚪 Quit</button> </div> <button id="close-menu-button" class="overlay-button-like">Close Menu</button> </div> </div>
        <div id="unit-tooltip"></div>
    </div>

    <script>
        let gameContainer, gameBoard, gridContent, uiPanel, levelDisplayElement, goldDisplayUIElement, spellAreaElement,
            fireballElement, flameWaveElement, frostNovaElement, healElement, unitInfo, unitPortraitElement,
            actionsLeftDisplayElement, unitNameDisplay, unitHpDisplay, unitAtkDisplay, unitMovDisplay,
            unitRngDisplay, unitStatusDisplay, boardFeedbackArea, endTurnButton, startScreen, gameOverScreen,
            startButton, restartButton, gameOverTitle, gameOverMessage, fullscreenButton, muteButton, tooltipElement,
            leaderboardButton, leaderboardOverlay, leaderboardList, closeLeaderboardButton,
            menuButton, menuOverlay, closeMenuButton, restartLevelMenuButton, quitToLevelSelectButton,
            levelSelectScreen, levelSelectContainer, backToStartButton, menuGoldAmountElement;

        const musicTracks = ['audio/music_WarcraftOrc.mp3', 'audio/music_Luffy.mp3', 'audio/music_WormsTheme.mp3'];
        const sfx = {};
        const bgMusic = new Audio(); bgMusic.loop = true; bgMusic.volume = 0.3;
        let isMuted = false; let audioInitialized = false;
        const SFX_FILES = { success: 'audio/Success.wav', error: 'audio/Error.wav', gameOver: 'audio/GameOver.wav', hit: 'audio/sfxHit.wav', defeat: 'audio/sfxGoblinDead.wav', move: 'audio/sfxMove.wav', select: 'audio/sfxSelect.wav', fireballShoot: 'audio/fireball_shoot.wav', fireballHit: 'audio/sfxFireballHit.wav', frostNovaCast: 'audio/sfxFrostboltCast.wav', frostNovaHit: 'audio/sfxFrostboltHit.wav', playerDie: 'audio/player_die.wav', startBeep: 'audio/start_beep.wav', heal: 'audio/heal.wav', arrowShoot: 'audio/arrow_shoot.wav', pickup: 'audio/pickup.wav', goldDrop: 'audio/gold_drop.wav', chestOpen: 'audio/chest.wav', cheat: 'audio/Success.wav', menuOpen: 'audio/sfxSelect.wav', menuClose: 'audio/sfxSelect.wav', levelSelect: 'audio/start_beep.wav' };

        const BASE_GRID_COLS = 8;
        const BASE_GRID_ROWS = 10;
        let currentGridCols = BASE_GRID_COLS;
        let currentGridRows = BASE_GRID_ROWS;
        let currentCellSize = 30;
        let gridContentOffsetX = 0;
        let gridContentOffsetY = 0;

        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let gridStartPanX = 0;
        let gridStartPanY = 0;

        const FIREBALL_UNLOCK_LEVEL = 4; const FIREBALL_DAMAGE = 2;
        const FLAME_WAVE_UNLOCK_LEVEL = 8; const FLAME_WAVE_DAMAGE = 1;
        const FROST_NOVA_UNLOCK_LEVEL = 12; const FROST_NOVA_DURATION = 3;
        const HEAL_UNLOCK_LEVEL = 16; const HEAL_AMOUNT = 3;
        const ARCHER_KNIGHT_INTRO_LEVEL = 6;
        const GOBLIN_ARCHER_INTRO_LEVEL = 3;
        const GOBLIN_NETTER_INTRO_LEVEL = 12;
        const CLUBBER_INTRO_LEVEL = 7;
        const JUGGERNAUT_INTRO_LEVEL = 10;
        const JUGGERNAUT_SPAWN_MULTIPLE = 10;
        const ARROW_FLY_DURATION_MS = 300; const FIREBALL_PROJECTILE_DURATION_MS = 400;
        const FIREBALL_EXPLOSION_DURATION_MS = 800;
        const ENEMY_SPAWN_ROWS_PERCENT = 0.3;
        const PLAYER_SPAWN_ROWS_PERCENT = 0.2;
        const MIN_OBSTACLES = 2; const MAX_OBSTACLES_PER_LEVEL = 0.01;
        const WALL_ROCK_CHANCE = 0.4; const GOLD_DROP_CHANCE = 0.6;
        const BASE_GOLD_DROP_AMOUNT = 1;
        const ADVANCED_GOBLIN_TYPES = ['goblin_archer', 'goblin_netter', 'goblin_clubber', 'orc_juggernaut'];
        const ADVANCED_GOBLIN_EXTRA_GOLD_CHANCE = 0.25; const ADVANCED_GOBLIN_EXTRA_GOLD_AMOUNT = 1;
        const GOLD_PENALTY_ON_DEATH = 5;
        const CHEST_SPAWN_CHANCE_PER_LEVEL = 0.3; const CHEST_GOLD_AMOUNT = 5;
        const MAX_CHESTS_PER_LEVEL = 2;

        const UNIT_DATA = {
            knight: { name: "Knight", hp: 6, atk: 1, mov: 3, range: 1, team: 'player', spriteUrl: './sprites/Knight.png', deadSpriteUrl: './sprites/Knight_dead.png', portraitUrl: './sprites/knight_portrait.png' },
            knight_archer: { name: "Archer", hp: 3, atk: 1, mov: 2, range: 4, team: 'player', spriteUrl: './sprites/archer.png', deadSpriteUrl: './sprites/archer_dead.png', portraitUrl: './sprites/archer_portrait.png' },
            goblin: { name: "Goblin", hp: 2, atk: 1, mov: 4, range: 1, team: 'enemy', spriteUrl: './sprites/Goblin.png', deadSpriteUrl: './sprites/Goblin_dead.png', portraitUrl: './sprites/goblin_portrait.png' },
            goblin_archer: { name: "Goblin Archer", hp: 1, atk: 1, mov: 3, range: 4, team: 'enemy', spriteUrl: './sprites/goblin_archer.png', deadSpriteUrl: './sprites/Goblin_dead.png', portraitUrl: './sprites/goblin_archer_portrait.png' },
            goblin_netter: { name: "Goblin Netter", hp: 1, atk: 0, mov: 3, range: 3, team: 'enemy', spriteUrl: './sprites/goblin_netter.png', deadSpriteUrl: './sprites/Goblin_dead.png', portraitUrl: './sprites/goblin_netter_portrait.png' },
            goblin_clubber: { name: "Goblin Clubber", hp: 3, atk: 2, mov: 3, range: 1, knockback: true, team: 'enemy', spriteUrl: './sprites/goblin_club.png', deadSpriteUrl: './sprites/Goblin_dead.png', portraitUrl: './sprites/goblin_club_portrait.png' },
            orc_juggernaut: { name: "Orc Juggernaut", hp: 8, atk: 3, mov: 2, range: 1, knockback: true, team: 'enemy', spriteUrl: './sprites/orc_juggernaut.png', deadSpriteUrl: './sprites/orc_juggernaut_dead.png', portraitUrl: './sprites/orc_juggernaut_portrait.png' }
        };
        const OBSTACLE_TYPES = {
            rock: { blocksMove: true, blocksLOS: false, spriteClass: 'rock' },
            wall_rock: { blocksMove: true, blocksLOS: true, spriteClass: 'wall_rock' }
        };
        const ITEM_DATA = {
            gold: { spriteClass: 'gold-coin', zIndex: 6 },
            chest: { spriteClass: 'chest', zIndex: 7, goldAmount: CHEST_GOLD_AMOUNT }
        };

        let units = []; let selectedUnit = null; let currentTurn = 'player';
        let validMoves = []; let validAttacks = []; let highlightedAttackCells = [];
        let unitCounter = 0; let isProcessing = false; let currentLevel = 1;
        let playerGold = 0; let levelToRestartOnLoss = 1; let currentSpell = null;
        let spellUses = { fireball: false, flameWave: false, frostNova: false, heal: false };
        let unlimitedSpellsCheat = false; let resizeTimeout = null; let winCheckTimeout = null;
        let MOVE_ANIMATION_DURATION_MS = 250; let FLAME_WAVE_STAGGER_DELAY_MS = 50; let DEATH_FADE_DURATION_MS = 1000;
        let gridState = []; let items = []; let cellElementsMap = new Map();
        let levelClearedAwaitingInput = false; let currentMouseX = 0; let currentMouseY = 0;
        let lastHoveredUnitId = null; let tooltipUpdateInterval = null; let isGameActive = false;

        function loadSfx() {
            for (const key in SFX_FILES) {
                sfx[key] = new Audio(SFX_FILES[key]);
                sfx[key].preload = 'auto';
            }
            sfx.success.volume = 0.6; sfx.error.volume = 0.6; sfx.gameOver.volume = 0.8;
            sfx.hit.volume = 0.7; sfx.defeat.volume = 0.7; sfx.move.volume = 0.4;
            sfx.select.volume = 0.5; sfx.fireballShoot.volume = 0.7; sfx.fireballHit.volume = 0.8;
            sfx.frostNovaCast.volume = 0.6; sfx.frostNovaHit.volume = 0.7;
            sfx.playerDie.volume = 0.7; sfx.startBeep.volume = 0.6; sfx.heal.volume = 0.7;
            sfx.arrowShoot.volume = 0.5; sfx.pickup.volume = 0.7; sfx.goldDrop.volume = 0.6;
            sfx.chestOpen.volume = 0.7; sfx.cheat.volume = 0.7; sfx.menuOpen.volume = 0.5;
            sfx.menuClose.volume = 0.5; sfx.levelSelect.volume = 0.6;
        }

        function playSfx(soundKey) {
            const sound = sfx[soundKey];
            if (isMuted || !audioInitialized || !sound) return;
            try {
                sound.currentTime = 0;
                sound.play().catch(()=>{});
            } catch (e) {}
        }

        function startMusic() {
            if (isMuted || !audioInitialized) return;
            if (!bgMusic.src || bgMusic.ended) {
                selectAndLoadMusic();
                if (!bgMusic.src) return;
            }
            if (bgMusic.paused) {
                bgMusic.play().catch(()=>{});
            }
        }

        function stopMusic() {
            if (bgMusic && !bgMusic.paused) {
                bgMusic.pause();
                bgMusic.currentTime = 0;
            }
        }

        function selectAndLoadMusic() {
            if (musicTracks.length === 0) return;
            const currentTrackName = bgMusic.src ? bgMusic.src.substring(bgMusic.src.lastIndexOf('/') + 1) : null;
            const currentTrackIndex = musicTracks.findIndex(track => track.endsWith(currentTrackName));
            let nextTrackIndex = (currentTrackIndex + 1) % musicTracks.length;
            if (currentTrackIndex === -1 || musicTracks.length === 1) {
                nextTrackIndex = Math.floor(Math.random() * musicTracks.length);
            }
            const track = musicTracks[nextTrackIndex];
            if (track) {
                bgMusic.src = track;
                bgMusic.load();
            }
        }

        function initializeAudio() {
            if (audioInitialized) return true;
            const AC = window.AudioContext || window.webkitAudioContext;
            if (!AC) {
                audioInitialized = true; loadSfx(); return true;
            }
            const context = new AC();
            const unlockAudio = () => {
                context.resume().then(() => {
                    audioInitialized = true;
                    loadSfx();
                    startMusicIfNotPlaying();
                    document.removeEventListener('click', unlockAudio, true);
                    document.removeEventListener('keydown', unlockAudio, true);
                    document.removeEventListener('touchstart', unlockAudio, true);
                }).catch(()=>{});
            };
            if (context.state === 'suspended') {
                document.addEventListener('click', unlockAudio, { once: true, capture: true });
                document.addEventListener('keydown', unlockAudio, { once: true, capture: true });
                document.addEventListener('touchstart', unlockAudio, { once: true, capture: true });
            } else {
                audioInitialized = true;
                loadSfx();
            }
            return audioInitialized;
        }

        function startMusicIfNotPlaying() {
            if (isGameActive && !isGameOver() && !isLevelSelectOpen() && !isMuted && bgMusic.paused) {
                startMusic();
            }
        }

        function isUnitAliveAndValid(unit) {
            return unit?.hp > 0 && unit.element && !unit.element.classList.contains('dead') && !unit.element.classList.contains('fading-out');
        }

        function isCellInBounds(x, y) {
            return x >= 0 && x < currentGridCols && y >= 0 && y < currentGridRows;
        }

        function getObstacleAt(x, y) {
            const obstacleType = gridState[y]?.[x];
            return obstacleType ? OBSTACLE_TYPES[obstacleType] : null;
        }

        function getItemAt(x, y) {
            return items.find(item => item.x === x && item.y === y);
        }

        function getUnitAt(x, y) {
            return units.find(unit => unit.x === x && unit.y === y && isUnitAliveAndValid(unit));
        }

        function getDistance(unitA, unitB) {
            if (!unitA || !unitB) return Infinity;
            return Math.abs(unitA.x - unitB.x) + Math.abs(unitA.y - unitB.y);
        }

        function calculateGridDimensions(level) {
            const levelFactor = Math.floor((level - 1) / 5);
            currentGridCols = BASE_GRID_COLS + Math.floor(levelFactor / 2) + (levelFactor % 2);
            currentGridRows = BASE_GRID_ROWS + Math.floor(levelFactor / 2);
            currentGridCols = Math.max(BASE_GRID_COLS, currentGridCols);
            currentGridRows = Math.max(BASE_GRID_ROWS, currentGridRows);
            document.documentElement.style.setProperty('--initial-grid-cols', currentGridCols);
            document.documentElement.style.setProperty('--initial-grid-rows', currentGridRows);
            document.documentElement.style.setProperty('--board-aspect-ratio', `${currentGridCols} / ${currentGridRows}`);
        }

        function calculateCellSize() {
            if (!gameBoard) return;
            const boardWidth = gameBoard.clientWidth;
            const boardHeight = gameBoard.clientHeight;
            if (boardWidth > 1 && boardHeight > 1) {
                const cellWidth = Math.floor(boardWidth / currentGridCols);
                const cellHeight = Math.floor(boardHeight / currentGridRows);
                 currentCellSize = Math.max(1, Math.min(cellWidth, cellHeight));
            } else {
                currentCellSize = Math.max(currentCellSize, 20);
            }
            currentCellSize = Math.max(currentCellSize, 10);
            document.documentElement.style.setProperty('--cell-size', `${currentCellSize}px`);

             if (gridContent) {
                 gridContent.style.width = `${currentGridCols * currentCellSize}px`;
                 gridContent.style.height = `${currentGridRows * currentCellSize}px`;
             }
        }


        function clampPan() {
            if (!gameBoard || !gridContent) return;
            const gridWidth = gridContent.offsetWidth;
            const gridHeight = gridContent.offsetHeight;
            const boardWidth = gameBoard.clientWidth;
            const boardHeight = gameBoard.clientHeight;

            const minX = Math.min(0, boardWidth - gridWidth);
            const minY = Math.min(0, boardHeight - gridHeight);
            const maxX = 0;
            const maxY = 0;

            gridContentOffsetX = Math.max(minX, Math.min(maxX, gridContentOffsetX));
            gridContentOffsetY = Math.max(minY, Math.min(maxY, gridContentOffsetY));

            gridContent.style.left = `${gridContentOffsetX}px`;
            gridContent.style.top = `${gridContentOffsetY}px`;
        }

        function centerView(immediate = false) {
             if (!gameBoard || !gridContent) return;
             const gridWidth = gridContent.offsetWidth;
             const gridHeight = gridContent.offsetHeight;
             const boardWidth = gameBoard.clientWidth;
             const boardHeight = gameBoard.clientHeight;

             gridContentOffsetX = Math.max(boardWidth - gridWidth, 0) / 2;
             gridContentOffsetY = Math.max(boardHeight - gridHeight, 0) / 2;

             if (!immediate) {
                 gridContent.style.transition = 'left 0.3s ease-out, top 0.3s ease-out';
             }
             clampPan();
             if (!immediate) {
                setTimeout(() => { if(gridContent) gridContent.style.transition = ''; }, 300);
             }
        }

        function applyLayout() {
            if (currentCellSize < 10) calculateCellSize();
            if (currentCellSize < 10) return;

            if (gridContent) {
                 gridContent.style.width = `${currentGridCols * currentCellSize}px`;
                 gridContent.style.height = `${currentGridRows * currentCellSize}px`;
                 gridContent.style.gridTemplateColumns = `repeat(${currentGridCols}, 1fr)`;
                 gridContent.style.gridTemplateRows = `repeat(${currentGridRows}, 1fr)`;
                 cellElementsMap.forEach(cell => {
                     cell.style.width = `var(--cell-size)`;
                     cell.style.height = `var(--cell-size)`;
                 });
            }

            for (const unit of units) {
                if (unit.element && !unit.element.classList.contains('dead')) {
                    updateUnitPosition(unit, true);
                }
            }
            gridContent?.querySelectorAll('.unit.dead').forEach(deadEl => {
                const unitId = parseInt(deadEl.dataset.id);
                const unit = units.find(u => u.id === unitId);
                if (unit) updateUnitVisualPositionOnly(deadEl, unit.x, unit.y);
            });
            gridContent?.querySelectorAll('.obstacle').forEach(obsEl => updateObstaclePosition(obsEl));
            for (const item of items) {
                if (item.element) updateItemPosition(item.element, item.x, item.y, item.stackIndex || 0);
            }

            if (selectedUnit) highlightMovesAndAttacks(selectedUnit);
            clampPan();
        }

        const handleResize = () => {
            if (resizeTimeout) clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (!isGameActive || isGameOver() || isLevelSelectOpen() || startScreen?.classList.contains('visible')) return;
                requestAnimationFrame(() => {
                    try {
                        calculateCellSize();
                        applyLayout();
                        centerView(true);
                    } catch (e) { console.error("Resize Error:", e); }
                });
            }, 100);
        };

        function handlePanStart(event) {
            if (event.button !== 0 || event.target.closest('.unit, .ui-button, button, a') || !isGameActive || isProcessing || isGameOver() || isMenuOpen()) {
                return;
            }
            event.preventDefault();
            if (!gridContent) return;

            isPanning = true;
            panStartX = event.clientX;
            panStartY = event.clientY;
            gridStartPanX = gridContent.offsetLeft;
            gridStartPanY = gridContent.offsetTop;
            gameBoard?.classList.add('panning');
            document.addEventListener('mousemove', handlePanMove);
            document.addEventListener('mouseup', handlePanEnd);
        }

        function handlePanMove(event) {
            if (!isPanning || !gridContent) return;
            event.preventDefault();
            const deltaX = event.clientX - panStartX;
            const deltaY = event.clientY - panStartY;
            gridContentOffsetX = gridStartPanX + deltaX;
            gridContentOffsetY = gridStartPanY + deltaY;
            clampPan();
        }

        function handlePanEnd(event) {
            if (!isPanning) return;
            event.preventDefault();
            isPanning = false;
            gameBoard?.classList.remove('panning');
            document.removeEventListener('mousemove', handlePanMove);
            document.removeEventListener('mouseup', handlePanEnd);
        }

        function resetSpellStateForNewLevel() {
            currentSpell = null;
            spellUses = {
                fireball: currentLevel >= FIREBALL_UNLOCK_LEVEL,
                flameWave: currentLevel >= FLAME_WAVE_UNLOCK_LEVEL,
                frostNova: currentLevel >= FROST_NOVA_UNLOCK_LEVEL,
                heal: currentLevel >= HEAL_UNLOCK_LEVEL
            };
            if (unlimitedSpellsCheat) {
                spellUses = { fireball: true, flameWave: true, frostNova: true, heal: true };
            }
            if (gameBoard) {
                gameBoard.className = 'game-board';
                gameBoard.style.removeProperty('--hover-col');
            }
            updateSpellUI();
            clearFrostNovaPreview();
        }

        function clearLevelItems() {
            for (const item of items) {
                item.element?.remove();
            }
            items = [];
        }

        function resetLevelState() {
            units = []; unitCounter = 0; selectedUnit = null; lastHoveredUnitId = null;
            validMoves = []; validAttacks = []; highlightedAttackCells = []; currentTurn = 'player';
            gridState = []; clearLevelItems(); levelClearedAwaitingInput = false;
            if (winCheckTimeout) clearTimeout(winCheckTimeout); winCheckTimeout = null;
            if (resizeTimeout) clearTimeout(resizeTimeout); resizeTimeout = null; isProcessing = false;
            if (gridContent) {
                gridContent.innerHTML = '';
                gridContent.style.left = '0px'; gridContent.style.top = '0px';
                gridContentOffsetX = 0; gridContentOffsetY = 0;
            }
            cellElementsMap.clear();
            clearHighlights();
            if (endTurnButton) { endTurnButton.innerHTML = `<span class="hotkey-e">[E]</span>nd Turn`; endTurnButton.title = "End Player Turn (E)"; endTurnButton.classList.remove('next-level-mode'); }
            if (gameBoard) gameBoard.className = 'game-board';
        }

        function fullGameReset() {
            resetLevelState();
            stopMusic();
            stopTooltipUpdater();
            document.removeEventListener('mousemove', trackMousePosition);
            window.removeEventListener('resize', handleResize);
            document.removeEventListener('fullscreenchange', updateFullscreenButton);
            document.removeEventListener('webkitfullscreenchange', updateFullscreenButton);
            document.removeEventListener('mozfullscreenchange', updateFullscreenButton);
            document.removeEventListener('MSFullscreenChange', updateFullscreenButton);
            isGameActive = false;
            gameBoard?.removeEventListener('mousedown', handlePanStart);
            if(gridContent) gridContent.innerHTML = '';
        }

        function initGame(startLevel = 1) {
            isGameActive = true; isProcessing = true;
            if (!audioInitialized) initializeAudio();
            playSfx('startBeep'); currentLevel = startLevel; levelToRestartOnLoss = currentLevel;
            if (startLevel === 1) playerGold = 0;

            calculateGridDimensions(currentLevel);
            resetLevelState();
            resetSpellStateForNewLevel();
            isProcessing = true; stopMusic();
            if (sfx.gameOver) { sfx.gameOver.pause(); sfx.gameOver.currentTime = 0; }
            selectAndLoadMusic();

            try {
                calculateCellSize();
                setupBoard();
                initializeGridState();
                updateLevelDisplay(); updateGoldDisplay(); updateUnitInfo(null);
                if (boardFeedbackArea) { boardFeedbackArea.innerHTML = ''; boardFeedbackArea.className = 'board-feedback-area'; boardFeedbackArea.style.opacity = '1'; }
                if (endTurnButton) { endTurnButton.classList.remove('disabled'); endTurnButton.disabled = false; }
                gameOverScreen?.classList.remove('visible'); startScreen?.classList.remove('visible');
                menuOverlay?.classList.remove('visible'); leaderboardOverlay?.classList.remove('visible'); levelSelectScreen?.classList.remove('visible');

                window.addEventListener('resize', handleResize, { passive: true });
                document.addEventListener('fullscreenchange', updateFullscreenButton);
                document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
                document.addEventListener('mozfullscreenchange', updateFullscreenButton);
                document.addEventListener('MSFullscreenChange', updateFullscreenButton);
                updateFullscreenButton();
                document.addEventListener('mousemove', trackMousePosition);
                gameBoard?.addEventListener('mousedown', handlePanStart);
                startTooltipUpdater();

                requestAnimationFrame(() => {
                    try {
                        spawnObstacles();
                        spawnInitialUnits();
                        spawnItems();
                        for (const u of units) {
                            if (u.team === 'player') u.acted = false;
                            u.isFrozen = false; u.frozenTurnsLeft = 0;
                        }
                        renderAllUnitsAndItems();
                        applyLayout();
                        centerView(true);
                        updateTurnDisplay();
                        startMusicIfNotPlaying();
                    } catch (rafError) { console.error("Error during initial game setup render:", rafError); }
                    finally { isProcessing = false; updateTurnDisplay(); }
                });
            } catch (initError) { console.error("Error initializing game:", initError); isProcessing = false; updateTurnDisplay(); isGameActive = false; }
        }

        function setupBoard() {
            if (!gridContent) return;
            gridContent.innerHTML = '';
            cellElementsMap.clear();

            gridContent.style.width = `${currentGridCols * currentCellSize}px`;
            gridContent.style.height = `${currentGridRows * currentCellSize}px`;
            gridContent.style.gridTemplateColumns = `repeat(${currentGridCols}, 1fr)`;
            gridContent.style.gridTemplateRows = `repeat(${currentGridRows}, 1fr)`;
            gridContent.style.setProperty('--grid-cols', currentGridCols);
            gridContent.style.setProperty('--grid-rows', currentGridRows);

            gridContentOffsetX = 0; gridContentOffsetY = 0;
            gridContent.style.left = '0px'; gridContent.style.top = '0px';

            const fragment = document.createDocumentFragment();
            for (let r = 0; r < currentGridRows; r++) {
                for (let c = 0; c < currentGridCols; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.x = c;
                    cell.dataset.y = r;
                    cell.addEventListener('click', handleCellClick);
                    cell.addEventListener('mouseenter', handleCellMouseEnter);
                    cell.addEventListener('mouseleave', handleCellMouseLeave);
                    fragment.appendChild(cell);
                    cellElementsMap.set(`${c},${r}`, cell);
                }
            }
            gridContent.appendChild(fragment);
        }

        function initializeGridState() {
            gridState = Array.from({ length: currentGridRows }, () => Array(currentGridCols).fill(null));
        }

        function spawnObstacles() {
            const totalCells = currentGridCols * currentGridRows;
            const numObstacles = MIN_OBSTACLES + Math.floor(totalCells * MAX_OBSTACLES_PER_LEVEL);
            const enemySpawnAreaHeight = Math.floor(currentGridRows * ENEMY_SPAWN_ROWS_PERCENT);
            const playerSpawnAreaHeight = Math.floor(currentGridRows * PLAYER_SPAWN_ROWS_PERCENT);
            const validSpawnMinY = enemySpawnAreaHeight;
            const validSpawnMaxY = currentGridRows - playerSpawnAreaHeight - 1;

            let spawnedCount = 0; let attempts = 0; const maxAttempts = numObstacles * 20;
            if (validSpawnMinY > validSpawnMaxY || !gridContent) { return; }

            const fragment = document.createDocumentFragment();
            while (spawnedCount < numObstacles && attempts < maxAttempts) {
                attempts++;
                const x = Math.floor(Math.random() * currentGridCols);
                const y = Math.floor(Math.random() * (validSpawnMaxY - validSpawnMinY + 1)) + validSpawnMinY;

                if (isCellInBounds(x, y) && gridState[y]?.[x] === null) {
                    const isWall = Math.random() < WALL_ROCK_CHANCE;
                    const obstacleType = isWall ? 'wall_rock' : 'rock';
                    gridState[y][x] = obstacleType;
                    const obstacleData = OBSTACLE_TYPES[obstacleType];
                    if (obstacleData) {
                        const obsEl = document.createElement('div');
                        obsEl.className = `obstacle ${obstacleData.spriteClass}`;
                        obsEl.style.setProperty('--obs-x', x + 1);
                        obsEl.style.setProperty('--obs-y', y + 1);
                        obsEl.style.left = `calc((var(--obs-x) - 0.5) * var(--cell-size))`;
                        obsEl.style.top = `calc((var(--obs-y) - 0.5) * var(--cell-size))`;
                        fragment.appendChild(obsEl);
                        getCellElement(x, y)?.classList.add('has-obstacle');
                        spawnedCount++;
                    }
                }
            }
            gridContent.appendChild(fragment);
        }

                 function spawnInitialUnits() {
             const occupied = new Set();
             const enemySpawnMaxY = Math.floor(currentGridRows * ENEMY_SPAWN_ROWS_PERCENT) - 1;
             const playerSpawnMinY = currentGridRows - Math.floor(currentGridRows * PLAYER_SPAWN_ROWS_PERCENT);

             // --- Player Spawning (remains the same) ---
             const playerPositions = [];
             for (let y = currentGridRows - 1; y >= playerSpawnMinY; y--) {
                 for (let x = 0; x < currentGridCols; x++) {
                    if (gridState[y]?.[x] === null) playerPositions.push({ x, y });
                 }
             }
             let numPlayerUnits = 3 + Math.floor(currentLevel / 6);
             numPlayerUnits = Math.min(numPlayerUnits, playerPositions.length);

             let numArchers = (currentLevel >= ARCHER_KNIGHT_INTRO_LEVEL) ? 1 : 0;
             numArchers += Math.floor(currentLevel / 10);
             numArchers = Math.min(numArchers, numPlayerUnits);
             let numKnights = numPlayerUnits - numArchers;
             let playerUnitsSpawned = 0; let archersSpawned = 0; let knightsSpawned = 0;
             const shuffledPositions = [...playerPositions].sort(() => 0.5 - Math.random());

             for (let i = 0; i < shuffledPositions.length && archersSpawned < numArchers && playerUnitsSpawned < numPlayerUnits; i++) {
                 const p = shuffledPositions[i];
                 if (!occupied.has(`${p.x},${p.y}`)) { createUnit('knight_archer', p.x, p.y); occupied.add(`${p.x},${p.y}`); archersSpawned++; playerUnitsSpawned++; }
             }
             for (let i = 0; i < shuffledPositions.length && knightsSpawned < numKnights && playerUnitsSpawned < numPlayerUnits; i++) {
                 const p = shuffledPositions[i];
                 if (!occupied.has(`${p.x},${p.y}`)) { createUnit('knight', p.x, p.y); occupied.add(`${p.x},${p.y}`); knightsSpawned++; playerUnitsSpawned++; }
             }
             // --- End Player Spawning ---


            // --- Enemy Spawning (Corrected Logic) ---
            const numEnemies = 3 + currentLevel;
            const unitsToSpawnTypes = [];

            // Determine all possible enemy types for this level bracket
            const potentialTypesMasterList = ['goblin'];
            if (currentLevel >= GOBLIN_ARCHER_INTRO_LEVEL) potentialTypesMasterList.push('goblin_archer');
            if (currentLevel >= GOBLIN_NETTER_INTRO_LEVEL) potentialTypesMasterList.push('goblin_netter');
            if (currentLevel >= CLUBBER_INTRO_LEVEL) potentialTypesMasterList.push('goblin_clubber');
            if (currentLevel >= JUGGERNAUT_INTRO_LEVEL) potentialTypesMasterList.push('orc_juggernaut'); // Include if level is high enough

            // Check if it's a Juggernaut level (meets intro AND divisible by 10)
            const isJuggernautLevel = (currentLevel >= JUGGERNAUT_INTRO_LEVEL && currentLevel % JUGGERNAUT_SPAWN_MULTIPLE === 0);

            if (isJuggernautLevel) {
                // Spawn exactly ONE Juggernaut
                unitsToSpawnTypes.push('orc_juggernaut');

                // Determine remaining enemies and their types (excluding Juggernaut)
                const remainingEnemies = numEnemies - 1;
                const potentialTypesWithoutJuggernaut = potentialTypesMasterList.filter(type => type !== 'orc_juggernaut');
                const fallbackType = 'goblin'; // Fallback if no other types are available

                for (let i = 0; i < remainingEnemies; i++) {
                    // *** Use the correct list for this block ***
                    const typePool = potentialTypesWithoutJuggernaut.length > 0 ? potentialTypesWithoutJuggernaut : [fallbackType];
                    // *** Ensure this line uses typePool ***
                    const randomType = typePool[Math.floor(Math.random() * typePool.length)];
                    unitsToSpawnTypes.push(randomType);
                }

            } else {
                // Not a Juggernaut level (or not divisible by 10), spawn normally BUT EXCLUDE Juggernauts
                const potentialTypesForThisLevel = potentialTypesMasterList.filter(type => type !== 'orc_juggernaut');
                const fallbackType = 'goblin'; // Fallback if only Juggernaut was possible but excluded

                for (let i = 0; i < numEnemies; i++) {
                    // *** Use the correct list for this block ***
                    const typePool = potentialTypesForThisLevel.length > 0 ? potentialTypesForThisLevel : [fallbackType];
                     // *** Ensure this line uses typePool ***
                    const randomType = typePool[Math.floor(Math.random() * typePool.length)];
                    unitsToSpawnTypes.push(randomType);
                }
            }

            // Ensure introductory units appear on their specific levels (might replace a random unit)
            // This runs *after* the main spawn list is generated.
            if (currentLevel === GOBLIN_ARCHER_INTRO_LEVEL && !unitsToSpawnTypes.includes('goblin_archer') && unitsToSpawnTypes.length > 0) {
                unitsToSpawnTypes[0] = 'goblin_archer'; // Replace the first unit
            }
            if (currentLevel === GOBLIN_NETTER_INTRO_LEVEL && !unitsToSpawnTypes.includes('goblin_netter') && unitsToSpawnTypes.length > 0) {
                const replaceIndex = unitsToSpawnTypes.length > 1 ? 1 : 0; // Replace the second unit if possible, else the first
                unitsToSpawnTypes[replaceIndex] = 'goblin_netter';
            }
            if (currentLevel === CLUBBER_INTRO_LEVEL && !unitsToSpawnTypes.includes('goblin_clubber') && unitsToSpawnTypes.length > 0) {
                // Try to replace the third unit if possible, otherwise fallback
                const replaceIndex = unitsToSpawnTypes.length > 2 ? 2 : (unitsToSpawnTypes.length > 1 ? 1 : 0);
                unitsToSpawnTypes[replaceIndex] = 'goblin_clubber';
            }
            // No special check needed for Juggernaut intro level, as the logic above handles the specific level 10 spawn.

             // Place the chosen enemy units on the board
             for (const typeToSpawn of unitsToSpawnTypes) {
                 let spawned = false; let attempts = 0; const maxAttempts = currentGridCols * (enemySpawnMaxY + 1) * 3;
                 while (!spawned && attempts < maxAttempts) {
                     attempts++;
                     const x = Math.floor(Math.random() * currentGridCols);
                     const y = Math.floor(Math.random() * (enemySpawnMaxY + 1));
                     const key = `${x},${y}`;
                     // Check bounds, no obstacle, and not occupied by another unit yet
                     if (isCellInBounds(x, y) && gridState[y]?.[x] === null && !occupied.has(key)) {
                         createUnit(typeToSpawn, x, y);
                         occupied.add(key); // Mark cell as occupied for this function's scope
                         spawned = true;
                     }
                 }
                 if (!spawned) { console.warn(`Could not find space for enemy: ${typeToSpawn}`); }
             }
             // --- End Enemy Spawning ---

             return occupied; // Return the set of occupied cells (optional, depends if needed elsewhere)
        }

        function spawnItems() {
            const occupiedSet = new Set(units.map(u => `${u.x},${u.y}`));
            let chestsSpawned = 0;
            const maxChests = Math.random() < CHEST_SPAWN_CHANCE_PER_LEVEL ? Math.floor(Math.random() * MAX_CHESTS_PER_LEVEL) + 1 : 0;
            const enemySpawnAreaHeight = Math.floor(currentGridRows * ENEMY_SPAWN_ROWS_PERCENT);
            const playerSpawnAreaHeight = Math.floor(currentGridRows * PLAYER_SPAWN_ROWS_PERCENT);
            const validSpawnMinY = enemySpawnAreaHeight;
            const validSpawnMaxY = currentGridRows - playerSpawnAreaHeight - 1;

            let attempts = 0; const maxAttempts = currentGridCols * currentGridRows;

            while (chestsSpawned < maxChests && attempts < maxAttempts) {
                 attempts++;
                 const x = Math.floor(Math.random() * currentGridCols);
                 const y = Math.floor(Math.random() * (validSpawnMaxY - validSpawnMinY + 1)) + validSpawnMinY;
                 const key = `${x},${y}`;

                 if (isCellInBounds(x, y) && gridState[y]?.[x] === null && !occupiedSet.has(key)) {
                     createItem('chest', x, y);
                     occupiedSet.add(key);
                     chestsSpawned++;
                 }
            }
        }

        function createUnit(type, x, y) {
             const data = UNIT_DATA[type]; if (!data) return;
             const unit = { id: unitCounter++, type, x, y, hp: data.hp, maxHp: data.hp, atk: data.atk, mov: data.mov, range: data.range, knockback: data.knockback || false, team: data.team, acted: false, element: null, deadSpriteUrl: data.deadSpriteUrl, isFrozen: false, frozenTurnsLeft: 0 };
             units.push(unit);
        }

        function createItem(type, x, y, stackIndex = 0) {
             const data = ITEM_DATA[type]; if (!data) return;
             const item = { type, x, y, element: null, stackIndex, opened: false };
             if (type === 'chest') item.goldAmount = data.goldAmount;
             items.push(item);
             getCellElement(x, y)?.classList.add('has-item');
        }

        function renderAllUnitsAndItems() {
            if (!gridContent) return;
            gridContent.querySelectorAll('.unit, .item').forEach(el => el.remove());
            const fragment = document.createDocumentFragment();
            for (const unit of units) {
                const el = renderUnit(unit, false);
                if (el) fragment.appendChild(el);
            }
             for (const item of items) {
                 const el = renderItem(item, false);
                 if (el) fragment.appendChild(el);
             }
            gridContent.appendChild(fragment);
        }

        function renderUnit(unit, shouldAppend = true) {
            if (!gridContent && shouldAppend) return null;
            unit.element?.remove();
            const el = document.createElement('div');
            el.className = `unit ${unit.team}`; el.dataset.id = unit.id;
            const data = UNIT_DATA[unit.type];
            if (data?.spriteUrl) el.style.backgroundImage = `url('${data.spriteUrl}')`;
            el.classList.toggle('selected', selectedUnit?.id === unit.id);
            el.classList.toggle('acted', unit.acted); el.classList.toggle('frozen', unit.isFrozen);
            el.addEventListener('click', (ev) => handleUnitClick(ev, unit), { passive: false });
            unit.element = el;
            if (shouldAppend && gridContent) gridContent.appendChild(el);
            updateUnitPosition(unit, true);
            return el;
        }

        function renderItem(item, shouldAppend = true) {
             if (!gridContent && shouldAppend) return null;
             item.element?.remove();
             const data = ITEM_DATA[item.type];
             if (!data) return null;
             const el = document.createElement('div');
             el.className = `item ${data.spriteClass}`;
             el.dataset.x = item.x; el.dataset.y = item.y;
             el.style.zIndex = data.zIndex || 6;
             if (item.type === 'chest' && item.opened) el.classList.add('opened');
             item.element = el;
             if (shouldAppend && gridContent) gridContent.appendChild(el);
             updateItemPosition(el, item.x, item.y, item.stackIndex);
             return el;
        }

        function updateUnitPosition(unit, forceUpdate = false) {
            if (!unit?.element || unit.element.classList.contains('dead')) return;
            const targetCol = unit.x + 1; const targetRow = unit.y + 1;
            unit.element.style.setProperty('--unit-x', targetCol);
            unit.element.style.setProperty('--unit-y', targetRow);
            if (!unit.element.classList.contains('is-moving') || forceUpdate) {
                 unit.element.style.left = `calc((var(--unit-x) - 0.5) * var(--cell-size))`;
                 unit.element.style.top = `calc((var(--unit-y) - 0.5) * var(--cell-size))`;
                 unit.element.style.transform = 'translate(-50%, -50%)';
            }
            unit.element.classList.toggle('acted', unit.acted);
            unit.element.classList.toggle('selected', selectedUnit?.id === unit.id);
            unit.element.classList.toggle('frozen', unit.isFrozen);
            unit.element.style.opacity = '1';
        }

        function updateUnitVisualPositionOnly(element, x, y) {
             if (!element || !isCellInBounds(x,y)) return;
             element.style.setProperty('--unit-x', x + 1);
             element.style.setProperty('--unit-y', y + 1);
             element.style.left = `calc((var(--unit-x) - 0.5) * var(--cell-size))`;
             element.style.top = `calc((var(--unit-y) - 0.5) * var(--cell-size))`;
             element.style.transform = 'translate(-50%, -50%)';
        }

        function updateObstaclePosition(element) {
             if (!element) return;
             const x = parseInt(element.style.getPropertyValue('--obs-x')) - 1;
             const y = parseInt(element.style.getPropertyValue('--obs-y')) - 1;
             if (!isCellInBounds(x, y)) return;
             element.style.left = `calc((var(--obs-x) - 0.5) * var(--cell-size))`;
             element.style.top = `calc((var(--obs-y) - 0.5) * var(--cell-size))`;
             element.style.transform = 'translate(-50%, -50%)';
        }

        function updateItemPosition(element, x, y, stackIndex = 0) {
            if (!element) return;
            element.style.setProperty('--item-x', x + 1);
            element.style.setProperty('--item-y', y + 1);
            element.style.setProperty('--stackIndex', stackIndex);
            element.style.left = `calc((var(--item-x) - 0.5) * var(--cell-size))`;
            element.style.top = `calc((var(--item-y) - 0.5) * var(--cell-size))`;
            element.style.transform = `translate(calc(-50% + ${stackIndex} * var(--stack-offset-x)), calc(-50% + ${stackIndex} * var(--stack-offset-y)))`;
        }

        function showPopup(x, y, text, className) {
            if (!gridContent) return;
            const popup = document.createElement('div');
            popup.className = className; popup.textContent = text;
            const popupX = (x + 0.5) * currentCellSize;
            const popupY = (y + 0.5) * currentCellSize - (currentCellSize * 0.5);
            popup.style.left = `${popupX}px`; popup.style.top = `${popupY}px`;
            gridContent.appendChild(popup);
            const duration = (className === 'freeze-popup') ? 800 : 1000;
            setTimeout(() => popup.remove(), duration);
        }

        function showDamagePopup(x, y, damage) { showPopup(x, y, `-${damage}`, 'damage-popup'); }
        function showFreezePopup(x, y) { showPopup(x, y, `Frozen!`, 'freeze-popup'); }
        function showHealPopup(x, y, amount) { showPopup(x, y, `+${amount}`, 'heal-popup'); }
        function updateLevelDisplay() { if (levelDisplayElement) levelDisplayElement.textContent = `Level: ${currentLevel}`; }
        function updateGoldDisplay() { if (menuGoldAmountElement) menuGoldAmountElement.textContent = playerGold; }

        function updateSpellUI() {
            if (!fireballElement || !flameWaveElement || !frostNovaElement || !healElement) return;
            const spellData = [
                { el: fireballElement, name: 'fireball', unlock: FIREBALL_UNLOCK_LEVEL, label: "Fireball" },
                { el: flameWaveElement, name: 'flameWave', unlock: FLAME_WAVE_UNLOCK_LEVEL, label: "Flame Wave" },
                { el: frostNovaElement, name: 'frostNova', unlock: FROST_NOVA_UNLOCK_LEVEL, label: "Frost Nova" },
                { el: healElement, name: 'heal', unlock: HEAL_UNLOCK_LEVEL, label: "Heal" }
            ];
            for (const spell of spellData) {
                if (!spell.el) continue;
                const normallyUnlocked = currentLevel >= spell.unlock;
                const cheatActive = unlimitedSpellsCheat;
                const isEffectivelyUnlocked = normallyUnlocked || cheatActive;
                const isAvailableThisLevel = spellUses[spell.name] || cheatActive;
                spell.el.className = 'spell-icon';
                if (!isEffectivelyUnlocked) {
                    spell.el.classList.add('locked');
                    spell.el.title = `Unlock at Level ${spell.unlock}`;
                } else if (!isAvailableThisLevel) {
                    spell.el.classList.add('used');
                    spell.el.title = `${spell.label} (Used this level)`;
                } else {
                    spell.el.classList.add('available');
                    if (cheatActive) {
                        spell.el.classList.add('cheat-available');
                        spell.el.title = normallyUnlocked ? `${spell.label} (CHEAT ACTIVE)` : `${spell.label} (CHEAT UNLOCKED)`;
                    } else {
                        spell.el.title = spell.label;
                    }
                    if (currentSpell === spell.name) {
                        spell.el.classList.add('selected');
                    }
                }
                const labelEl = spell.el.nextElementSibling;
                if (labelEl) {
                   if (!isEffectivelyUnlocked) labelEl.style.color = '#a85858';
                   else if (!isAvailableThisLevel) labelEl.style.color = '#aaa';
                   else if (cheatActive) labelEl.style.color = 'lime';
                   else labelEl.style.color = '#eee';
                }
            }
            if (gameBoard) {
                gameBoard.classList.toggle('fireball-targeting', currentSpell === 'fireball');
                gameBoard.classList.toggle('flame-wave-targeting', currentSpell === 'flameWave');
                gameBoard.classList.toggle('frost-nova-targeting', currentSpell === 'frostNova');
                gameBoard.classList.toggle('heal-targeting', currentSpell === 'heal');
            }
        }

        function updateTurnDisplay() {
            if (!actionsLeftDisplayElement || !endTurnButton) return;
            const isPlayer = currentTurn === 'player';
            let btnDisabled = false; let btnClassDisabled = false;
            if (isPlayer) {
                const remainingActions = units.reduce((count, u) => count + (u.team === 'player' && !u.acted && !u.isFrozen && isUnitAliveAndValid(u) ? 1 : 0), 0);
                actionsLeftDisplayElement.textContent = levelClearedAwaitingInput ? `Collect Items!` : `Actions Left: ${remainingActions}`;
                btnDisabled = isProcessing; btnClassDisabled = isProcessing;
            } else {
                actionsLeftDisplayElement.textContent = `AI Thinking...`;
                btnDisabled = true; btnClassDisabled = true;
            }

            const itemsLeft = items.some(item => (item.type === 'gold' || (item.type === 'chest' && !item.opened)));
            if (levelClearedAwaitingInput && !itemsLeft) {
                 endTurnButton.innerHTML = `N<span class="hotkey-e">[E]</span>xt Level`;
                 endTurnButton.title = "Proceed to Next Level (E)";
                 endTurnButton.classList.add('next-level-mode');
                 endTurnButton.disabled = false; endTurnButton.classList.remove('disabled');
            } else if (levelClearedAwaitingInput && itemsLeft) {
                 endTurnButton.innerHTML = `<span class="hotkey-e">[E]</span>nd Turn`;
                 endTurnButton.title = "End Player Turn (E)";
                 endTurnButton.classList.remove('next-level-mode');
                 endTurnButton.disabled = btnDisabled;
                 endTurnButton.classList.toggle('disabled', btnClassDisabled);
            } else {
                endTurnButton.innerHTML = `<span class="hotkey-e">[E]</span>nd Turn`;
                endTurnButton.title = "End Player Turn (E)";
                endTurnButton.classList.remove('next-level-mode');
                endTurnButton.disabled = btnDisabled;
                endTurnButton.classList.toggle('disabled', btnClassDisabled);
            }
        }

        function updateUnitInfo(unit) {
             if (!unitInfo || !unitNameDisplay || !unitHpDisplay || !unitAtkDisplay || !unitMovDisplay || !unitRngDisplay || !unitStatusDisplay || !unitPortraitElement) return;
             const shouldShow = unit && isUnitAliveAndValid(unit);
             unitInfo.style.display = shouldShow ? 'flex' : 'none';

             if (shouldShow) {
                 const data = UNIT_DATA[unit.type];
                 unitNameDisplay.textContent = data ? data.name : unit.type;
                 unitHpDisplay.textContent = `HP: ${unit.hp}/${unit.maxHp}`;
                 unitAtkDisplay.textContent = `ATK: ${unit.atk}`;
                 unitMovDisplay.textContent = `MOV: ${unit.mov}`;
                 unitRngDisplay.style.display = unit.range > 1 ? 'block' : 'none';
                 if (unit.range > 1) unitRngDisplay.textContent = `RNG: ${unit.range}`;
                 unitStatusDisplay.style.display = unit.isFrozen ? 'block' : 'none';
                 if (unit.isFrozen) unitStatusDisplay.textContent = `❄️ Status: Frozen (${unit.frozenTurnsLeft} turns)`;

                 const portraitUrl = data?.portraitUrl;
                 if (portraitUrl) {
                     unitPortraitElement.style.backgroundImage = `url('${portraitUrl}')`;
                     unitPortraitElement.style.display = 'block';
                     unitPortraitElement.style.opacity = '1';
                 } else {
                     unitPortraitElement.style.backgroundImage = '';
                     unitPortraitElement.alt = '';
                     unitPortraitElement.style.display = 'none';
                     unitPortraitElement.style.opacity = '0';
                 }
             } else {
                 unitNameDisplay.textContent = 'Unit Info';
                 unitHpDisplay.textContent = 'HP: -/-';
                 unitAtkDisplay.textContent = 'ATK: -';
                 unitMovDisplay.textContent = 'MOV: -';
                 unitRngDisplay.textContent = 'RNG: -';
                 unitStatusDisplay.textContent = '';
                 unitRngDisplay.style.display = 'none';
                 unitStatusDisplay.style.display = 'none';
                 unitPortraitElement.style.backgroundImage = '';
                 unitPortraitElement.style.opacity = '0';
             }
        }

        function showFeedback(message, type = '', duration = 2500) {
            if (!boardFeedbackArea) return;
            boardFeedbackArea.innerHTML = message;
            boardFeedbackArea.className = `board-feedback-area ${type}`;
            boardFeedbackArea.style.opacity = '1';

            if (type === 'feedback-gold' || type === 'feedback-cheat') duration = 1500;
            else if (type === 'feedback-levelup') duration = 2000;

            setTimeout(() => {
                if (boardFeedbackArea.innerHTML === message) {
                     boardFeedbackArea.style.opacity = '0';
                     setTimeout(() => {
                         if (boardFeedbackArea.style.opacity === '0') boardFeedbackArea.innerHTML = '';
                     }, 500);
                 }
            }, duration - 500);
        }

        function getCellElement(x, y) {
            return cellElementsMap.get(`${x},${y}`);
        }

        function clearHighlights() {
            gridContent?.querySelectorAll('.grid-cell.valid-move').forEach(c => c.classList.remove('valid-move'));
            gridContent?.querySelectorAll('.grid-cell.valid-attack-target').forEach(c => c.classList.remove('valid-attack-target'));
            validMoves = [];
            validAttacks = [];
            highlightedAttackCells = [];
        }

        function highlightMovesAndAttacks(unit) {
            clearHighlights();
            if (!unit || (!levelClearedAwaitingInput && unit.acted) || unit.isFrozen || !isUnitAliveAndValid(unit)) return;

            validMoves = getValidMoves(unit);
            validAttacks = getValidAttacks(unit);

            for (const pos of validMoves) {
                getCellElement(pos.x, pos.y)?.classList.add('valid-move');
            }
            for (const targetId of validAttacks) {
                const targetUnit = units.find(u => u.id === targetId);
                if (targetUnit && isUnitAliveAndValid(targetUnit)) {
                    const cell = getCellElement(targetUnit.x, targetUnit.y);
                    if (cell) {
                        cell.classList.add('valid-attack-target');
                        highlightedAttackCells.push(cell);
                    }
                }
            }
        }

        function selectUnit(unit) {
            if (!unit || (!levelClearedAwaitingInput && unit.acted) || unit.isFrozen || unit.team !== 'player' || currentTurn !== 'player' || isProcessing || !isUnitAliveAndValid(unit)) {
                if (unit?.isFrozen) { showFeedback("Cannot select: Unit is Frozen!", "feedback-error"); playSfx('error'); }
                else if (unit?.acted && !levelClearedAwaitingInput) { showFeedback("Unit already acted.", "feedback-error"); playSfx('error'); }
                return;
            }
            if (currentSpell) setActiveSpell(null);
            if (selectedUnit === unit) return;

            deselectUnit(false);
            selectedUnit = unit;
            unit.element?.classList.add('selected');
            highlightMovesAndAttacks(unit);
            updateUnitInfo(unit);
            playSfx('select');
        }

        function deselectUnit(playSound = true) {
            if (selectedUnit) {
                 selectedUnit.element?.classList.remove('selected');
                 if (playSound) playSfx('select');
                 updateUnitInfo(null);
                 selectedUnit = null;
                 clearHighlights();
            }
        }

        function trackMousePosition(event) {
            currentMouseX = event.clientX;
            currentMouseY = event.clientY;
        }

        function updateTooltip() {
            if (!isGameActive || !tooltipElement || isProcessing || !gameBoard || isGameOver() || isLevelSelectOpen() || startScreen?.classList.contains('visible')) {
                hideTooltip();
                return;
            }
            const boardRect = gameBoard.getBoundingClientRect();
            const isMouseOverBoard = currentMouseX >= boardRect.left && currentMouseX <= boardRect.right &&
                                   currentMouseY >= boardRect.top && currentMouseY <= boardRect.bottom;

            let unitToShow = null;
            if (isMouseOverBoard) {
                const elementUnderMouse = document.elementFromPoint(currentMouseX, currentMouseY);
                const unitElement = elementUnderMouse?.closest('.unit');
                if (unitElement && !unitElement.classList.contains('dead')) {
                    const unitId = parseInt(unitElement.dataset.id);
                    unitToShow = units.find(u => u.id === unitId && isUnitAliveAndValid(u));
                }
            }

            if (unitToShow) {
                if (lastHoveredUnitId !== unitToShow.id) {
                     showTooltip(unitToShow);
                     lastHoveredUnitId = unitToShow.id;
                     if (!selectedUnit) updateUnitInfo(unitToShow);
                } else {
                     positionTooltip();
                }
            } else if (lastHoveredUnitId !== null) {
                 hideTooltip();
                 lastHoveredUnitId = null;
                 if (!selectedUnit) updateUnitInfo(null);
            }
        }

        function startTooltipUpdater() {
            if (tooltipUpdateInterval) clearInterval(tooltipUpdateInterval);
            tooltipUpdateInterval = setInterval(updateTooltip, 100);
        }

        function stopTooltipUpdater() {
             if (tooltipUpdateInterval) clearInterval(tooltipUpdateInterval);
             tooltipUpdateInterval = null;
             hideTooltip();
        }

        function showTooltip(unit) {
            if (!tooltipElement || !unit || !isUnitAliveAndValid(unit)) return;
            const unitData = UNIT_DATA[unit.type];
            let tooltipContent = `<b>${unitData ? unitData.name : unit.type}</b>HP: ${unit.hp}/${unit.maxHp}`;
            if (unit.isFrozen) {
                tooltipContent += `<br><span style="color:#aadeff;">❄️ Frozen (${unit.frozenTurnsLeft}t)</span>`;
            }
            tooltipElement.innerHTML = tooltipContent;
            tooltipElement.classList.add('visible');
            positionTooltip();
        }

        function hideTooltip() {
            tooltipElement?.classList.remove('visible');
            lastHoveredUnitId = null;
        }

        function positionTooltip() {
            if (!tooltipElement || !tooltipElement.classList.contains('visible')) return;
            const tooltipRect = tooltipElement.getBoundingClientRect();
            const containerRect = document.body.getBoundingClientRect();
            const transformStyle = getComputedStyle(tooltipElement).transform;
            let offsetX = 12, offsetY = 18;
            try { const matrix = new DOMMatrixReadOnly(transformStyle); offsetX = matrix.m41; offsetY = matrix.m42; } catch (e) {}
            let top = currentMouseY + offsetY; let left = currentMouseX + offsetX;
            if (top + tooltipRect.height > containerRect.height - 5) top = currentMouseY - tooltipRect.height - 10;
            if (left + tooltipRect.width > containerRect.width - 5) left = currentMouseX - tooltipRect.width - 10;
            top = Math.max(5, top); left = Math.max(5, left);
            tooltipElement.style.left = `${left}px`;
            tooltipElement.style.top = `${top}px`;
        }

        function finishAction(unit) {
            if (!unit || (unit.acted && !levelClearedAwaitingInput) || !isUnitAliveAndValid(unit)) return;
            if (!levelClearedAwaitingInput) unit.acted = true;
            if (unit.element) {
                unit.element.classList.add('acted');
                unit.element.classList.remove('selected');
            }
            if (selectedUnit?.id === unit.id) {
                selectedUnit = null;
                clearHighlights();
                updateUnitInfo(null);
            }
            updateUnitPosition(unit);
            checkWinLossConditions();
        }

        function moveUnit(unit, targetX, targetY) {
             return new Promise((resolve) => {
                 if (!unit || (!levelClearedAwaitingInput && unit.acted) || unit.isFrozen || !isUnitAliveAndValid(unit) || !unit.element || !isCellInBounds(targetX, targetY) || getObstacleAt(targetX, targetY) || getUnitAt(targetX,targetY)) {
                     resolve(); return;
                 }
                 const startX = unit.x; const startY = unit.y;
                 if (targetX === startX && targetY === startY) { resolve(); return; }

                 unit.element.classList.add('is-moving');
                 playSfx('move');

                 const finalLeft = `calc((${targetX} + 0.5) * var(--cell-size))`;
                 const finalTop = `calc((${targetY} + 0.5) * var(--cell-size))`;

                 unit.element.style.left = finalLeft;
                 unit.element.style.top = finalTop;
                 unit.element.style.transform = 'translate(-50%, -50%)';

                 let moveFinalized = false;
                 const finalizeMove = () => {
                     if (moveFinalized || !unit.element) return;
                     moveFinalized = true;
                     unit.element.removeEventListener('transitionend', transitionEndHandler);
                     unit.element.classList.remove('is-moving');
                     unit.x = targetX; unit.y = targetY;
                     unit.element.style.setProperty('--unit-x', targetX + 1);
                     unit.element.style.setProperty('--unit-y', targetY + 1);
                     resolve();
                 };

                 const transitionEndHandler = (event) => {
                     if (event.target === unit.element && (event.propertyName === 'left' || event.propertyName === 'top')) {
                         finalizeMove();
                     }
                 };

                 unit.element.addEventListener('transitionend', transitionEndHandler);
                 setTimeout(() => {
                     if (unit.element && !moveFinalized) finalizeMove();
                     else if (!unit.element) resolve();
                 }, MOVE_ANIMATION_DURATION_MS + 50);
             });
        }

        function checkForItemPickup(unit, x, y) {
             if (!unit || unit.team !== 'player' || !isUnitAliveAndValid(unit)) return;

             const goldItemsOnCell = items.filter(item => item.type === 'gold' && item.x === x && item.y === y);
             if (goldItemsOnCell.length > 0) {
                 const totalAmountPickedUp = goldItemsOnCell.length;
                 playerGold += totalAmountPickedUp;
                 playSfx('pickup');
                 updateGoldDisplay();
                 showFeedback(`+${totalAmountPickedUp} Gold!<img src="./sprites/gold.png" class="feedback-gold-icon" alt="G"> ${playerGold}`, 'feedback-gold');
                 goldItemsOnCell.forEach(goldItem => goldItem.element?.remove());
                 items = items.filter(item => !(item.type === 'gold' && item.x === x && item.y === y));
                 getCellElement(x,y)?.classList.toggle('has-item', items.some(i => i.x === x && i.y === y));
             }

             const chestItemOnCell = items.find(item => item.type === 'chest' && item.x === x && item.y === y && !item.opened);
             if (chestItemOnCell) {
                  playerGold += chestItemOnCell.goldAmount;
                  chestItemOnCell.opened = true;
                  playSfx('chestOpen');
                  updateGoldDisplay();
                  showFeedback(`Chest opened! +${chestItemOnCell.goldAmount} Gold!<img src="./sprites/gold.png" class="feedback-gold-icon" alt="G"> ${playerGold}`, 'feedback-gold');
                  chestItemOnCell.element?.classList.add('opened');
                  getCellElement(x,y)?.classList.toggle('has-item', items.some(i => i.x === x && i.y === y && (i.type !== 'chest' || !i.opened)));
             }

            const itemsLeft = items.some(item => (item.type === 'gold' || (item.type === 'chest' && !item.opened)));
            if (levelClearedAwaitingInput && !itemsLeft) {
                 showFeedback("All items collected! Press [E] for Next Level.", "feedback-levelup");
                 updateTurnDisplay();
            }
        }

        function shootArrow(attacker, defender) {
            if (!gridContent || !attacker?.element || !defender?.element) return;
            const projectile = document.createElement('div'); projectile.className = 'projectile arrow';
            const gridRect = gridContent.getBoundingClientRect();
            const startRect = attacker.element.getBoundingClientRect();
            const endRect = defender.element.getBoundingClientRect();

            const startX = startRect.left - gridRect.left + startRect.width / 2;
            const startY = startRect.top - gridRect.top + startRect.height / 2;
            const endX = endRect.left - gridRect.left + endRect.width / 2;
            const endY = endRect.top - gridRect.top + endRect.height / 2;

            const angleRad = Math.atan2(endY - startY, endX - startX); const angleDeg = angleRad * (180 / Math.PI);
            projectile.style.left = `${startX}px`; projectile.style.top = `${startY}px`;
            projectile.style.transform = `translate(-50%, -50%) rotate(${angleDeg}deg)`;
            gridContent.appendChild(projectile);
            playSfx('arrowShoot');
            void projectile.offsetWidth;
            projectile.style.left = `${endX}px`; projectile.style.top = `${endY}px`;
            setTimeout(() => projectile.remove(), ARROW_FLY_DURATION_MS);
        }

        function attackUnit(attacker, defender) {
             if (levelClearedAwaitingInput) {
                 playSfx('error'); showFeedback("Level cleared, cannot attack.", "feedback-error");
                 if (currentTurn === 'player') { isProcessing = false; updateTurnDisplay(); } return;
             }
             if (!attacker || !defender || attacker.acted || attacker.isFrozen || !isUnitAliveAndValid(attacker) || !isUnitAliveAndValid(defender)) {
                 if (currentTurn === 'enemy' && attacker && !attacker.acted && !attacker.isFrozen && isUnitAliveAndValid(attacker)) finishAction(attacker);
                 else if (currentTurn === 'player') { isProcessing = false; updateTurnDisplay(); } return;
             }
             const attackerElement = attacker.element; const defenderElement = defender.element;
             if (!attackerElement?.parentNode || !defenderElement?.parentNode) {
                 if (currentTurn === 'enemy' && attacker && !attacker.acted && !attacker.isFrozen && isUnitAliveAndValid(attacker)) finishAction(attacker);
                 else if (currentTurn === 'player') { isProcessing = false; updateTurnDisplay(); } return;
             }

             const originalZIndex = window.getComputedStyle(attackerElement).zIndex || '10';
             const attackZIndex = '25';
             const distance = getDistance(attacker, defender);
             const isRangedAttack = distance > 1;

             if (isRangedAttack) shootArrow(attacker, defender);

             const animDurationMs = MOVE_ANIMATION_DURATION_MS;
             const strikePause = 50; const returnPause = 60;
             const damage = attacker.atk;

             if (!isRangedAttack && attackerElement) {
                 const deltaX = defender.x - attacker.x; const deltaY = defender.y - attacker.y;
                 const tapDistanceFactor = 0.2 * currentCellSize;
                 const translateX = deltaX * tapDistanceFactor; const translateY = deltaY * tapDistanceFactor;
                 const transformValue = `translate(calc(-50% + ${translateX}px), calc(-50% + ${translateY}px))`;

                 attackerElement.style.zIndex = attackZIndex;
                 attackerElement.style.transition = `transform ${animDurationMs}ms ease-out`;
                 attackerElement.style.transform = transformValue;
                 playSfx('move');

                 setTimeout(() => {
                     if (attackerElement?.parentNode) {
                          attackerElement.style.transform = 'translate(-50%, -50%)';
                          setTimeout(() => { if(attackerElement) attackerElement.style.zIndex = originalZIndex; }, returnPause);
                     }
                 }, animDurationMs + strikePause);
             }

             const impactDelay = isRangedAttack ? Math.max(ARROW_FLY_DURATION_MS, animDurationMs + strikePause) : animDurationMs + strikePause;

             setTimeout(() => {
                 const stillAttacker = units.find(u => u.id === attacker.id);
                 const stillDefender = units.find(u => u.id === defender.id);
                 const originalDefenderData = { x: defender.x, y: defender.y, team: defender.team, id: defender.id, type: defender.type };

                 if (stillDefender && isUnitAliveAndValid(stillDefender)) {
                     playSfx('hit');
                     stillDefender.hp -= damage; if (stillDefender.hp < 0) stillDefender.hp = 0;
                     showDamagePopup(stillDefender.x, stillDefender.y, damage);
                     if (defenderElement?.parentNode) {
                         defenderElement.classList.add('unit-hit-flash');
                         setTimeout(() => { defenderElement?.classList.remove('unit-hit-flash'); }, 200);
                     }
                     updateUnitInfo(selectedUnit === stillDefender ? stillDefender : (lastHoveredUnitId === stillDefender.id ? stillDefender : null));
                     if (tooltipElement?.classList.contains('visible') && lastHoveredUnitId === stillDefender.id) showTooltip(stillDefender);

                     if (attacker.knockback && stillDefender.hp > 0) {
                         const kbDirX = Math.sign(stillDefender.x - attacker.x); const kbDirY = Math.sign(stillDefender.y - attacker.y);
                         const kbX = stillDefender.x + kbDirX; const kbY = stillDefender.y + kbDirY;
                         if (isCellInBounds(kbX, kbY) && !getUnitAt(kbX, kbY) && !getObstacleAt(kbX, kbY)) {
                             moveUnit(stillDefender, kbX, kbY).then(() => {
                                if (stillDefender.team === 'player') checkForItemPickup(stillDefender, stillDefender.x, stillDefender.y);
                             });
                         }
                     }

                     if (stillDefender.hp <= 0) {
                          playSfx(defender.team === 'player' ? 'playerDie' : 'defeat');
                          removeUnit(stillDefender, originalDefenderData.x, originalDefenderData.y);
                     }

                 } else if (stillDefender && stillDefender.hp <= 0) {
                      removeUnit(stillDefender, originalDefenderData.x, originalDefenderData.y);
                 }

                 if (stillAttacker && isUnitAliveAndValid(stillAttacker) && !stillAttacker.acted) {
                     finishAction(stillAttacker);
                 }
                 if (currentTurn === 'player') { isProcessing = false; updateTurnDisplay(); }
             }, impactDelay);
        }

                function removeUnit(unit, originalX = null, originalY = null) {
    if (!unit) return;

    const unitElement = unit.element;
    const deathX = originalX ?? unit.x;
    const deathY = originalY ?? unit.y;
    const unitTeam = unit.team;
    const unitType = unit.type;
    const unitId = unit.id;

    if (unitTeam === 'enemy' && Math.random() < GOLD_DROP_CHANCE && gridContent && isCellInBounds(deathX, deathY) && !getObstacleAt(deathX, deathY)) {
        let goldAmountToDrop = BASE_GOLD_DROP_AMOUNT;
        if (ADVANCED_GOBLIN_TYPES.includes(unitType) && Math.random() < ADVANCED_GOBLIN_EXTRA_GOLD_CHANCE) {
            goldAmountToDrop += ADVANCED_GOBLIN_EXTRA_GOLD_AMOUNT;
        }

        if (goldAmountToDrop > 0) {
            playSfx('goldDrop');
            const fragment = document.createDocumentFragment();
            const fallStartOffsetY = -50;
            const maxPixelSpread = currentCellSize * 0.25;

            for (let i = 0; i < goldAmountToDrop; i++) {
                const goldItem = { type: 'gold', x: deathX, y: deathY, element: null };
                const goldEl = renderItem(goldItem, false);

                if (goldEl) {
                    const randomPixelOffsetX = (Math.random() * 2 - 1) * maxPixelSpread;
                    const randomPixelOffsetY = (Math.random() * 2 - 1) * maxPixelSpread;

                    const finalTranslateX = `calc(-50% + ${randomPixelOffsetX}px)`;
                    const finalTranslateY = `calc(-50% + ${randomPixelOffsetY}px)`;
                    const finalTransform = `translate(${finalTranslateX}, ${finalTranslateY})`;

                    const initialTranslateX = finalTranslateX;
                    const initialTranslateY = `calc(-50% + ${randomPixelOffsetY + fallStartOffsetY}px)`;
                    const initialTransform = `translate(${initialTranslateX}, ${initialTranslateY})`;

                    goldEl.style.transform = initialTransform;
                    goldEl.style.opacity = '0';

                    goldEl.style.setProperty('--item-x', deathX + 1);
                    goldEl.style.setProperty('--item-y', deathY + 1);
                    goldEl.style.left = `calc((var(--item-x) - 0.5) * var(--cell-size))`;
                    goldEl.style.top = `calc((var(--item-y) - 0.5) * var(--cell-size))`;

                    fragment.appendChild(goldEl);
                    items.push(goldItem);

                    requestAnimationFrame(() => {
                        if (goldEl && goldEl.parentNode) {
                            goldEl.style.transform = finalTransform;
                            goldEl.style.opacity = '1';
                        }
                    });
                }
            }
            gridContent.appendChild(fragment);
            getCellElement(deathX, deathY)?.classList.add('has-item');
        }
    }

    unit.hp = 0;

    const handleUnitDataRemoval = () => {
        const finalUnitIndex = units.findIndex(u => u.id === unitId);
        if (finalUnitIndex !== -1) {
            units.splice(finalUnitIndex, 1);
        }
        checkWinLossConditions(); // Check win/loss *after* data is removed
    };

    if (unitElement?.parentNode) {
        if (!unitElement.classList.contains('dead')) {
            const deathSpriteUrl = UNIT_DATA[unitType]?.deadSpriteUrl;
            if (deathSpriteUrl) {
                unitElement.style.backgroundImage = `url('${deathSpriteUrl}')`;
            }
            unitElement.className = 'unit dead';
            unitElement.style.filter = 'none';
            unitElement.style.boxShadow = 'none';
            unitElement.style.transform = 'translate(-50%, -50%)';
            unitElement.style.pointerEvents = 'none';
            unitElement.style.opacity = '1';
            updateUnitVisualPositionOnly(unitElement, deathX, deathY);
        }

        const deathDisplayTime = 1500;
        setTimeout(() => {
            if (unitElement?.parentNode && unitElement.classList.contains('dead') && !unitElement.classList.contains('fading-out')) {
                unitElement.classList.add('fading-out');
                setTimeout(() => {
                    unitElement?.remove();
                    handleUnitDataRemoval();
                }, DEATH_FADE_DURATION_MS);
            } else if (!unitElement?.parentNode) {
                handleUnitDataRemoval(); // Element already gone, just remove data
            }
        }, deathDisplayTime);

    } else {
        handleUnitDataRemoval(); // No element to animate, remove data immediately
    }

    if (selectedUnit?.id === unitId) {
        deselectUnit(false);
    }
    if (lastHoveredUnitId === unitId) {
        hideTooltip();
    }
    updateUnitInfo(selectedUnit);
}

        function setActiveSpell(spellName) {
            if (!audioInitialized) initializeAudio();
            if (levelClearedAwaitingInput) return;
            const wasSelected = currentSpell === spellName;
            currentSpell = null;
            clearFrostNovaPreview();
            if (gameBoard) gameBoard.style.removeProperty('--hover-col');
            if (wasSelected) {
                showFeedback('');
                playSfx('select');
            } else if (spellName) {
                const spellDataMap = {
                    fireball: { unlock: FIREBALL_UNLOCK_LEVEL, available: spellUses.fireball, feedback: 'Select ENEMY target for Fireball.' },
                    flameWave: { unlock: FLAME_WAVE_UNLOCK_LEVEL, available: spellUses.flameWave, feedback: 'Click target ROW for Flame Wave.' },
                    frostNova: { unlock: FROST_NOVA_UNLOCK_LEVEL, available: spellUses.frostNova, feedback: 'Select CENTER cell for Frost Nova.' },
                    heal: { unlock: HEAL_UNLOCK_LEVEL, available: spellUses.heal, feedback: 'Select FRIENDLY unit to Heal.' }
                };
                const data = spellDataMap[spellName];
                if (data) {
                    const normallyUnlocked = currentLevel >= data.unlock;
                    const cheatActive = unlimitedSpellsCheat;
                    const isEffectivelyUnlocked = normallyUnlocked || cheatActive;
                    const isAvailableThisLevel = data.available || cheatActive;
                    if (isProcessing || currentTurn !== 'player' || !isEffectivelyUnlocked || !isAvailableThisLevel) {
                        if (!isEffectivelyUnlocked) showFeedback(`Unlock at Level ${data.unlock}!`, "feedback-error");
                        else if (!isAvailableThisLevel) showFeedback(`${spellName.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())} already used this level.`, 'feedback-error');
                        else showFeedback("Cannot select spell now.", "feedback-error");
                        playSfx('error');
                    } else {
                        currentSpell = spellName;
                        showFeedback(data.feedback);
                        playSfx('select');
                    }
                }
            }
            updateSpellUI();
        }

        function castFireball(targetUnit) {
            if (levelClearedAwaitingInput || !isUnitAliveAndValid(targetUnit) || !gridContent) return;
            const normallyUnlocked = currentLevel >= FIREBALL_UNLOCK_LEVEL; const isEffectivelyUnlocked = normallyUnlocked || unlimitedSpellsCheat;
            const isAvailable = spellUses.fireball || unlimitedSpellsCheat;
            if (!isAvailable || !isEffectivelyUnlocked || targetUnit.team !== 'enemy' || isProcessing) return;
            isProcessing = true; updateTurnDisplay(); setActiveSpell(null); if (!unlimitedSpellsCheat) spellUses.fireball = false; updateSpellUI();
            const targetUnitId = targetUnit.id; const originalCoords = { x: targetUnit.x, y: targetUnit.y };
            const projectileEl = document.createElement('div'); projectileEl.className = 'projectile fireball-projectile';

            const spellIconRect = fireballElement.getBoundingClientRect();
            const gridRect = gridContent.getBoundingClientRect();

            const startX = spellIconRect.left - gridRect.left + spellIconRect.width / 2;
            const startY = spellIconRect.top - gridRect.top + spellIconRect.height / 2;
            const endX = (originalCoords.x + 0.5) * currentCellSize;
            const endY = (originalCoords.y + 0.5) * currentCellSize;

            const angleRad = Math.atan2(endY - startY, endX - startX); const angleDeg = angleRad * (180 / Math.PI);
            projectileEl.style.transform = `translate(-50%, -50%) rotate(${angleDeg}deg)`;
            projectileEl.style.left = `${startX}px`; projectileEl.style.top = `${startY}px`;
            gridContent.appendChild(projectileEl);
            playSfx('fireballShoot'); void projectileEl.offsetWidth;
            projectileEl.style.left = `${endX}px`; projectileEl.style.top = `${endY}px`;

            setTimeout(() => {
                projectileEl.remove(); playSfx('fireballHit');
                const stillTarget = units.find(u => u.id === targetUnitId);
                if (isUnitAliveAndValid(stillTarget) && stillTarget.x === originalCoords.x && stillTarget.y === originalCoords.y) {
                    stillTarget.hp -= FIREBALL_DAMAGE; if (stillTarget.hp < 0) stillTarget.hp = 0;
                    showDamagePopup(stillTarget.x, stillTarget.y, FIREBALL_DAMAGE);
                    stillTarget.element?.classList.add('unit-hit-flash');
                    setTimeout(() => { stillTarget.element?.classList.remove('unit-hit-flash'); }, 200);
                    updateUnitInfo(selectedUnit === stillTarget ? stillTarget : (lastHoveredUnitId === stillTarget.id ? stillTarget : null));
                    if (tooltipElement?.classList.contains('visible') && lastHoveredUnitId === stillTarget.id) showTooltip(stillTarget);
                    if (stillTarget.hp <= 0) removeUnit(stillTarget, originalCoords.x, originalCoords.y);
                }
                const explosionEl = document.createElement('div'); explosionEl.className = 'fireball-explosion';
                explosionEl.style.left = `${endX}px`; explosionEl.style.top = `${endY}px`;
                gridContent.appendChild(explosionEl);
                setTimeout(() => explosionEl.remove(), FIREBALL_EXPLOSION_DURATION_MS);
                isProcessing = false; checkWinLossConditions(); updateTurnDisplay();
            }, FIREBALL_PROJECTILE_DURATION_MS);
        }

        function castFlameWave(targetRow) {
             if (levelClearedAwaitingInput || !gridContent) return;
             const normallyUnlocked = currentLevel >= FLAME_WAVE_UNLOCK_LEVEL; const isEffectivelyUnlocked = normallyUnlocked || unlimitedSpellsCheat;
             const isAvailable = spellUses.flameWave || unlimitedSpellsCheat;
             if (!isAvailable || !isEffectivelyUnlocked || isProcessing || targetRow < 0 || targetRow >= currentGridRows) return;
             isProcessing = true; updateTurnDisplay(); setActiveSpell(null); if (!unlimitedSpellsCheat) spellUses.flameWave = false; updateSpellUI();
             const processedUnitsInRow = new Set();
             let cellsProcessed = 0; const totalCells = currentGridCols; let soundPlayed = false;

             for (let x = 0; x < currentGridCols; x++) {
                 const currentDelay = x * FLAME_WAVE_STAGGER_DELAY_MS;
                 setTimeout(() => {
                     if (!isCellInBounds(x, targetRow) || getObstacleAt(x, targetRow)) {
                          cellsProcessed++; if (cellsProcessed === totalCells) { isProcessing = false; checkWinLossConditions(); updateTurnDisplay(); } return;
                     }
                     const cellCenterX = (x + 0.5) * currentCellSize;
                     const cellCenterY = (targetRow + 0.5) * currentCellSize;
                     const explosionEl = document.createElement('div'); explosionEl.className = 'fireball-explosion';
                     explosionEl.style.left = `${cellCenterX}px`; explosionEl.style.top = `${cellCenterY}px`;
                     gridContent.appendChild(explosionEl);
                     setTimeout(() => explosionEl.remove(), FIREBALL_EXPLOSION_DURATION_MS);
                     if (!soundPlayed) { playSfx('fireballHit'); soundPlayed = true; }
                     const unit = getUnitAt(x, targetRow);
                     if (unit && isUnitAliveAndValid(unit) && !processedUnitsInRow.has(unit.id)) {
                         processedUnitsInRow.add(unit.id); unit.hp -= FLAME_WAVE_DAMAGE; if (unit.hp < 0) unit.hp = 0;
                         showDamagePopup(unit.x, unit.y, FLAME_WAVE_DAMAGE);
                         unit.element?.classList.add('unit-hit-flash');
                         setTimeout(() => { unit.element?.classList.remove('unit-hit-flash'); }, 200);
                         updateUnitInfo(selectedUnit === unit ? unit : (lastHoveredUnitId === unit.id ? unit : null));
                         if (tooltipElement?.classList.contains('visible') && lastHoveredUnitId === unit.id) showTooltip(unit);
                         if (unit.hp <= 0) removeUnit(unit, x, targetRow);
                     }
                     cellsProcessed++; if (cellsProcessed === totalCells) { isProcessing = false; checkWinLossConditions(); updateTurnDisplay(); }
                 }, currentDelay);
             }
        }

        function castFrostNova(centerX, centerY) {
            if (levelClearedAwaitingInput) { showFeedback("Level cleared, cannot cast spells.", "feedback-error"); playSfx('error'); setActiveSpell(null); return; }
            const normallyUnlocked = currentLevel >= FROST_NOVA_UNLOCK_LEVEL; const isEffectivelyUnlocked = normallyUnlocked || unlimitedSpellsCheat;
            const isAvailable = spellUses.frostNova || unlimitedSpellsCheat;
            if (!isAvailable || !isEffectivelyUnlocked || isProcessing || !isCellInBounds(centerX, centerY) || getObstacleAt(centerX, centerY)) {
                if (!isEffectivelyUnlocked) showFeedback(`Unlock at Level ${FROST_NOVA_UNLOCK_LEVEL}!`, "feedback-error");
                else if (!isAvailable) showFeedback("Frost Nova already used.", "feedback-error");
                else if (getObstacleAt(centerX, centerY)) showFeedback("Cannot cast on obstacle.", "feedback-error");
                else showFeedback("Invalid Frost Nova target/state.", "feedback-error");
                playSfx('error'); setActiveSpell(null); return;
            }
            isProcessing = true; updateTurnDisplay(); setActiveSpell(null); if (!unlimitedSpellsCheat) spellUses.frostNova = false;
            updateSpellUI(); playSfx('frostNovaCast');
            setTimeout(() => {
                let unitsFrozenCount = 0; let newlyFrozen = false;
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const targetX = centerX + dx; const targetY = centerY + dy;
                         if (isCellInBounds(targetX, targetY) && !getObstacleAt(targetX, targetY)) {
                            const unit = getUnitAt(targetX, targetY);
                             if (unit?.team === 'enemy' && isUnitAliveAndValid(unit)) {
                                if (!unit.isFrozen) newlyFrozen = true;
                                unit.isFrozen = true; unit.frozenTurnsLeft = FROST_NOVA_DURATION;
                                showFreezePopup(unit.x, unit.y); updateUnitPosition(unit);
                                updateUnitInfo(selectedUnit === unit ? unit : (lastHoveredUnitId === unit.id ? unit : null));
                                if (tooltipElement?.classList.contains('visible') && lastHoveredUnitId === unit.id) showTooltip(unit);
                                unitsFrozenCount++;
                            }
                        }
                    }
                }
                 if (unitsFrozenCount > 0 && newlyFrozen) playSfx('frostNovaHit');
                 else if (unitsFrozenCount === 0) { playSfx('error'); showFeedback("No enemies hit.", "feedback-error"); }
                 else { playSfx('frostNovaHit'); }

                isProcessing = false; checkWinLossConditions(); updateTurnDisplay();
            }, 200);
        }

        function castHeal(targetUnit) {
            if (levelClearedAwaitingInput) { showFeedback("Level cleared, cannot cast spells.", "feedback-error"); playSfx('error'); setActiveSpell(null); return; }
            const normallyUnlocked = currentLevel >= HEAL_UNLOCK_LEVEL; const isEffectivelyUnlocked = normallyUnlocked || unlimitedSpellsCheat;
            const isAvailable = spellUses.heal || unlimitedSpellsCheat;
            if (!isAvailable || !isEffectivelyUnlocked || !targetUnit || !isUnitAliveAndValid(targetUnit) || targetUnit.team !== 'player' || isProcessing) {
                if (!isEffectivelyUnlocked) showFeedback(`Unlock at Level ${HEAL_UNLOCK_LEVEL}!`, "feedback-error");
                else if (!isAvailable) showFeedback("Heal already used.", "feedback-error");
                else showFeedback("Invalid Heal target/state.", "feedback-error");
                playSfx('error'); setActiveSpell(null); return;
            }
            if (targetUnit.hp >= targetUnit.maxHp) { showFeedback("Unit at full HP.", "feedback-error"); playSfx('error'); setActiveSpell(null); return; }
            isProcessing = true; updateTurnDisplay(); setActiveSpell(null); if (!unlimitedSpellsCheat) spellUses.heal = false;
            updateSpellUI(); playSfx('heal');
            const healApplied = Math.min(HEAL_AMOUNT, targetUnit.maxHp - targetUnit.hp);
            targetUnit.hp += healApplied; showHealPopup(targetUnit.x, targetUnit.y, healApplied);
            targetUnit.element?.classList.add('unit-hit-flash');
            setTimeout(() => { targetUnit.element?.classList.remove('unit-hit-flash'); }, 200);
            updateUnitInfo(selectedUnit === targetUnit ? targetUnit : (lastHoveredUnitId === targetUnit.id ? targetUnit : null));
            if (tooltipElement?.classList.contains('visible') && lastHoveredUnitId === targetUnit.id) showTooltip(targetUnit);
            isProcessing = false; updateTurnDisplay(); checkWinLossConditions();
        }

        function getValidMoves(unit) {
            if (!unit || (!levelClearedAwaitingInput && unit.acted) || unit.isFrozen || !isUnitAliveAndValid(unit)) return [];
            const moves = [];
            const queue = [{ x: unit.x, y: unit.y, distance: 0 }];
            const visited = new Set([`${unit.x},${unit.y}`]);
            const directions = [[0, -1], [0, 1], [-1, 0], [1, 0]];

            while (queue.length > 0) {
                const current = queue.shift();
                for (const [dx, dy] of directions) {
                    const nextX = current.x + dx;
                    const nextY = current.y + dy;
                    const key = `${nextX},${nextY}`;

                    if (!isCellInBounds(nextX, nextY) || visited.has(key)) continue;

                    const newDistance = current.distance + 1;
                    if (newDistance > unit.mov) continue;

                    if (!getUnitAt(nextX, nextY) && !getObstacleAt(nextX, nextY)?.blocksMove) {
                        moves.push({ x: nextX, y: nextY });
                        visited.add(key);
                        queue.push({ x: nextX, y: nextY, distance: newDistance });
                    }
                }
            }
            return moves;
        }

        function hasLineOfSight(startUnit, endUnit) {
             if (!startUnit || !endUnit) return false;
             const startX = startUnit.x; const startY = startUnit.y;
             const endX = endUnit.x; const endY = endUnit.y;
             let x = startX; let y = startY;
             const dx = Math.abs(endX - startX); const dy = -Math.abs(endY - startY);
             const sx = startX < endX ? 1 : -1; const sy = startY < endY ? 1 : -1;
             let err = dx + dy;
             while (true) {
                 if (x === endX && y === endY) break;
                 let nextX = x; let nextY = y;
                 let e2 = 2 * err; let moved = false;
                 if (e2 >= dy) { if (x === endX) break; err += dy; nextX += sx; moved = true; }
                 if (e2 <= dx) { if (y === endY) break; err += dx; nextY += sy; moved = true; }
                 if (!moved) break;
                 if (nextX === endX && nextY === endY) break;
                 if (getObstacleAt(nextX, nextY)?.blocksLOS) return false;
                 x = nextX; y = nextY;
                 if (Math.abs(x - startX) > currentGridCols * 2 || Math.abs(y - startY) > currentGridRows * 2) break;
             }
             return true;
        }

        function getValidAttacks(unit) {
            const attacks = [];
            if (!unit || (!levelClearedAwaitingInput && unit.acted) || unit.isFrozen || !isUnitAliveAndValid(unit) || levelClearedAwaitingInput) return attacks;
            const unitRange = unit.range || 1;
            for (const target of units) {
                if (target.team !== unit.team && isUnitAliveAndValid(target)) {
                    const distance = getDistance(unit, target);
                    if (distance <= unitRange && (unitRange === 1 || hasLineOfSight(unit, target))) {
                         attacks.push(target.id);
                    }
                }
            }
            return attacks;
        }

        function processFreezeTicks(team) {
            let thawedCount = 0;
            for (const unit of units) {
                if (unit.team === team && unit.isFrozen && isUnitAliveAndValid(unit)) {
                    unit.frozenTurnsLeft--;
                    if (unit.frozenTurnsLeft <= 0) {
                        unit.isFrozen = false; thawedCount++;
                        updateUnitPosition(unit);
                    }
                    if (selectedUnit?.id === unit.id || (!selectedUnit && lastHoveredUnitId === unit.id)) updateUnitInfo(unit);
                    if (tooltipElement?.classList.contains('visible') && lastHoveredUnitId === unit.id) showTooltip(unit);
                }
            }
            return thawedCount;
        }

        function endTurn() {
            const itemsLeft = items.some(item => (item.type === 'gold' || (item.type === 'chest' && !item.opened)));
            if (levelClearedAwaitingInput && !itemsLeft) {
                playSfx('success'); startNextLevel(); return;
            }
            if (currentTurn !== 'player' || isProcessing || isGameOver()) return;
            if (!initializeAudio()) return;
            playSfx('select'); isProcessing = true; updateTurnDisplay();
            deselectUnit(false); setActiveSpell(null); updateUnitInfo(null);
            lastHoveredUnitId = null; showFeedback(''); hideTooltip();
            currentTurn = 'enemy'; processFreezeTicks('enemy');
            for (const u of units) {
                if (u.team === 'enemy' && isUnitAliveAndValid(u)) {
                    u.acted = false; updateUnitPosition(u);
                }
            }
            updateTurnDisplay(); setTimeout(runAITurn, 400);
        }

        function runAITurn() {
             const unitsToAct = units.filter(u => u.team === 'enemy' && isUnitAliveAndValid(u) && !u.acted && !u.isFrozen);
             let currentAIUnitIndex = 0; const totalActions = unitsToAct.length;
             const actionInterval = 150;
             const minActionDuration = Math.max(MOVE_ANIMATION_DURATION_MS, ARROW_FLY_DURATION_MS) + 150;

             async function processNextAIUnit() {
                 if (!isGameActive || isGameOver()) { endAITurnSequence(); return; }
                 if (currentAIUnitIndex >= totalActions) { endAITurnSequence(); return; }

                 const unitToProcess = unitsToAct[currentAIUnitIndex];
                 currentAIUnitIndex++;

                 const stillValidUnit = units.find(u => u.id === unitToProcess.id && isUnitAliveAndValid(u) && !u.acted && !u.isFrozen);

                 if (stillValidUnit) {
                     const actionStartTime = Date.now();
                     try {
                         updateTurnDisplay();
                         await performAIAction(stillValidUnit);
                     } catch (e) {
                          console.error(`Error during AI action for unit ${stillValidUnit.id}:`, e);
                          if (isUnitAliveAndValid(stillValidUnit) && !stillValidUnit.acted) finishAction(stillValidUnit);
                     } finally {
                         const actionEndTime = Date.now();
                         const duration = actionEndTime - actionStartTime;
                         const delayNeeded = Math.max(actionInterval, minActionDuration - duration);
                         setTimeout(processNextAIUnit, delayNeeded);
                     }
                 } else {
                     setTimeout(processNextAIUnit, 50);
                 }
             }

             function endAITurnSequence() {
                 if (!isGameActive) return;
                 if (!isGameOver()) {
                     currentTurn = 'player';
                     processFreezeTicks('player');
                     for (const u of units) {
                          if (u.team === 'player' && isUnitAliveAndValid(u)) u.acted = false;
                          if (isUnitAliveAndValid(u) && u.element) {
                              if (u.team === 'enemy') {
                                  u.element.classList.remove('acted');
                              }
                              updateUnitPosition(u);
                          }
                     }
                     showFeedback("Player Turn!");
                     isProcessing = false;
                     updateTurnDisplay();
                 } else {
                     if (endTurnButton) { endTurnButton.disabled = true; endTurnButton.classList.add('disabled'); }
                     isProcessing = true;
                     updateTurnDisplay();
                 }
             }

             if (totalActions === 0) endAITurnSequence();
             else setTimeout(processNextAIUnit, 100);
        }

        async function performAIAction(unit) {
             if (!unit || !isUnitAliveAndValid(unit) || unit.isFrozen) {
                 if (unit && !unit.acted) finishAction(unit);
                 return;
             }

             const livingPlayers = units.filter(u => u.team === 'player' && isUnitAliveAndValid(u));
             if (livingPlayers.length === 0) {
                 if (!unit.acted) finishAction(unit);
                 return;
             }

             const unitRange = unit.range || 1;
             const possibleAttacks = getValidAttacks(unit);

             if (possibleAttacks.length > 0) {
                 let targetToAttack = null;
                 let bestTargetScore = -Infinity;
                 for (const id of possibleAttacks) {
                     const target = units.find(u => u.id === id);
                     if (target && isUnitAliveAndValid(target)) {
                         let score = 1000 - target.hp;
                         const isCurrentTargetRanged = getDistance(unit, target) > 1;
                         if (unitRange > 1 && isCurrentTargetRanged) score += 500;
                         else if (unitRange === 1 && !isCurrentTargetRanged) score += 500;
                         if (score > bestTargetScore) { bestTargetScore = score; targetToAttack = target; }
                     }
                 }
                 if (targetToAttack) {
                     attackUnit(unit, targetToAttack);
                     return;
                 }
             }

             let nearestPlayer = null; let minDistance = Infinity;
             for (const p of livingPlayers) {
                 const d = getDistance(unit, p);
                 if (d < minDistance) { minDistance = d; nearestPlayer = p; }
             }

             if (nearestPlayer) {
                 const possibleMoves = getValidMoves(unit);
                 if (possibleMoves.length > 0) {
                     let bestMove = null;
                     let bestMoveScore = -Infinity;
                     for (const moveOption of possibleMoves) {
                         if (!isUnitAliveAndValid(nearestPlayer)) continue;
                         const distAfterMove = Math.abs(moveOption.x - nearestPlayer.x) + Math.abs(moveOption.y - nearestPlayer.y);
                         let moveScore = 1000 - distAfterMove;
                         if (unitRange > 1) {
                             const optimalDist = unitRange;
                             if (distAfterMove <= optimalDist && distAfterMove > 0) moveScore += 500 - Math.abs(distAfterMove - optimalDist) * 10;
                         } else {
                             if (distAfterMove === 1) moveScore += 500;
                         }
                         if (distAfterMove <= unitRange) {
                             if (unitRange > 1 && hasLineOfSight({ x: moveOption.x, y: moveOption.y }, nearestPlayer)) moveScore += 200;
                             else if (unitRange === 1) moveScore += 200;
                         }
                         if (moveScore > bestMoveScore) { bestMoveScore = moveScore; bestMove = moveOption; }
                     }

                     const currentPosScore = 1000 - minDistance +
                         ((unitRange > 1 && minDistance <= unitRange && minDistance > 0 && hasLineOfSight(unit, nearestPlayer)) || (unitRange === 1 && minDistance === 1) ? 700 : 0);

                     if (bestMove && bestMoveScore > currentPosScore && (bestMove.x !== unit.x || bestMove.y !== unit.y)) {
                         await moveUnit(unit, bestMove.x, bestMove.y);
                         finishAction(unit);
                         return;
                     }
                 }
             }

             if (!unit.acted && isUnitAliveAndValid(unit)) {
                 finishAction(unit);
             }
        }

        function checkWinLossConditions() {
            if (winCheckTimeout) clearTimeout(winCheckTimeout);
            winCheckTimeout = setTimeout(() => {
                if (!isGameActive || isGameOver() || levelClearedAwaitingInput) { winCheckTimeout = null; return; }
                const playersLeft = units.some(u => u.team === 'player' && isUnitAliveAndValid(u));
                const enemiesLeft = units.some(u => u.team === 'enemy' && isUnitAliveAndValid(u));

                if (!enemiesLeft && playersLeft) {
                    playSfx('success'); deselectUnit(false); setActiveSpell(null); hideTooltip(); lastHoveredUnitId = null;
                    const itemsLeft = items.some(item => (item.type === 'gold' || (item.type === 'chest' && !item.opened)));
                    if (itemsLeft) {
                        levelClearedAwaitingInput = true; isProcessing = false;
                        showFeedback(`Level Cleared! Collect Items!`, 'feedback-levelup');
                        updateTurnDisplay();
                    } else {
                        isProcessing = true;
                        showFeedback(`Level ${currentLevel} Cleared!`, 'feedback-levelup');
                        updateTurnDisplay();
                        setTimeout(startNextLevel, 1800);
                    }
                } else if (!playersLeft) {
                     gameOver(false);
                }
                winCheckTimeout = null;
            }, 100);
        }

        function startNextLevel() {
            if (isGameOver()) return;
            currentLevel++; levelToRestartOnLoss = currentLevel; isProcessing = true;
            stopMusic(); selectAndLoadMusic();
            calculateGridDimensions(currentLevel);
            resetLevelState(); resetSpellStateForNewLevel(); initializeGridState();
            updateLevelDisplay(); updateGoldDisplay(); updateUnitInfo(null); lastHoveredUnitId = null;
            if (endTurnButton) { endTurnButton.disabled = true; endTurnButton.classList.add('disabled'); }
            showFeedback(`Level ${currentLevel} Start!`, 'feedback-levelup');
            requestAnimationFrame(() => {
                try {
                    calculateCellSize(); setupBoard(); spawnObstacles(); spawnInitialUnits(); spawnItems();
                    for (const u of units) { if (u.team === 'player') { u.acted = false; u.isFrozen = false; u.frozenTurnsLeft = 0; } }
                    renderAllUnitsAndItems(); applyLayout(); centerView(true); updateTurnDisplay(); startMusicIfNotPlaying();
                } catch (e) { console.error("Error during next level setup render:", e); }
                finally { isProcessing = false; updateTurnDisplay(); }
            });
        }

        function gameOver(playerWon) {
            if (isGameOver()) return;
            isGameActive = false; levelClearedAwaitingInput = false; isProcessing = true;
            stopMusic(); hideTooltip(); stopTooltipUpdater();
            document.removeEventListener('mousemove', trackMousePosition);
            window.removeEventListener('resize', handleResize);
            document.removeEventListener('fullscreenchange', updateFullscreenButton);
            document.removeEventListener('webkitfullscreenchange', updateFullscreenButton);
            document.removeEventListener('mozfullscreenchange', updateFullscreenButton);
            document.removeEventListener('MSFullscreenChange', updateFullscreenButton);
            gameBoard?.removeEventListener('mousedown', handlePanStart);
            if (winCheckTimeout) clearTimeout(winCheckTimeout); winCheckTimeout = null;
            if (resizeTimeout) clearTimeout(resizeTimeout); resizeTimeout = null;

            let messageText = "";
            if (!playerWon) {
                playSfx('gameOver');
                const goldBeforePenalty = playerGold;
                playerGold = Math.max(0, playerGold - GOLD_PENALTY_ON_DEATH);
                updateGoldDisplay();
                messageText = `You have fallen on Level ${currentLevel}!<br>Gold: ${goldBeforePenalty} - ${GOLD_PENALTY_ON_DEATH} Penalty = ${playerGold}`;
                if (restartButton) restartButton.textContent = "Restart Level";
            } else {
                playSfx('success');
                levelToRestartOnLoss = 1;
                messageText = `You are victorious! Final Level: ${currentLevel}, Final Gold: ${playerGold}`;
                if (restartButton) restartButton.textContent = "Play Again?";
            }

            deselectUnit(false); updateUnitInfo(null); lastHoveredUnitId = null; setActiveSpell(null);
            if (endTurnButton) { endTurnButton.disabled = true; endTurnButton.classList.add('disabled'); }
            if (gameOverTitle) gameOverTitle.textContent = playerWon ? "Victory!" : "Defeat!";
            if (gameOverMessage) gameOverMessage.innerHTML = messageText;
            gameOverScreen?.classList.add('visible');
            menuOverlay?.classList.remove('visible'); leaderboardOverlay?.classList.remove('visible'); levelSelectScreen?.classList.remove('visible');
        }

        async function handleCellClick(event) {
             if (isPanning || event.target.closest('.unit, .item') || isProcessing) return;
             if (!isGameActive || !initializeAudio()) return;
             const cell = event.currentTarget; const x = parseInt(cell.dataset.x); const y = parseInt(cell.dataset.y);
             if (!isCellInBounds(x, y) || getObstacleAt(x, y)) { playSfx('error'); showFeedback("Cannot target obstacle.", "feedback-error"); if (currentSpell) setActiveSpell(null); if (selectedUnit) deselectUnit(false); return; }
             const unitOnCell = getUnitAt(x, y);
             const itemOnCell = getItemAt(x, y);

             if (!levelClearedAwaitingInput && currentSpell) {
                 switch (currentSpell) {
                     case 'fireball': playSfx('error'); showFeedback("Target an ENEMY unit.", "feedback-error"); setActiveSpell(null); if (selectedUnit) deselectUnit(false); return;
                     case 'frostNova': castFrostNova(x, y); return;
                     case 'flameWave': castFlameWave(y); return;
                     case 'heal': playSfx('error'); showFeedback("Select a FRIENDLY unit.", "feedback-error"); setActiveSpell(null); if (selectedUnit) deselectUnit(false); return;
                 }
             } else if (levelClearedAwaitingInput && currentSpell) { setActiveSpell(null); showFeedback("Level cleared, cannot cast spells.", "feedback-error"); playSfx('error'); return; }
             if (currentTurn === 'player' && selectedUnit) {
                 const isMoveValid = validMoves.some(p => p.x === x && p.y === y);
                 if (isMoveValid && !unitOnCell && !getObstacleAt(x,y)) {
                     const unitToMove = selectedUnit;

                     checkForItemPickup(unitToMove, x, y);

                     unitToMove.element?.classList.remove('selected');
                     clearHighlights();
                     selectedUnit = null;
                     isProcessing = true;
                     updateTurnDisplay();
                     await moveUnit(unitToMove, x, y);


                     if (!levelClearedAwaitingInput) { finishAction(unitToMove); }
                     else { updateUnitPosition(unitToMove); }
                     updateUnitInfo(null);
                     isProcessing = false;
                     updateTurnDisplay();

                 } else { deselectUnit(); }
             } else { deselectUnit(false); }
        }

        function handleUnitClick(event, clickedUnit) {
             event.stopPropagation();
             if (isPanning || !isGameActive || isProcessing || !clickedUnit || !isUnitAliveAndValid(clickedUnit)) { deselectUnit(false); updateUnitInfo(null); return; }
             if (!initializeAudio()) return;
             if (!levelClearedAwaitingInput && currentSpell) {
                 switch (currentSpell) {
                     case 'fireball': if (clickedUnit.team === 'enemy') castFireball(clickedUnit); else { playSfx('error'); showFeedback("Target an ENEMY unit.", "feedback-error"); setActiveSpell(null); updateUnitInfo(clickedUnit); } return;
                     case 'frostNova': castFrostNova(clickedUnit.x, clickedUnit.y); return;
                     case 'flameWave': castFlameWave(clickedUnit.y); return;
                     case 'heal': if (clickedUnit.team === 'player') castHeal(clickedUnit); else { playSfx('error'); showFeedback("Target a FRIENDLY unit.", "feedback-error"); setActiveSpell(null); updateUnitInfo(clickedUnit); } return;
                 }
             } else if (levelClearedAwaitingInput && currentSpell) { setActiveSpell(null); showFeedback("Level cleared, cannot cast spells.", "feedback-error"); playSfx('error'); return; }
             updateUnitInfo(clickedUnit);
             if (currentTurn === 'player') {
                 if (selectedUnit) {
                     if (!levelClearedAwaitingInput && clickedUnit.team === 'enemy' && validAttacks.includes(clickedUnit.id)) { const attacker = selectedUnit; deselectUnit(false); isProcessing = true; updateTurnDisplay(); attackUnit(attacker, clickedUnit); }
                     else if (clickedUnit.team === 'player' && clickedUnit.id !== selectedUnit.id) { if ((!clickedUnit.acted || levelClearedAwaitingInput) && !clickedUnit.isFrozen) { selectUnit(clickedUnit); } else if (clickedUnit.isFrozen) { showFeedback("Cannot select: Unit is Frozen!", "feedback-error"); playSfx('error'); deselectUnit(false); } else if (clickedUnit.acted && !levelClearedAwaitingInput) { showFeedback("Cannot select: Unit already acted.", "feedback-error"); playSfx('error'); deselectUnit(false); } else { deselectUnit(); } }
                     else if (clickedUnit.id === selectedUnit.id) { deselectUnit(); }
                     else { playSfx('error'); if (levelClearedAwaitingInput && clickedUnit.team === 'enemy') showFeedback("Level cleared, cannot attack.", "feedback-error"); else if (clickedUnit.team === 'enemy') { const targetExists = units.find(u => u.id === clickedUnit.id && isUnitAliveAndValid(u)); if (targetExists) { if (getDistance(selectedUnit, targetExists) > selectedUnit.range) showFeedback("Enemy out of range.", "feedback-error"); else if (selectedUnit.range > 1 && !hasLineOfSight(selectedUnit, targetExists)) showFeedback("Line of sight blocked.", "feedback-error"); else showFeedback("Invalid target.", "feedback-error"); } else showFeedback("Invalid target.", "feedback-error"); } else showFeedback("Invalid action.", "feedback-error"); deselectUnit(false); }
                 } else {
                     if (clickedUnit.team === 'player' && (!clickedUnit.acted || levelClearedAwaitingInput) && !clickedUnit.isFrozen) { selectUnit(clickedUnit); }
                     else if (clickedUnit.team === 'player' && clickedUnit.acted && !levelClearedAwaitingInput) { showFeedback("Unit already acted.", "feedback-error"); playSfx('error'); }
                     else if (clickedUnit.team === 'player' && clickedUnit.isFrozen) { showFeedback("Unit is Frozen!", "feedback-error"); playSfx('error'); }
                 }
             }
        }

        function handleCellMouseEnter(event) {
            if (!isGameActive || isProcessing || !gameBoard) return;
            const cell = event.currentTarget;
            if (cell.classList.contains('has-obstacle')) { clearFrostNovaPreview(); return; }
            if (currentSpell === 'flameWave') gameBoard.style.setProperty('--hover-col', parseInt(cell.dataset.x));
            else if (currentSpell === 'frostNova') { clearFrostNovaPreview(); highlightFrostNovaArea(parseInt(cell.dataset.x), parseInt(cell.dataset.y)); }
        }

        function handleCellMouseLeave(event) { if (isGameActive && currentSpell === 'frostNova' && !isProcessing) clearFrostNovaPreview(); }
        function highlightFrostNovaArea(centerX, centerY) { for (let dx = -1; dx <= 1; dx++) { for (let dy = -1; dy <= 1; dy++) { const targetX = centerX + dx; const targetY = centerY + dy; if (isCellInBounds(targetX, targetY) && !getObstacleAt(targetX, targetY)) { getCellElement(targetX, targetY)?.classList.add('frost-aoe-preview'); } } } }
        function clearFrostNovaPreview() { gridContent?.querySelectorAll('.grid-cell.frost-aoe-preview').forEach(cell => cell.classList.remove('frost-aoe-preview')); }

        function handleKeyDown(event) {
             const gameShouldProcessKeys = isGameActive && !isGameOver() && !isMenuOpen() && !isLeaderboardOpen() && !isLevelSelectOpen();
             const isOverlayVisible = isGameOver() || isMenuOpen() || isLeaderboardOpen() || isLevelSelectOpen() || startScreen?.classList.contains('visible');

            if (event.key === 'm' || event.key === 'M') { toggleMute(); event.preventDefault(); return; }
            if (event.key === 'f' || event.key === 'F') { toggleFullscreen(); event.preventDefault(); return; }

            if (event.key === 'Escape') {
                  if (isMenuOpen()) { hideMenu(); event.preventDefault(); return; }
                  if (isLeaderboardOpen()) { hideLeaderboard(); event.preventDefault(); return; }
                  if (isLevelSelectOpen()) { showStartScreen(); event.preventDefault(); return; }
                 if (gameShouldProcessKeys && currentTurn === 'player' && !isProcessing) {
                      if (currentSpell) { setActiveSpell(null); event.preventDefault(); }
                      else if (selectedUnit) { deselectUnit(); event.preventDefault(); }
                 }
                 return;
            }

            if (!gameShouldProcessKeys || isProcessing || (event.metaKey || event.ctrlKey || event.altKey)) return;

            if (event.shiftKey) {
                 const lowerKey = event.key.toLowerCase();
                 if (lowerKey === 'g') {
                    event.preventDefault(); unlimitedSpellsCheat = !unlimitedSpellsCheat;
                    showFeedback(unlimitedSpellsCheat ? "CHEAT: Unlimited/Unlocked Spells ON!" : "CHEAT: Unlimited/Unlocked Spells OFF.", "feedback-cheat"); playSfx('cheat');
                    if (unlimitedSpellsCheat) spellUses = { fireball: true, flameWave: true, frostNova: true, heal: true };
                    else resetSpellStateForNewLevel();
                    updateSpellUI(); return;
                 }
                 if (lowerKey === 't' && currentTurn === 'player' && !levelClearedAwaitingInput) {
                     isProcessing = true; updateTurnDisplay(); deselectUnit(false); setActiveSpell(null); hideTooltip(); lastHoveredUnitId = null;
                     showFeedback("CHEAT: Skipping Level...", "feedback-levelup"); playSfx('cheat');
                     setTimeout(startNextLevel, 100); event.preventDefault(); return;
                 }
                  if (lowerKey === 'p') {
                      event.preventDefault(); playerGold += 10; updateGoldDisplay();
                      showFeedback("+10 Cheat Gold!", "feedback-cheat"); playSfx('cheat'); return;
                  }
             }

            if (currentTurn === 'player') {
                 if (!levelClearedAwaitingInput) {
                     switch (event.key) {
                         case '1': setActiveSpell('fireball'); event.preventDefault(); break;
                         case '2': setActiveSpell('flameWave'); event.preventDefault(); break;
                         case '3': setActiveSpell('frostNova'); event.preventDefault(); break;
                         case '4': setActiveSpell('heal'); event.preventDefault(); break;
                     }
                 }
                 if (event.key.toLowerCase() === 'e') { endTurn(); event.preventDefault(); }
            }
        }

        function toggleMute() {
            if (!initializeAudio()) return;
            isMuted = !isMuted; bgMusic.muted = isMuted;
            for (const key in sfx) { sfx[key].muted = isMuted; }
            updateMuteButtonVisual();
            if (!isMuted) startMusicIfNotPlaying(); else stopMusic();
        }

        function updateMuteButtonVisual() {
            if (muteButton) {
                muteButton.innerHTML = isMuted ? '🔇 Unmute' : '🔊 Mute Sound';
                muteButton.title = isMuted ? 'Unmute (M)' : 'Mute Sound (M)';
            }
        }

        function isFullscreen() {
            return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
        }

        function toggleFullscreen() {
            if (!initializeAudio()) return;
            const fsEnabled = document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled;
            if (!fsEnabled) return;
            if (!isFullscreen()) {
                gameContainer?.requestFullscreen?.().catch(()=>{});
                gameContainer?.webkitRequestFullscreen?.().catch(()=>{});
                gameContainer?.mozRequestFullScreen?.().catch(()=>{});
                gameContainer?.msRequestFullscreen?.().catch(()=>{});
            } else {
                document.exitFullscreen?.().catch(()=>{});
                document.webkitExitFullscreen?.().catch(()=>{});
                document.mozCancelFullScreen?.().catch(()=>{});
                document.msExitFullscreen?.().catch(()=>{});
            }
        }

        function updateFullscreenButton() {
            const fsEnabled = document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled;
            if (fullscreenButton) {
                fullscreenButton.disabled = !fsEnabled;
                fullscreenButton.innerHTML = isFullscreen() ? '&#x2715; Exit Fullscreen' : '&#x26F6; Fullscreen';
                fullscreenButton.title = isFullscreen() ? 'Exit Fullscreen (F)' : 'Enter Fullscreen (F)';
            }
        }

        function showMenu() {
             if ((!isGameActive && !startScreen?.classList.contains('visible')) || isGameOver() || isLevelSelectOpen() || isMenuOpen()) return;
             if (!initializeAudio()) return;
             playSfx('menuOpen');
             updateGoldDisplay();
             menuOverlay?.classList.add('visible');
             leaderboardOverlay?.classList.remove('visible');
             hideTooltip();
         }
         function hideMenu() {
             if (!isMenuOpen()) return;
             playSfx('menuClose');
             menuOverlay?.classList.remove('visible');
         }
         function showLeaderboard() {
             if (!initializeAudio()) return;
             playSfx('select');
             leaderboardOverlay?.classList.add('visible');
             menuOverlay?.classList.remove('visible');
             hideTooltip();
         }
         function hideLeaderboard() {
             if (!isLeaderboardOpen()) return;
             playSfx('select');
             leaderboardOverlay?.classList.remove('visible');
         }
         function showLevelSelect() {
             fullGameReset();
             startScreen?.classList.remove('visible');
             gameOverScreen?.classList.remove('visible');
             menuOverlay?.classList.remove('visible');
             leaderboardOverlay?.classList.remove('visible');
             levelSelectScreen?.classList.add('visible');
         }
         function hideLevelSelect() {
              levelSelectScreen?.classList.remove('visible');
         }
         function showStartScreen() {
              fullGameReset();
              startScreen?.classList.add('visible');
              gameOverScreen?.classList.remove('visible');
              menuOverlay?.classList.remove('visible');
              leaderboardOverlay?.classList.remove('visible');
              levelSelectScreen?.classList.remove('visible');
              if (endTurnButton) { endTurnButton.classList.add('disabled'); endTurnButton.disabled = true; }
              updateUnitInfo(null); updateLevelDisplay(); updateGoldDisplay();
              updateTurnDisplay(); isProcessing = false; isGameActive = false;
         }
         function isGameOver() { return gameOverScreen?.classList.contains('visible'); }
         function isMenuOpen() { return menuOverlay?.classList.contains('visible'); }
         function isLeaderboardOpen() { return leaderboardOverlay?.classList.contains('visible'); }
         function isLevelSelectOpen() { return levelSelectScreen?.classList.contains('visible'); }

        document.addEventListener('DOMContentLoaded', () => {
            gameContainer = document.getElementById('game-container');
            gameBoard = document.getElementById('game-board');
            gridContent = document.getElementById('grid-content');
            uiPanel = document.getElementById('ui-panel');
            levelDisplayElement = document.getElementById('level-display');
            goldDisplayUIElement = document.getElementById('gold-display-ui-panel');
            spellAreaElement = document.getElementById('spell-area');
            fireballElement = document.getElementById('fireball-spell'); flameWaveElement = document.getElementById('flame-wave-spell'); frostNovaElement = document.getElementById('frost-nova-spell'); healElement = document.getElementById('heal-spell');
            unitInfo = document.getElementById('unit-info'); unitPortraitElement = document.getElementById('unit-portrait');
            actionsLeftDisplayElement = document.getElementById('actions-left-display'); unitNameDisplay = document.getElementById('unit-name'); unitHpDisplay = document.getElementById('unit-hp'); unitAtkDisplay = document.getElementById('unit-atk'); unitMovDisplay = document.getElementById('unit-mov'); unitRngDisplay = document.getElementById('unit-rng'); unitStatusDisplay = document.getElementById('unit-status');
            boardFeedbackArea = document.getElementById('board-feedback-area'); endTurnButton = document.getElementById('end-turn-button');
            startScreen = document.getElementById('start-screen'); gameOverScreen = document.getElementById('game-over-screen'); startButton = document.getElementById('start-button'); restartButton = document.getElementById('restart-button'); gameOverTitle = document.getElementById('game-over-title'); gameOverMessage = document.getElementById('game-over-message');
            fullscreenButton = document.getElementById('fullscreen-button'); muteButton = document.getElementById('mute-button'); tooltipElement = document.getElementById('unit-tooltip');
            leaderboardButton = document.getElementById('leaderboard-button'); leaderboardOverlay = document.getElementById('leaderboard-overlay'); leaderboardList = document.getElementById('leaderboard-list'); closeLeaderboardButton = document.getElementById('close-leaderboard-button');
            menuButton = document.getElementById('menu-button'); menuOverlay = document.getElementById('menu-overlay'); closeMenuButton = document.getElementById('close-menu-button'); restartLevelMenuButton = document.getElementById('restart-level-menu-button'); quitToLevelSelectButton = document.getElementById('quit-to-level-select-button');
            levelSelectScreen = document.getElementById('level-select-screen'); levelSelectContainer = document.getElementById('level-select-container'); backToStartButton = document.getElementById('back-to-start-button'); menuGoldAmountElement = document.getElementById('menu-gold-amount');

            try {
                const rootStyle = getComputedStyle(document.documentElement);
                const parseCssDuration = (varName, fallback) => {
                    const str = rootStyle.getPropertyValue(varName).trim();
                    if (str.endsWith('ms')) return parseFloat(str);
                    if (str.endsWith('s')) return parseFloat(str) * 1000;
                    return fallback;
                };
                MOVE_ANIMATION_DURATION_MS = parseCssDuration('--move-anim-time', 250);
                FLAME_WAVE_STAGGER_DELAY_MS = parseCssDuration('--flame-wave-stagger-delay', 50);
                DEATH_FADE_DURATION_MS = parseCssDuration('--death-fade-time', 1000);
            } catch (e) { console.warn("Could not parse animation durations from CSS.", e); }

            menuButton?.addEventListener('click', showMenu);
            closeMenuButton?.addEventListener('click', hideMenu);
            muteButton?.addEventListener('click', toggleMute);
            fireballElement?.addEventListener('click', () => setActiveSpell('fireball'));
            flameWaveElement?.addEventListener('click', () => setActiveSpell('flameWave'));
            frostNovaElement?.addEventListener('click', () => setActiveSpell('frostNova'));
            healElement?.addEventListener('click', () => setActiveSpell('heal'));
            fullscreenButton?.addEventListener('click', toggleFullscreen);
            leaderboardButton?.addEventListener('click', showLeaderboard);
            closeLeaderboardButton?.addEventListener('click', hideLeaderboard);
            backToStartButton?.addEventListener('click', showStartScreen);
            startButton?.addEventListener('click', () => { initializeAudio(); if (startScreen?.classList.contains('visible') && !isProcessing) initGame(1); });
            restartButton?.addEventListener('click', () => { initializeAudio(); initGame(levelToRestartOnLoss); });
            restartLevelMenuButton?.addEventListener('click', () => { if (!isGameActive) return; playSfx('select'); hideMenu(); setTimeout(() => initGame(currentLevel), 50); });
            quitToLevelSelectButton?.addEventListener('click', () => { playSfx('menuClose'); hideMenu(); showLevelSelect(); });
            levelSelectContainer?.addEventListener('click', (event) => {
                 if (event.target.classList.contains('level-select-button')) {
                     const level = parseInt(event.target.dataset.level);
                     if (!isNaN(level)) {
                          playSfx('levelSelect'); hideLevelSelect();
                          if (level === 1) playerGold = 0;
                          setTimeout(() => initGame(level), 50);
                     }
                 }
            });
            endTurnButton?.addEventListener('click', () => { if (isGameActive && currentTurn === 'player' && !isProcessing && !isGameOver()) endTurn(); });
            bgMusic.addEventListener('ended', selectAndLoadMusic);

            showStartScreen();
            updateMuteButtonVisual();
            requestAnimationFrame(() => { try { calculateCellSize(); updateFullscreenButton(); } catch (e) {console.error("Error in initial setup RAF:", e);} });
            window.addEventListener('keydown', handleKeyDown);
        });
    </script>
</body>
</html>
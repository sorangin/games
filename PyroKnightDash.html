<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pyro Knight Dash</title>
    <style>
        body { margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #1a1a2e; overflow: hidden; color: white; font-family: 'Courier New', Courier, monospace; }
        #game-container { position: relative; width: 800px; height: 600px; overflow: hidden; box-shadow: 0 0 15px rgba(0, 0, 0, 0.7); background-color: #0f0f1a; }
        #gameCanvas { display: block; width: 100%; height: 100%; background-color: #5c94fc; image-rendering: pixelated; image-rendering: crisp-edges; }
        #fullscreen-btn { position: absolute; bottom: 10px; right: 10px; padding: 8px 10px; background-color: rgba(0, 0, 0, 0.6); color: white; border: 1px solid white; border-radius: 5px; cursor: pointer; font-size: 20px; line-height: 1; z-index: 10; }
        #fullscreen-btn:hover { background-color: rgba(50, 50, 50, 0.8); }
        #message-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.75); display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 20; font-size: 1.3em; line-height: 1.6; cursor: pointer; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }
        #message-overlay.hidden { display: none; }
        #message-overlay.error { color: red; font-weight: bold; border: 2px solid red; padding: 15px; background-color: rgba(50,0,0,0.8); }
        #message-overlay.paused { font-size: 2em; font-weight: bold; text-shadow: 2px 2px 4px black; }
        .ui-element { position: absolute; top: 10px; color: white; font-size: 20px; text-shadow: 1px 1px 2px black; z-index: 5; }
        #score-display { left: 10px; }
        #health-display { right: 10px; }
        #health-display span { font-size: 24px; margin-left: 4px; color: #ff4d4d; }
        #boost-display { top: 40px; right: 10px; font-size: 16px; color: #f0e68c; display: none; }
        #audio-container { position: absolute; opacity: 0; width: 1px; height: 1px; overflow: hidden; pointer-events: none; }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="score-display" class="ui-element">Score: 0</div>
        <div id="health-display" class="ui-element">Health: <span>♥</span><span>♥</span><span>♥</span></div>
        <div id="boost-display" class="ui-element">SPEED BOOST!</div>
        <button id="fullscreen-btn" title="Toggle Fullscreen">⛶</button>
        <div id="message-overlay">Loading...</div>
        <div id="audio-container"></div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const messageOverlay = document.getElementById('message-overlay');
        const scoreDisplay = document.getElementById('score-display');
        const healthDisplay = document.getElementById('health-display');
        const boostDisplay = document.getElementById('boost-display');
        const audioContainer = document.getElementById('audio-container');

        const GAME_WIDTH = 800; const GAME_HEIGHT = 600;
        canvas.width = GAME_WIDTH; canvas.height = GAME_HEIGHT;
        const GRAVITY = 0.55; const BASE_PLAYER_SPEED = 4.8; const JUMP_FORCE = 12.5;
        const PLAYER_MAX_HEALTH = 3; const PLAYER_INVULNERABILITY_DURATION = 1200;
        const FIREBALL_SPEED = 8; const BASE_GOBLIN_SPEED = 1.2;
        const CAMERA_PLAYER_SCREEN_X_RATIO = 0.3;
        const CAMERA_SMOOTH_FACTOR = 0.08;
        const OFFSCREEN_BUFFER = 200; const GENERATION_DISTANCE = GAME_WIDTH * 1.5;
        const SPEED_BOOST_MULTIPLIER = 1.5; const SPEED_BOOST_DURATION = 8000;
        const MAGIC_BOLT_SPEED = 5; const ROOK_SPEED = 0.8; const ROOK_HEALTH = 2;
        const PARTICLE_GRAVITY = 0.1;
        const COYOTE_TIME_DURATION = 80;
        const JUMP_BUFFER_DURATION = 100;
        const ENEMY_HIT_FLASH_DURATION = 100;

        const GROUND_Y = GAME_HEIGHT - 60; const GROUND_THICKNESS = 60; const PLATFORM_THICKNESS = 20; const MIN_GROUND_WIDTH = 250; const MAX_GROUND_WIDTH = 550; const MIN_FLOAT_WIDTH = 75; const MAX_FLOAT_WIDTH = 170; const MIN_GAP = 50; const MAX_GAP = 135; const MIN_FLOAT_Y = GAME_HEIGHT - 280; const MAX_FLOAT_Y = GAME_HEIGHT - 90; const MAX_Y_DELTA_UP = 70; const GROUND_PROBABILITY = 0.60; const GOBLIN_SPAWN_CHANCE = 0.35; const ROOK_SPAWN_CHANCE = 0.15; const BISHOP_SPAWN_CHANCE = 0.10; const MIN_ENEMY_SPACING = 200; const MIN_PLATFORM_WIDTH_FOR_ENEMY = 90; const COIN_SPAWN_CHANCE = 0.50; const POWERUP_SPAWN_CHANCE = 0.05; const COIN_VALUE = 5; const ROOK_SCORE = 25; const BISHOP_SCORE = 35;
        const HIGH_SCORE_KEY = 'pyroKnightDashHighScore';

        const assets = { knight:null,goblin:null,fireball:null,coin:null,rook:null,bishop:null,speedBoost:null,magicBolt:null, bgSky: null, bgHills: null, bgGround: null };
        const assetSources = {
            knight:'sprites/KnightB.png',goblin:'sprites/Goblin.png',fireball:'sprites/sFireball1.png',coin:'sprites/coin.png',
            rook:'sprites/bRook.png',bishop:'sprites/wBishop.png',speedBoost:'sprites/wQueen.png',magicBolt:'sprites/sFireball1.png',
            bgSky: 'sprites/background_sky.png', bgHills: 'sprites/background_hills.png', bgGround: 'sprites/background_ground.png'
        };
        const htmlAudioElements = {};
        const audioSources = { jump: 'audio/jump.wav', shoot: 'audio/shoot.wav', coin: 'audio/coin.wav', powerup: 'audio/powerup.wav', playerHurt: 'audio/player_hurt.wav', playerDie: 'audio/player_die.wav', enemyHit: 'audio/enemy_hit.wav', start: 'audio/start_beep.wav', bgm: 'audio/bgm.mp3' };
        let assetsLoaded = 0; let totalAssetsToLoad = Object.keys(assetSources).length + Object.keys(audioSources).length; let gameReady = false; let loadError = false; let assetsLoadingStarted = false; let userInteracted = false;
        function showMessage(text, isError = false, isPause = false) { messageOverlay.innerHTML = text; messageOverlay.classList.remove('hidden', 'error', 'paused'); if (isError) messageOverlay.classList.add('error'); else if (isPause) messageOverlay.classList.add('paused'); messageOverlay.style.cursor = (gameState === 'ready' || gameState === 'gameOver') ? 'pointer' : 'default'; }
        function hideMessage() { messageOverlay.classList.add('hidden'); }
        function assetLoadedCallback(assetName, isAudio = false) { if (loadError) return; assetsLoaded++; if (assetsLoaded >= totalAssetsToLoad) { console.log("All assets loaded."); gameReady = true; gameState = 'ready'; showMessage(`High Score: ${highScore}<br>Press Any Key or Click/Tap to Start`); } else { if (gameState === 'loading') { showMessage(`Loading assets... (${assetsLoaded}/${totalAssetsToLoad})`); } } }
        function assetErrorCallback(assetName, event, isAudio = false) { if (loadError && messageOverlay.classList.contains('error')) return; const type = isAudio ? 'audio' : 'image'; console.error(`!!! Error loading ${type}: ${assetName}`, event); let errorMsg = `ERROR LOADING ${type.toUpperCase()}: "${assetName}"<br>Check console (F12) & file path/name.<br>Make sure file exists and path is correct.<br>Refresh after fixing.`; showMessage(errorMsg, true); loadError = true; assetsLoaded = -9999; }
        function loadAssets() { if (assetsLoadingStarted || loadError) return; assetsLoadingStarted = true; loadError = false; assetsLoaded = 0; totalAssetsToLoad = Object.keys(assetSources).length + Object.keys(audioSources).length; showMessage(`Loading assets... (0/${totalAssetsToLoad})`); let imagesToLoad = Object.keys(assetSources).length; if (imagesToLoad === 0) console.log("No images to load."); for (const key in assetSources) { assets[key] = new Image(); assets[key].onload = () => assetLoadedCallback(key, false); assets[key].onerror = (e) => assetErrorCallback(key, e, false); assets[key].src = assetSources[key]; } let audioToLoad = Object.keys(audioSources).length; if (audioToLoad === 0) console.log("No audio files defined."); for (const key in audioSources) { const audioElement = new Audio(); audioElement.id = `audio_${key}`; audioElement.preload = 'auto'; audioElement.addEventListener('canplaythrough', () => assetLoadedCallback(key, true), { once: true }); audioElement.addEventListener('error', (e) => assetErrorCallback(key, e, true), { once: true }); audioElement.src = audioSources[key]; htmlAudioElements[key] = audioElement; audioContainer.appendChild(audioElement); } if (assetsLoaded >= totalAssetsToLoad && imagesToLoad > 0) { gameReady = true; gameState = 'ready'; showMessage(`High Score: ${highScore}<br>Press Any Key or Click/Tap to Start`); } }
        function playHtmlSound(key, volume = 1.0) { if (!userInteracted) return; const audioElement = htmlAudioElements[key]; if (audioElement) { audioElement.volume = volume; audioElement.currentTime = 0; const playPromise = audioElement.play(); if (playPromise !== undefined) { playPromise.catch(error => { }); } } }
        function loopHtmlSound(key, volume = 1.0) { if (!userInteracted) return; const audioElement = htmlAudioElements[key]; if (audioElement) { audioElement.volume = volume; audioElement.loop = true; const playPromise = audioElement.play(); if (playPromise !== undefined) { playPromise.catch(error => { }); } } }
        function stopHtmlSound(key) { const audioElement = htmlAudioElements[key]; if (audioElement) { audioElement.pause(); audioElement.currentTime = 0; if(key === 'bgm') audioElement.loop = false; } }
        function handleFirstInteraction() { if (!userInteracted) { userInteracted = true; } }

        let keys = { left: false, right: false, up: false, shoot: false }; let player = null; let goblins = []; let rooks = []; let bishops = []; let fireballs = []; let magicBolts = []; let platforms = []; let coins = []; let powerUps = []; let backgroundElements = []; let particles = []; let lastTime = 0; let score = 0; let distanceScore = 0; let cameraX = 0; let cameraY = 0; let lastPlatformX = 0; let lastEnemySpawnX = 0; let gameState = 'loading'; let lastTimestamp = 0;
        let gameOverMessageTimeoutId = null;
        let lastDisplayedScore = -1;
        let lastDisplayedHealth = -1;
        let highScore = 0;

        function loadHighScore() { const savedScore = localStorage.getItem(HIGH_SCORE_KEY); highScore = savedScore ? parseInt(savedScore, 10) : 0; if (isNaN(highScore)) highScore = 0; console.log(`Loaded High Score: ${highScore}`); }
        function saveHighScore(newScore) { if (newScore > highScore) { highScore = newScore; localStorage.setItem(HIGH_SCORE_KEY, highScore.toString()); console.log(`New High Score Saved: ${highScore}`); return true; } return false; }

        class GameObject {
            constructor(x,y,w,h,k=null){this.x=x;this.y=y;this.width=w;this.height=h;this.spriteKey=k;this.active=true;this.color=null;}
            get sprite(){return this.spriteKey?assets[this.spriteKey]:null;}
            draw(ctx,cX,cY){if(!this.active)return;const i=this.sprite;const dX=Math.round(this.x-cX);const dY=Math.round(this.y-cY);if(dX+this.width<-OFFSCREEN_BUFFER||dX>GAME_WIDTH+OFFSCREEN_BUFFER||dY+this.height<-OFFSCREEN_BUFFER||dY>GAME_HEIGHT+OFFSCREEN_BUFFER)return;if(i && i.complete && i.naturalWidth > 0){ctx.drawImage(i,dX,dY,this.width,this.height);}else if(this.color){ctx.fillStyle=this.color;ctx.fillRect(dX,dY,this.width,this.height);}else{ctx.fillStyle='magenta';ctx.fillRect(dX,dY,this.width,this.height);}}
            collidesWith(o){return this.active&&o.active&&this.x<o.x+o.width&&this.x+this.width>o.x&&this.y<o.y+o.height&&this.y+this.height>o.y;}
            update(dT,p){}
        }

        class Player extends GameObject{
            constructor(x,y){super(x,y,50,60,'knight');this.vx=0;this.vy=0;this.isOnGround=false;this.wasOnGround=false; this.canJump=true;this.shootCooldown=0;this.shootDelay=25;this.facingRight=true;this.health=PLAYER_MAX_HEALTH;this.isInvulnerable=false;this.invulnerabilityTimer=0;this.flashState=false;this.isBoosted=false;this.boostTimer=0; this.coyoteTimeCounter = 0; this.jumpBufferCounter = 0;}
            update(dT, p) { if (!this.active) return; const currentSpeed = this.isBoosted ? BASE_PLAYER_SPEED * SPEED_BOOST_MULTIPLIER : BASE_PLAYER_SPEED; const currentShootDelay = this.isBoosted ? Math.round(this.shootDelay / SPEED_BOOST_MULTIPLIER) : this.shootDelay; if (this.isInvulnerable) { this.invulnerabilityTimer -= dT; if (this.invulnerabilityTimer <= 0) this.isInvulnerable = false; this.flashState = !this.flashState; } else { this.flashState = false; } if (this.isBoosted) { this.boostTimer -= dT; if (this.boostTimer <= 0) { this.isBoosted = false; boostDisplay.style.display = 'none'; } } if (this.shootCooldown > 0) this.shootCooldown -= (dT / 16.67); this.vx = 0; if (keys.left) { this.vx = -currentSpeed; this.facingRight = false; } if (keys.right) { this.vx = currentSpeed; this.facingRight = true; } let nX = this.x + this.vx; let tempHorizRect = { x: nX, y: this.y, width: this.width, height: this.height, active: true }; for (let i = 0; i < p.length; i++) { const plat = p[i]; if (plat.collidesWith(tempHorizRect)) { if (this.vx > 0) nX = plat.x - this.width; else if (this.vx < 0) nX = plat.x + plat.width; this.vx = 0; break; } } this.x = nX; this.wasOnGround = this.isOnGround; if (this.isOnGround) { this.coyoteTimeCounter = COYOTE_TIME_DURATION; } else { if (this.coyoteTimeCounter > 0) this.coyoteTimeCounter -= dT; } if (keys.up) { this.jumpBufferCounter = JUMP_BUFFER_DURATION; keys.up = false; } else { if (this.jumpBufferCounter > 0) this.jumpBufferCounter -= dT; } if (this.jumpBufferCounter > 0 && (this.isOnGround || this.coyoteTimeCounter > 0)) { this.vy = -JUMP_FORCE; this.isOnGround = false; this.coyoteTimeCounter = 0; this.jumpBufferCounter = 0; playHtmlSound('jump'); } if (keys.shoot && this.shootCooldown <= 0) { this.shoot(); this.shootCooldown = currentShootDelay; keys.shoot = false; } this.vy += GRAVITY; this.isOnGround = false; let nY = this.y + this.vy; let tempVertRect = { x: this.x, y: nY, width: this.width, height: this.height, active: true }; for (let i = 0; i < p.length; i++) { const plat = p[i]; if (plat.collidesWith(tempVertRect)) { if (this.vy > 0 && this.y + this.height <= plat.y + 1) { nY = plat.y - this.height; this.vy = 0; this.isOnGround = true; break; } else if (this.vy < 0 && this.y >= plat.y + plat.height - 1) { nY = plat.y + plat.height; this.vy = 0; } else if (this.vy > 0 && (this.x + this.width > plat.x && this.x < plat.x + plat.width)) { if (tempVertRect.y + tempVertRect.height > plat.y) { nY = plat.y - this.height; this.vy = 0; this.isOnGround = true; break; } } } } this.y = nY; if (this.isOnGround && !this.wasOnGround && this.vy >= 0) { spawnDustParticles(this.x + this.width / 2, this.y + this.height, 5); } if (this.y > GAME_HEIGHT + 150) { this.takeDamage(this.health); }}
            shoot(){let fX=this.facingRight?this.x+this.width:this.x-20;let fY=this.y+this.height/2-10;let vX=this.facingRight?FIREBALL_SPEED:-FIREBALL_SPEED;fireballs.push(new Fireball(fX,fY,vX)); playHtmlSound('shoot'); }
            takeDamage(a=1){if(this.isInvulnerable||!this.active)return;this.health-=a;updateHealthUI(this.health); playHtmlSound('playerHurt'); if(this.health<=0){this.die();}else{this.isInvulnerable=true;this.invulnerabilityTimer=PLAYER_INVULNERABILITY_DURATION;this.flashState=true;}}
            activateBoost(){if(!this.active)return;this.isBoosted=true;this.boostTimer=SPEED_BOOST_DURATION;boostDisplay.style.display='block'; playHtmlSound('powerup'); }
            draw(ctx,cX,cY){if(!this.active)return;const dX=Math.round(this.x-cX);const dY=Math.round(this.y-cY);if(dX+this.width<-OFFSCREEN_BUFFER||dX>GAME_WIDTH+OFFSCREEN_BUFFER||dY+this.height<-OFFSCREEN_BUFFER||dY>GAME_HEIGHT+OFFSCREEN_BUFFER)return;ctx.save();const i=this.sprite;if(!i || !i.complete || i.naturalWidth === 0){ctx.fillStyle='magenta';ctx.fillRect(dX,dY,this.width,this.height);ctx.restore();return;} if(this.isInvulnerable&&this.flashState)ctx.globalAlpha=0.5; if(this.isBoosted)ctx.filter='hue-rotate(90deg) brightness(1.2)'; if(!this.facingRight){ctx.translate(dX+this.width,dY);ctx.scale(-1,1);ctx.drawImage(i,0,0,this.width,this.height);}else{ctx.translate(dX,dY);ctx.drawImage(i,0,0,this.width,this.height);}ctx.restore();}
            die(){
                if(!this.active)return; this.active=false; gameState='gameOver'; stopHtmlSound('bgm'); playHtmlSound('playerDie'); spawnPlayerDeathParticles(this.x + this.width/2, this.y + this.height/2);
                const finalScore = score + distanceScore; const newHighScore = saveHighScore(finalScore);
                if (gameOverMessageTimeoutId) clearTimeout(gameOverMessageTimeoutId);
                gameOverMessageTimeoutId = setTimeout(()=>{
                    if (gameState === 'gameOver') {
                         let message = `Game Over!<br>Final Score: ${finalScore}<br>`;
                         message += newHighScore ? `NEW High Score: ${highScore}!<br>` : `High Score: ${highScore}<br>`;
                         message += `Tap/Click/Key to Restart`; showMessage(message);
                    }
                    gameOverMessageTimeoutId = null;
                }, 800);
            }
        }
        class Enemy extends GameObject {
             constructor(x, y, w, h, k) { super(x, y, w, h, k); this.isHit = false; this.hitTimer = 0; }
             update(dT, p) { if (this.hitTimer > 0) { this.hitTimer -= dT; if (this.hitTimer <= 0) this.isHit = false; } }
             triggerHitFlash() { this.isHit = true; this.hitTimer = ENEMY_HIT_FLASH_DURATION; }
             baseDraw(ctx, cX, cY, defaultColor, facingRight) {
                if(!this.active)return;const dX=Math.round(this.x-cX);const dY=Math.round(this.y-cY);if(dX+this.width<-OFFSCREEN_BUFFER||dX>GAME_WIDTH+OFFSCREEN_BUFFER||dY+this.height<-OFFSCREEN_BUFFER||dY>GAME_HEIGHT+100)return;ctx.save();const i=this.sprite; let drawImage = i && i.complete && i.naturalWidth > 0;
                if (this.isHit) ctx.filter = 'brightness(2.5) grayscale(0.5)';
                if(!facingRight){ ctx.translate(dX+this.width,dY);ctx.scale(-1,1); if (drawImage) ctx.drawImage(i,0,0,this.width,this.height); else { ctx.fillStyle = defaultColor; ctx.fillRect(0,0,this.width,this.height); }
                }else{ ctx.translate(dX,dY); if (drawImage) ctx.drawImage(i,0,0,this.width,this.height); else { ctx.fillStyle = defaultColor; ctx.fillRect(0,0,this.width,this.height); } }
                ctx.restore();
             }
             hitByFireball() { if(!this.active) return false; playHtmlSound('enemyHit'); spawnHitParticles(this.x+this.width/2, this.y+this.height/2); this.triggerHitFlash(); return true; }
        }
        class Goblin extends Enemy {
             constructor(x, y, patrolWidth = 50) { super(x, y, 45, 55, 'goblin'); this.vx = BASE_GOBLIN_SPEED * (Math.random() < 0.5 ? 1 : -1); this.vy = 0; this.isOnGround = false; this.patrolStartX = x; this.patrolEndX = x + patrolWidth; this.facingRight = this.vx > 0; }
             update(dT, p) { if (!this.active) return; super.update(dT); this.vy += GRAVITY * 0.8; this.isOnGround = false; let nY = this.y + this.vy; let tempVertRect = { x: this.x, y: nY, width: this.width, height: this.height, active: true }; let platformBelow = null; for (let i = 0; i < p.length; i++) { const plat = p[i]; if (plat.collidesWith(tempVertRect)) { if (this.vy > 0 && this.y + this.height <= plat.y + 1) { nY = plat.y - this.height; this.vy = 0; this.isOnGround = true; platformBelow = plat; break; } else if (this.vy < 0 && this.y >= plat.y + plat.height -1) { nY = plat.y + plat.height; this.vy = 0; } } } this.y = nY; if (this.isOnGround && platformBelow) { let nX = this.x + this.vx; const currentPlatformStartX = platformBelow.x; const currentPlatformEndX = platformBelow.x + platformBelow.width; if ((this.vx > 0 && nX + this.width > currentPlatformEndX) || (this.vx < 0 && nX < currentPlatformStartX)) { this.vx *= -1; nX = this.x; this.facingRight = this.vx > 0; } let tempHorizRect = { x: nX, y: this.y, width: this.width, height: this.height, active: true }; for (let i = 0; i < p.length; i++) { const plat = p[i]; if(plat === platformBelow) continue; if (plat.collidesWith(tempHorizRect)) { if (this.vx > 0) nX = plat.x - this.width; else if (this.vx < 0) nX = plat.x + plat.width; this.vx *= -1; this.facingRight = this.vx > 0; break; } } this.x = nX; } if (this.y > GAME_HEIGHT + 100) this.active = false; }
             draw(ctx,cX,cY){ super.baseDraw(ctx, cX, cY, 'lime', this.facingRight); }
             hitByFireball(){ if(super.hitByFireball()) { this.active=false; score+=10; } }
        }
        class Rook extends Enemy {
            constructor(x, y) { super(x, y, 50, 70, 'rook'); this.vx = ROOK_SPEED * (Math.random() < 0.5 ? 1 : -1); this.vy = 0; this.health = ROOK_HEALTH; this.isOnGround = false; this.facingRight = this.vx > 0; }
            update(dT, p) { if (!this.active) return; super.update(dT); this.vy += GRAVITY; this.isOnGround = false; let nY = this.y + this.vy; let tempVertRect = { x: this.x, y: nY, width: this.width, height: this.height, active: true }; let platformBelow = null; for (let i = 0; i < p.length; i++) { const plat = p[i]; if (plat.collidesWith(tempVertRect)) { if (this.vy > 0 && this.y + this.height <= plat.y + 1) { nY = plat.y - this.height; this.vy = 0; this.isOnGround = true; platformBelow = plat; break; } else if (this.vy < 0 && this.y >= plat.y + plat.height - 1) { nY = plat.y + plat.height; this.vy = 0; } } } this.y = nY; if (this.isOnGround && platformBelow) { let nX = this.x + this.vx; const currentPlatformStartX = platformBelow.x; const currentPlatformEndX = platformBelow.x + platformBelow.width; if ((this.vx > 0 && nX + this.width > currentPlatformEndX) || (this.vx < 0 && nX < currentPlatformStartX)) { this.vx *= -1; nX = this.x; this.facingRight = this.vx > 0; } let tempHorizRect = { x: nX, y: this.y, width: this.width, height: this.height, active: true }; for (let i = 0; i < p.length; i++) { const plat = p[i]; if(plat === platformBelow) continue; if (plat.collidesWith(tempHorizRect)) { if (this.vx > 0) nX = plat.x - this.width; else if (this.vx < 0) nX = plat.x + plat.width; this.vx *= -1; this.facingRight = this.vx > 0; break; } } this.x = nX; } if (this.y > GAME_HEIGHT + 100) this.active = false; }
            draw(ctx,cX,cY){ super.baseDraw(ctx, cX, cY, '#666', this.facingRight); }
            hitByFireball() { if(super.hitByFireball()) { this.health--; if (this.health <= 0) { this.active = false; score += ROOK_SCORE; } } }
        }
        class Bishop extends Enemy {
             constructor(x, y) { super(x, y, 55, 75, 'bishop'); this.shootCooldown = 180 + Math.random() * 120; this.shootTimer = this.shootCooldown * Math.random(); this.facingRight = false; this.vy = 0; this.isOnGround = false; }
             update(dT, p) { if (!this.active || !player) return; super.update(dT); this.vy += GRAVITY; this.isOnGround = false; let nY = this.y + this.vy; let tempVertRect = { x: this.x, y: nY, width: this.width, height: this.height, active: true }; for (let i = 0; i < p.length; i++) { const plat = p[i]; if (plat.collidesWith(tempVertRect)) { if (this.vy > 0 && this.y + this.height <= plat.y + 1) { nY = plat.y - this.height; this.vy = 0; this.isOnGround = true; break; } else if (this.vy < 0 && this.y >= plat.y + plat.height - 1) { nY = plat.y + plat.height; this.vy = 0; } } } this.y = nY; if(this.isOnGround && player.active) { this.facingRight = (player.x > this.x); this.shootTimer -= (dT / 16.67); if (this.shootTimer <= 0) { const verticalDist = Math.abs((player.y + player.height / 2) - (this.y + this.height / 2)); if (verticalDist < GAME_HEIGHT * 0.6) { this.shoot(); this.shootTimer = this.shootCooldown; } else { this.shootTimer = this.shootCooldown * 0.3; } } } else { if(this.shootTimer < this.shootCooldown * 0.5) { this.shootTimer = this.shootCooldown * 0.5; } } if (this.y > GAME_HEIGHT + 100) this.active = false; }
             shoot() { let bX = this.facingRight ? this.x + this.width : this.x - 15; let bY = this.y + this.height * 0.4; let bVX = this.facingRight ? MAGIC_BOLT_SPEED : -MAGIC_BOLT_SPEED; magicBolts.push(new MagicBolt(bX, bY, bVX)); }
             draw(ctx,cX,cY){ super.baseDraw(ctx, cX, cY, '#9370DB', this.facingRight); }
             hitByFireball(){ if(super.hitByFireball()){ this.active=false;score+=BISHOP_SCORE; } }
        }
        class Fireball extends GameObject{constructor(x,y,vx){super(x,y,20,20,'fireball');this.vx=vx;}update(dT){if(!this.active)return;this.x+=this.vx * (dT/16.67);if(this.x<cameraX-OFFSCREEN_BUFFER||this.x>cameraX+GAME_WIDTH+OFFSCREEN_BUFFER)this.active=false;}}
        class MagicBolt extends GameObject{constructor(x,y,vx){super(x,y,18,18,'magicBolt');this.vx=vx;this.color='#9932CC';}update(dT){if(!this.active)return;this.x+=this.vx * (dT/16.67);if(this.x<cameraX-OFFSCREEN_BUFFER||this.x>cameraX+GAME_WIDTH+OFFSCREEN_BUFFER)this.active=false;}draw(ctx,cX,cY){if(!this.active)return;const i=this.sprite;const dX=Math.round(this.x-cX);const dY=Math.round(this.y-cY);if(dX+this.width<-OFFSCREEN_BUFFER||dX>GAME_WIDTH+OFFSCREEN_BUFFER||dY+this.height<-OFFSCREEN_BUFFER||dY>GAME_HEIGHT+OFFSCREEN_BUFFER)return;ctx.save();if(i && i.complete && i.naturalWidth > 0){ctx.filter='hue-rotate(200deg) saturate(2)';ctx.drawImage(i,dX,dY,this.width,this.height);}else{ctx.fillStyle=this.color;ctx.fillRect(dX,dY,this.width,this.height);}ctx.restore();}}
        class Coin extends GameObject{constructor(x,y){super(x,y,25,25,'coin');this.baseY=y;this.angle=Math.random()*Math.PI*2;}update(dT){if(!this.active)return;this.angle+=0.05 * (dT / 16.67);this.y=this.baseY+Math.sin(this.angle)*3;}collect(){if(!this.active) return; this.active=false;score+=COIN_VALUE; playHtmlSound('coin', 0.7);}}
        class SpeedBoost extends GameObject{constructor(x,y){super(x,y,40,40,'speedBoost');this.baseY=y;this.angle=Math.random()*Math.PI*2;}update(dT){if(!this.active)return;this.angle+=0.06 * (dT / 16.67);this.y=this.baseY+Math.sin(this.angle)*4;}collect(){if(!this.active) return; this.active=false;if(player)player.activateBoost();}}
        class BackgroundElement{
            constructor(x,y,w,h,sf,c=null,sk=null, yOffset = 0){ // <-- Added yOffset parameter with default value
    this.x=x;
    this.y=y; // Note: this.y isn't really used for drawing vertical position anymore
    this.scrollFactor=sf;
    this.color=c;
    this.spriteKey=sk;
    this.imgRef = this.spriteKey ? assets[this.spriteKey] : null;
    this.yOffset = yOffset; // <-- Store the offset
}
             draw(ctx,cX,cY){
                const i = this.imgRef;
                const hasImage = i && i.complete && i.naturalWidth > 0 && i.naturalHeight > 0;

                if(hasImage){
                    const aspectRatio = i.naturalWidth / i.naturalHeight;
                    const drawHeight = GAME_HEIGHT; // Scale to fit game height
                    const scaledWidth = drawHeight * aspectRatio;

                    if (scaledWidth <= 0) return; // Avoid division by zero or infinite loops

                    const effectiveCamX = cX * this.scrollFactor;
                    let startX = this.x - (effectiveCamX % scaledWidth);
                    if(startX > 0) startX -= scaledWidth;

                    // Draw Y position is 0 relative to canvas, adjusted by vertical parallax
                    // This ensures the image scaled to GAME_HEIGHT covers the screen vertically
                    const drawY = Math.round(this.yOffset - (cY * this.scrollFactor));

                    let currentXpos = startX;
                    while(currentXpos < GAME_WIDTH){
                         ctx.drawImage(i, Math.round(currentXpos), drawY, scaledWidth, drawHeight);
                         currentXpos += scaledWidth;
                    }
                } else if (this.color){
                     // Fallback for original color rect drawing (if needed, less common now)
                     const effectiveCamX=cX*this.scrollFactor;
                     let startX=this.x-(effectiveCamX%this.width);
                     if(startX>0)startX-=this.width;
                     ctx.fillStyle=this.color;
                     let currentXpos=startX;
                     const drawY = Math.round(this.y - cY * this.scrollFactor);
                     while(currentXpos<GAME_WIDTH){
                         ctx.fillRect(Math.round(currentXpos),drawY,this.width,this.height);
                         currentXpos+=this.width;
                     }
                }
             }
        }
        class Platform extends GameObject{constructor(x,y,w,h,c='#8B4513',isG=false){super(x,y,w,h);this.color=c;this.isGround=isG;}draw(ctx,cX,cY){if(!this.active)return;const dX=Math.round(this.x-cX);const dY=Math.round(this.y-cY);if(dX+this.width<0||dX>GAME_WIDTH||dY+this.height<0||dY>GAME_HEIGHT+GROUND_THICKNESS)return;ctx.fillStyle=this.color;ctx.fillRect(dX,dY,this.width,this.height);if(this.isGround){ctx.fillStyle='#A0522D';ctx.fillRect(dX,dY,this.width,5);}}}
        class Particle extends GameObject { constructor(x, y, vx, vy, size, color, lifespan, gravity = PARTICLE_GRAVITY) { super(x - size / 2, y - size / 2, size, size); this.vx = vx; this.vy = vy; this.lifespan = lifespan; this.life = lifespan; this.color = color; this.gravity = gravity; } update(dT) { if (!this.active) return; this.life -= dT; if (this.life <= 0) { this.active = false; return; } this.vy += this.gravity * (dT / 16.67); this.x += this.vx * (dT / 16.67); this.y += this.vy * (dT / 16.67); } draw(ctx, cX, cY) { if (!this.active) return; const dX = Math.round(this.x - cX); const dY = Math.round(this.y - cY); ctx.globalAlpha = Math.max(0, this.life / this.lifespan); ctx.fillStyle = this.color; ctx.fillRect(dX, dY, this.width, this.height); ctx.globalAlpha = 1.0; } }
        function spawnParticles(x, y, count, color, speedRange, lifespan, gravity = PARTICLE_GRAVITY) { for (let i = 0; i < count; i++) { const angle = Math.random() * Math.PI * 2; const speed = Math.random() * speedRange.max + speedRange.min; const vx = Math.cos(angle) * speed; const vy = Math.sin(angle) * speed; const size = Math.random() * 3 + 2; particles.push(new Particle(x, y, vx, vy, size, color, lifespan, gravity)); } }
        function spawnDustParticles(x, y, count = 5) { spawnParticles(x, y, count, '#bca980', {min: 0.5, max: 1.5}, 400 + Math.random() * 200, 0.05); }
        function spawnHitParticles(x, y, count = 8) { spawnParticles(x, y, count, '#FFA500', {min: 1, max: 3}, 300 + Math.random() * 150); }
        function spawnPlayerDeathParticles(x, y, count = 30) { for(let i=0; i<count; i++) { const color = Math.random() < 0.6 ? '#ff4d4d' : (Math.random() < 0.5 ? '#FFA500' : '#f0e68c'); spawnParticles(x, y, 1, color, {min: 2, max: 6}, 600 + Math.random() * 400); } }

        function startGame() {
            handleFirstInteraction(); if (loadError || !gameReady) return;
            if (gameOverMessageTimeoutId) { clearTimeout(gameOverMessageTimeoutId); gameOverMessageTimeoutId = null; }
            resetGame(); if (!player) { showMessage("Error starting game. Please refresh.", true); return; }
            gameState = 'playing'; hideMessage(); playHtmlSound('start'); loopHtmlSound('bgm', 0.4); lastTimestamp = performance.now();
        }

        function handleOverlayInput(e) { e.preventDefault(); e.stopPropagation(); handleFirstInteraction(); if (gameState === 'ready' || gameState === 'gameOver') { startGame(); } }
        function handleKeyDown(e) { handleFirstInteraction(); if (gameState === 'ready' || gameState === 'gameOver') { const gameplayKeys = ['ArrowLeft', 'a', 'ArrowRight', 'd', 'ArrowUp', 'w', ' ', 'f', 'Control', 'p', 'Escape']; startGame(); if (gameplayKeys.includes(e.key)) e.preventDefault(); return; } if (e.key === 'p' || e.key === 'Escape') { if (gameState === 'playing') { gameState = 'paused'; stopHtmlSound('bgm'); showMessage('Paused', false, true); } else if (gameState === 'paused') { gameState = 'playing'; lastTimestamp = performance.now(); loopHtmlSound('bgm', 0.4); hideMessage(); } e.preventDefault(); return; } if (gameState !== 'playing') return; switch (e.key) { case 'ArrowLeft': case 'a': keys.left = true; break; case 'ArrowRight': case 'd': keys.right = true; break; case 'ArrowUp': case 'w': case ' ': keys.up = true; break; case 'f': case 'Control': keys.shoot = true; break; } }
        function handleKeyUp(e) { if (gameState !== 'playing' && gameState !== 'paused') return; switch (e.key) { case 'ArrowLeft': case 'a': keys.left = false; break; case 'ArrowRight': case 'd': keys.right = false; break; case 'f': case 'Control': keys.shoot = false; break; } }
        function handleTouchInput(e) { handleFirstInteraction(); if (gameState === 'ready' || gameState === 'gameOver' || gameState !== 'playing') return; e.preventDefault(); let ct = { l: 0, r: 0, u: 0, s: 0 }; const rect = gameContainer.getBoundingClientRect(); const scaleX = rect.width / GAME_WIDTH; const scaleY = rect.height / GAME_HEIGHT; keys.left = false; keys.right = false; keys.up = false; keys.shoot = false; for (let i = 0; i < e.touches.length; i++) { const touch = e.touches[i]; const touchX = (touch.clientX - rect.left) / scaleX; const touchY = (touch.clientY - rect.top) / scaleY; const deadZoneX = GAME_WIDTH * 0.1; const jumpShootBoundaryY = GAME_HEIGHT * 0.4; const leftBoundaryX = GAME_WIDTH * 0.5 - deadZoneX; const rightBoundaryX = GAME_WIDTH * 0.5 + deadZoneX; if (touchY < jumpShootBoundaryY) { if (touchX < GAME_WIDTH / 2) ct.s = 1; else ct.u = 1; } else { if (touchX < leftBoundaryX) ct.l = 1; else if (touchX > rightBoundaryX) ct.r = 1; } } keys.left = !!ct.l; keys.right = !!ct.r; keys.up = !!ct.u; keys.shoot = !!ct.s; if (e.type === 'touchend' || e.type === 'touchcancel') { if (e.touches.length === 0) { keys.left = false; keys.right = false; keys.up = false; keys.shoot = false; } } }

        function toggleFullScreen() { try{if(!document.fullscreenElement&&!document.mozFullScreenElement&&!document.webkitFullscreenElement&&!document.msFullscreenElement){if(gameContainer.requestFullscreen)gameContainer.requestFullscreen();else if(gameContainer.msRequestFullscreen)gameContainer.msRequestFullscreen();else if(gameContainer.mozRequestFullScreen)gameContainer.mozRequestFullScreen();else if(gameContainer.webkitRequestFullscreen)gameContainer.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);}else{if(document.exitFullscreen)document.exitFullscreen();else if(document.msExitFullscreen)document.msExitFullscreen();else if(document.mozCancelFullScreen)document.mozCancelFullScreen();else if(document.webkitExitFullscreen)document.webkitExitFullscreen();}}catch(err){} }
        function resizeGame() { try{const ww=window.innerWidth;const wh=window.innerHeight;const gar=GAME_WIDTH/GAME_HEIGHT;const war=ww/wh;let nw,nh;if(war>gar){nh=wh;nw=nh*gar;}else{nw=ww;nh=nw/gar;}gameContainer.style.width=`${nw}px`;gameContainer.style.height=`${nh}px`;}catch(err){} }

        function generateWorld() { if(!player)return;let generationEdge=cameraX+GENERATION_DISTANCE;while(lastPlatformX<generationEdge){const gap=MIN_GAP+Math.random()*(MAX_GAP-MIN_GAP);const nextX=lastPlatformX+gap;let platformY,platformWidth,platformHeight,platformColor;let isGroundPlatform=Math.random()<GROUND_PROBABILITY;let previousPlatformY=GROUND_Y;let previousPlatformEndX=lastPlatformX;if(platforms.length>0){const prevPlat=platforms[platforms.length-1];previousPlatformY=prevPlat.y;previousPlatformEndX=prevPlat.x+prevPlat.width;} if(isGroundPlatform){platformWidth=MIN_GROUND_WIDTH+Math.random()*(MAX_GROUND_WIDTH-MIN_GROUND_WIDTH);platformY=GROUND_Y;platformHeight=GROUND_THICKNESS;platformColor='#654321';}else{platformWidth=MIN_FLOAT_WIDTH+Math.random()*(MAX_FLOAT_WIDTH-MIN_FLOAT_WIDTH);platformHeight=PLATFORM_THICKNESS;platformColor='#8B4513';let yVariance=MAX_Y_DELTA_UP*1.8;let targetY=previousPlatformY+(Math.random()*yVariance-yVariance*0.6);platformY=Math.max(MIN_FLOAT_Y,Math.min(targetY,MAX_FLOAT_Y));let yDelta=platformY-previousPlatformY;if(yDelta<-MAX_Y_DELTA_UP)platformY=previousPlatformY-MAX_Y_DELTA_UP;const actualGap=nextX-previousPlatformEndX;if(actualGap>MAX_GAP*0.8&&yDelta<-MAX_Y_DELTA_UP*0.5)platformY=previousPlatformY-MAX_Y_DELTA_UP*0.5;} platformY=Math.round(platformY); const newPlatform=new Platform(nextX,platformY,platformWidth,platformHeight,platformColor,isGroundPlatform);platforms.push(newPlatform);lastPlatformX=nextX+platformWidth; let didSpawnEnemy=false;if(platformWidth>MIN_PLATFORM_WIDTH_FOR_ENEMY&&lastPlatformX>lastEnemySpawnX+MIN_ENEMY_SPACING){let enemyRoll=Math.random();let spawnX = nextX + platformWidth * 0.1 + Math.random() * platformWidth * 0.8; if (!isGroundPlatform && enemyRoll < GOBLIN_SPAWN_CHANCE) { goblins.push(new Goblin(spawnX - 22, platformY - 57, Math.max(20, platformWidth * 0.6))); didSpawnEnemy = true; } else if (isGroundPlatform && enemyRoll < GOBLIN_SPAWN_CHANCE + ROOK_SPAWN_CHANCE) { rooks.push(new Rook(spawnX - 25, platformY - 72)); didSpawnEnemy = true; } else if (!isGroundPlatform && enemyRoll < GOBLIN_SPAWN_CHANCE + ROOK_SPAWN_CHANCE + BISHOP_SPAWN_CHANCE) { bishops.push(new Bishop(spawnX - 27, platformY - 77)); didSpawnEnemy = true; } if(didSpawnEnemy)lastEnemySpawnX=nextX;} if(platformWidth>50&&Math.random()<COIN_SPAWN_CHANCE){const numCoins=1+Math.floor(Math.random()*(platformWidth/70));const coinSize=25;const coinSpacing=5;let startCoinX=nextX+platformWidth*0.15+Math.random()*platformWidth*0.4;const coinY=platformY-coinSize-10;for(let i=0;i<numCoins;i++){let potentialCoinX=startCoinX+i*(coinSize+coinSpacing);if(potentialCoinX+coinSize<nextX+platformWidth-platformWidth*0.1)coins.push(new Coin(potentialCoinX,coinY));else break;}} if(!isGroundPlatform&&platformWidth>60&&Math.random()<POWERUP_SPAWN_CHANCE){powerUps.push(new SpeedBoost(nextX+platformWidth*0.5-20,platformY-45));}} }
        function cleanupObjects() { const removalEdge = cameraX - OFFSCREEN_BUFFER*1.5; platforms=platforms.filter(o=>o.x+o.width>removalEdge); goblins=goblins.filter(o=>o.active&&(o.x+o.width)>removalEdge); rooks=rooks.filter(o=>o.active&&o.x+o.width>removalEdge); bishops=bishops.filter(o=>o.active&&o.x+o.width>removalEdge); fireballs=fireballs.filter(o=>o.active); magicBolts=magicBolts.filter(o=>o.active); coins=coins.filter(o=>o.active&&o.x+o.width>removalEdge); powerUps=powerUps.filter(o=>o.active&&o.x+o.width>removalEdge); particles = particles.filter(p => p.active); }

        function resetGame() {
            stopHtmlSound('bgm');
            platforms=[]; goblins=[]; rooks=[]; bishops=[]; fireballs=[]; magicBolts=[]; coins=[]; powerUps=[]; backgroundElements=[]; particles=[];
            score=0; distanceScore=0; cameraX=0; cameraY=0; lastPlatformX=0; lastEnemySpawnX=-MIN_ENEMY_SPACING;
            player=new Player(100,GROUND_Y-100); player.active=true; player.health=PLAYER_MAX_HEALTH; player.isInvulnerable=false; player.isBoosted=false;
            lastDisplayedScore = -1; lastDisplayedHealth = -1; updateHealthUI(player.health); boostDisplay.style.display='none';
            const startPlatform=new Platform(-50,GROUND_Y,GAME_WIDTH*0.6,GROUND_THICKNESS,'#654321',true); platforms.push(startPlatform); lastPlatformX=startPlatform.x+startPlatform.width;
            backgroundElements = [];
             backgroundElements.push(new BackgroundElement(0, 0, 0, 0, 0.0, null, 'bgSky', 0));
             backgroundElements.push(new BackgroundElement(0, 0, 0, 0, 0.15, null, 'bgHills', 100));
             backgroundElements.push(new BackgroundElement(0, 0, 0, 0, 0.4, null, 'bgGround', 220));
            generateWorld(); keys={left:false,right:false,up:false,shoot:false};
            if (gameOverMessageTimeoutId) { clearTimeout(gameOverMessageTimeoutId); gameOverMessageTimeoutId = null; }
         }

        function gameLoop(timestamp) {
             if (loadError && !gameReady) return;
             if (!lastTimestamp) lastTimestamp = timestamp; let deltaTime = timestamp - lastTimestamp; lastTimestamp = timestamp;
             if (deltaTime > 50) deltaTime = 16.67; if (deltaTime <= 0) deltaTime = 1;
             if (gameState === 'playing') update(deltaTime);
             render(); requestAnimationFrame(gameLoop);
         }

        function update(deltaTime) {
            if (!player) return;
            if (!player.active) { if (gameState === 'playing' && gameState !== 'gameOver') player.die(); return; }
            player.update(deltaTime, platforms); if (!player.active) return;
            let i;
            for (i = 0; i < goblins.length; i++) goblins[i].update(deltaTime, platforms);
            for (i = 0; i < rooks.length; i++) rooks[i].update(deltaTime, platforms);
            for (i = 0; i < bishops.length; i++) bishops[i].update(deltaTime, platforms);
            for (i = 0; i < fireballs.length; i++) fireballs[i].update(deltaTime);
            for (i = 0; i < magicBolts.length; i++) magicBolts[i].update(deltaTime);
            for (i = 0; i < coins.length; i++) coins[i].update(deltaTime);
            for (i = 0; i < powerUps.length; i++) powerUps[i].update(deltaTime);
            for (i = 0; i < particles.length; i++) particles[i].update(deltaTime);

            const playerScreenTargetX = GAME_WIDTH * CAMERA_PLAYER_SCREEN_X_RATIO;
            const targetCameraX = player.x - playerScreenTargetX;
            cameraX += (targetCameraX - cameraX) * CAMERA_SMOOTH_FACTOR; cameraX = Math.max(0, cameraX);

            for (let fbIdx = 0; fbIdx < fireballs.length; fbIdx++) {
                const fb = fireballs[fbIdx]; if (!fb.active) continue; let hit = false;
                for (let gIdx = 0; gIdx < goblins.length; gIdx++) { const g = goblins[gIdx]; if (!hit && g.active && fb.collidesWith(g)) { fb.active = false; g.hitByFireball(); hit = true; break; } } if (hit) continue;
                for (let rIdx = 0; rIdx < rooks.length; rIdx++) { const r = rooks[rIdx]; if (!hit && r.active && fb.collidesWith(r)) { fb.active = false; r.hitByFireball(); hit = true; break; } } if (hit) continue;
                for (let bIdx = 0; bIdx < bishops.length; bIdx++) { const b = bishops[bIdx]; if (!hit && b.active && fb.collidesWith(b)) { fb.active = false; b.hitByFireball(); hit = true; break; } }
            }
            for (let mbIdx = 0; mbIdx < magicBolts.length; mbIdx++) { const mb = magicBolts[mbIdx]; if (mb.active && player.active && !player.isInvulnerable && mb.collidesWith(player)) { mb.active = false; player.takeDamage(1); if (!player.active) return; } }
             if (player.active && !player.isInvulnerable) {
                 let tookDamage = false;
                 for (let gIdx = 0; gIdx < goblins.length; gIdx++) { const g = goblins[gIdx]; if (!tookDamage && g.active && player.collidesWith(g)) { player.takeDamage(1); tookDamage = true; if (!player.active) return; break; } }
                 if (tookDamage) return;
                 for (let rIdx = 0; rIdx < rooks.length; rIdx++) { const r = rooks[rIdx]; if (!tookDamage && r.active && player.collidesWith(r)) { player.takeDamage(1); tookDamage = true; if (!player.active) return; break; } }
             }
             if (player.active) {
                 for (let cIdx = 0; cIdx < coins.length; cIdx++) { const c = coins[cIdx]; if (c.active && player.collidesWith(c)) c.collect(); }
                 for (let pIdx = 0; pIdx < powerUps.length; pIdx++) { const p = powerUps[pIdx]; if (p.active && player.collidesWith(p)) p.collect(); }
             }
            if (player.active) { distanceScore = Math.floor(player.x / 10); }
            generateWorld(); cleanupObjects();
        }

        function updateScoreUI() {
            const totalScore = score + distanceScore; if (totalScore !== lastDisplayedScore) { scoreDisplay.textContent = `Score: ${totalScore}`; lastDisplayedScore = totalScore; }
        }
        function updateHealthUI(currentHealth) {
             if(currentHealth !== lastDisplayedHealth){ let h=''; for(let i=0;i<PLAYER_MAX_HEALTH;i++) h+=(i<currentHealth)?'<span>♥</span>':'<span style="opacity: 0.5;">♡</span>'; healthDisplay.innerHTML=`Health: ${h}`; lastDisplayedHealth = currentHealth; }
        }

        function render() {
             ctx.fillStyle = '#5c94fc'; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
             const camX = Math.round(cameraX); const camY = Math.round(cameraY); let i;
             for (i = 0; i < backgroundElements.length; i++) backgroundElements[i].draw(ctx, camX, camY);
             for (i = 0; i < platforms.length; i++) platforms[i].draw(ctx, camX, camY);
             for (i = 0; i < coins.length; i++) coins[i].draw(ctx, camX, camY);
             for (i = 0; i < powerUps.length; i++) powerUps[i].draw(ctx, camX, camY);
             for (i = 0; i < goblins.length; i++) goblins[i].draw(ctx, camX, camY);
             for (i = 0; i < rooks.length; i++) rooks[i].draw(ctx, camX, camY);
             for (i = 0; i < bishops.length; i++) bishops[i].draw(ctx, camX, camY);
             for (i = 0; i < fireballs.length; i++) fireballs[i].draw(ctx, camX, camY);
             for (i = 0; i < magicBolts.length; i++) magicBolts[i].draw(ctx, camX, camY);
             for (i = 0; i < particles.length; i++) particles[i].draw(ctx, camX, camY);
             if (player && player.active) player.draw(ctx, camX, camY);
             if (gameState === 'playing' || gameState === 'gameOver' || gameState === 'paused') updateScoreUI();
         }

        function initialize() {
             loadHighScore();
             document.body.addEventListener('click', handleFirstInteraction, { once: true });
             document.body.addEventListener('keydown', handleFirstInteraction, { once: true });
             document.body.addEventListener('touchstart', handleFirstInteraction, { passive: true, once: true });
             try {
                 window.addEventListener('keydown', handleKeyDown); window.addEventListener('keyup', handleKeyUp);
                 canvas.addEventListener('touchstart', handleTouchInput, { passive: false }); canvas.addEventListener('touchmove', handleTouchInput, { passive: false });
                 canvas.addEventListener('touchend', handleTouchInput, { passive: false }); canvas.addEventListener('touchcancel', handleTouchInput, { passive: false });
                 messageOverlay.addEventListener('click', handleOverlayInput); messageOverlay.addEventListener('touchstart', handleOverlayInput, { passive: false });
                 fullscreenBtn.addEventListener('click', toggleFullScreen); window.addEventListener('resize', resizeGame);
                 resizeGame(); loadAssets(); showMessage("Loading Assets..."); lastTimestamp = 0; requestAnimationFrame(gameLoop);
             } catch (err) { console.error("Error during initialization:", err); showMessage("Critical error during startup. Please refresh.", true); loadError = true; }
         }

        initialize();

    </script>

</body>
</html>

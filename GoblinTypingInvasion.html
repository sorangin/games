<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Typing Knight: Apex - Rewritten</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root{--font-main:'Roboto', sans-serif;--font-title:'MedievalSharp', cursive;--color-bg-deep:#1a1f1a;--color-bg-mid:#2a3a2a;--color-bg-near:#5c7e5c;--color-ui-bg:rgba(42, 30, 18, 0.92);--color-ui-border:#b8860b;--color-ui-accent:#daa520;--color-text-light:#f5e9d3;--color-text-dark:#3a2a1a;--color-health:#ef4444;--color-freeze:#3b82f6;--color-bomb:#f97316;--color-heal:#22c55e;--color-target:#facc15;--color-correct:#4ade80;--color-streak:#f472b6;--color-letter-highlight:#4ade80; --color-arrow-letter: #ffebcd; --color-hp-bar-bg: #5a1e1e; --color-hp-bar-fill: var(--color-health);--color-enemy-warning: rgba(255, 50, 50, 0.8); --screen-transition:0.6s cubic-bezier(0.68, -0.55, 0.27, 1.55);--z-bg:-10;--z-game:1;--z-enemies:5;--z-arrows:7;--z-knight:10;--z-words:15; --z-hp-bar: 16; --z-particles:20;--z-powerups:25;--z-ui:50;--z-message:100;--z-overlay:200;--z-pause-menu:250;--z-screen:300}
        *{box-sizing:border-box;margin:0;padding:0;user-select:none;-webkit-user-select:none;outline:none;-webkit-tap-highlight-color:transparent;-webkit-touch-callout: none;}
        html,body{height:100dvh; overflow:hidden;background-color:var(--color-bg-deep);font-family:var(--font-main);color:var(--color-text-light)}
        body{display:flex;justify-content:center;align-items:center}
        #app-container{position:relative;width:100%;height:100%;max-width:1200px;max-height:800px;background:var(--color-ui-bg);border:12px solid transparent;border-image:url('data:image/svg+xml;utf8,<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="g" x1="0" x2="0" y1="0" y2="1"><stop offset="0%" stop-color="%23daa520"/><stop offset="100%" stop-color="%236b4423"/></linearGradient></defs><rect fill="url(%23g)" width="100" height="100"/></svg>') 12 stretch;box-shadow:0 0 40px rgba(0, 0, 0, 0.8);overflow:hidden;display:flex;flex-direction:column}
        .screen-shake { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-3px, 0, 0); } 40%, 60% { transform: translate3d(3px, 0, 0); } }

        .screen{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;justify-content:center;align-items:center;padding:25px;opacity:0;visibility:hidden;z-index:var(--z-screen);transition:opacity var(--screen-transition), visibility 0s linear var(--screen-transition);background:rgba(0, 0, 0, 0.5)}
        .screen.active{opacity:1;visibility:visible;transition-delay:0s}
        #main-menu,#game-over-screen{background:radial-gradient(circle, var(--color-bg-near) 0%, var(--color-bg-mid) 70%, var(--color-bg-deep) 100%)}
        #game-screen{background:none;padding:0;z-index:var(--z-game);display:flex;flex-direction:column}
        #main-menu h1,#game-over-screen h2,#pause-menu h2{font-family:var(--font-title);font-size:clamp(2.8em, 9vw, 5.5em);color:var(--color-ui-accent);text-shadow:4px 4px 8px rgba(0, 0, 0, 0.9);margin-bottom:40px;text-align:center;line-height:1.1}
        .menu-button,.overlay-button{font-family:var(--font-title);font-size:clamp(1.4em, 3.8vw, 2em);padding:12px 25px;margin:10px;min-width:200px;text-align:center;background-color:var(--color-ui-border);color:var(--color-text-light);border:4px solid var(--color-ui-accent);border-radius:8px;cursor:pointer;text-shadow:2px 2px 3px var(--color-text-dark);transition:all 0.2s ease;box-shadow:0 5px 10px rgba(0,0,0,0.5)}
        .menu-button:hover,.overlay-button:hover{background-color:var(--color-ui-accent);border-color:var(--color-text-light);transform:translateY(-3px) scale(1.03);box-shadow:0 8px 15px rgba(0,0,0,0.6)}
        .menu-button:active,.overlay-button:active{transform:translateY(1px) scale(1);box-shadow:0 3px 6px rgba(0,0,0,0.5)}
        .menu-button:disabled{background-color:#555;border-color:#777;color:#aaa;cursor:not-allowed;opacity:0.6;transform:none;box-shadow:none}
        #high-score-display{margin-top:20px;font-size:clamp(1em, 2.5vw, 1.2em); color:var(--color-text-light); text-shadow:1px 1px 2px #000;}
        #high-score-display span { color: var(--color-ui-accent); font-weight: bold; }
        #loading-indicator{position:absolute;bottom:20px;font-size:clamp(1em, 2.5vw, 1.2em);color:var(--color-ui-accent);background:rgba(0,0,0,0.5);padding:5px 10px;border-radius:5px}
        #game-over-screen #final-stats{font-size:clamp(1em, 2.4vw, 1.4em);margin-bottom:30px;line-height:1.9;color:var(--color-text-light);background:rgba(0,0,0,0.3);padding:15px;border-radius:8px;border:1px solid var(--color-ui-border);min-width:280px;text-align:left}
        #game-over-screen #final-stats span{font-weight:bold;color:var(--color-ui-accent);margin-left:8px}

        #ui-bar{padding:clamp(5px, 1.5vh, 8px) clamp(10px, 3vw, 15px);background-color:var(--color-ui-bg);border-bottom:5px solid var(--color-ui-border);display:flex;justify-content:space-between;align-items:center;flex-shrink:0;box-shadow:0 5px 12px rgba(0,0,0,0.4);z-index:var(--z-ui);position:relative;min-height:50px}
        #stats-left,#stats-right{display:flex;align-items:center; gap: clamp(10px, 3vw, 30px); margin-left: 10px; margin-right: clamp(10px, 4vw, 30px); font-size:clamp(0.85em, 2vw, 1.15em);font-weight:bold}
        #stats-right { gap: clamp(10px, 3vw, 30px); margin-right: clamp(25px, 6vw, 50px); }
        #health-display,#score-display,#wave-display,#streak-display{display:flex;align-items:center;gap:clamp(5px, 1.5vw, 8px)}
        .heart{display: inline-block; width:clamp(16px, 3vw, 20px);height:clamp(16px, 3vw, 20px);background:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23ef4444"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>') center/contain no-repeat;transition:opacity 0.3s ease; margin-left: 4px; }
        .heart.lost{opacity:0.3}
        .score-icon{width:clamp(18px, 3.5vw, 22px);height:clamp(18px, 3.5vw, 22px);background:url('sprites/coin.png') center/contain no-repeat}
        #streak-value{color:var(--color-text-light);font-size:1.1em;transition:color 0.2s, transform 0.2s; display: inline-block;}
        #streak-value.pulse { animation: pulseAnim 0.4s ease-out; }
        @keyframes pulseAnim { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } }

        #input-display-area{padding:clamp(8px, 2vh, 12px) 0;text-align:center;background-color:rgba(0,0,0,0.3);flex-shrink:0;z-index:var(--z-ui);min-height:45px; cursor: text;}
        #current-input-display{font-size:clamp(1.3em, 3.2vw, 1.7em);font-family:var(--font-main);color:var(--color-text-light);background-color:rgba(255, 255, 255, 0.1);padding:clamp(6px, 1.5vh, 8px) 15px;border-radius:5px;display:inline-block;min-width:160px;min-height:1.5em;border:2px solid transparent;transition:border-color 0.2s ease}
        #current-input-display.has-target{border-color:var(--color-target)}
        #current-input-display:empty::after{content:'Start Typing...';color:#aaa;font-style:italic;}
        #mobile-input-hack { position: absolute; top: -9999px; left: -9999px; opacity: 0; pointer-events: none; width: 1px; height: 1px; }

        #game-area{flex-grow:1;position:relative;width:100%;overflow:hidden;z-index:var(--z-game);background:#1a2e1a; cursor: default;}
        .parallax-bg{position:absolute;top:0;left:0;width:100%;height:100%;background-repeat:repeat-x;background-position:0 bottom;will-change:background-position;z-index:var(--z-bg);pointer-events:none}
        .parallax-bg.paused{animation-play-state:paused !important}
        #bg-layer-1{background-image:url('sprites/background_sky.png');background-size:auto 100%;animation:parallax-scroll-slight 180s linear infinite}
        #bg-layer-2{background-image:url('sprites/background_hills.png');background-size:auto 80%;animation:parallax-scroll 90s linear infinite;opacity:1;background-position:0 80%}
        #bg-layer-3{background-image:url('sprites/background_ground.png');background-size:auto 45%;animation:parallax-scroll 45s linear infinite;opacity:1;background-position:0 bottom}
        @keyframes parallax-scroll{0%{background-position-x:0}100%{background-position-x:-2000px}}
        @keyframes parallax-scroll-slight{0%{background-position-x:0}100%{background-position-x:-500px}}

        #knight{position:absolute;left:5%;bottom:45px;width:clamp(75px, 9vw, 110px);height:clamp(90px, 12vh, 140px);background:url("sprites/Knight.png") no-repeat center bottom / contain;z-index:var(--z-knight);filter:drop-shadow(4px 4px 6px rgba(0,0,0,0.7));transition:transform 0.1s ease-out}
        #knight.hit{animation:knightHitFeedback 0.4s ease-in-out}
        @keyframes knightHitFeedback{0%,100%{transform:translateX(0); } 25%{transform:translateX(-6px) rotate(-2deg); } 75%{transform:translateX(4px) rotate(1deg); }}

        .enemy{position:absolute;display:flex;flex-direction:column;align-items:center;width:clamp(55px, 6.5vw, 85px);height:clamp(70px, 8.5vh, 105px);background-size:contain;background-repeat:no-repeat;background-position:center bottom;z-index:var(--z-enemies);filter:drop-shadow(3px 3px 3px rgba(0,0,0,0.5));transition:left 0.1s linear, opacity 0.5s ease-out, transform 0.5s ease-out;opacity:0;transform:translateX(30px) scale(0.8);will-change:left, opacity, transform, filter; animation: enemyWarningPulse 1s infinite paused;}
        .enemy.paused{animation-play-state:paused !important}
        .enemy.warning { animation-play-state: running !important; }
        @keyframes enemyWarningPulse { 0%, 100% { filter: drop-shadow(3px 3px 3px rgba(0,0,0,0.5)) brightness(1); } 50% { filter: drop-shadow(3px 3px 6px var(--color-enemy-warning)) brightness(1.3); } }
        .enemy.boss{width:clamp(90px, 11vw, 140px);height:clamp(110px, 14vh, 170px);z-index:calc(var(--z-enemies) + 1)}
        .enemy.spawned{opacity:1;transform:translateX(0) scale(1)}
        .enemy.hit{animation:enemyHitFeedback 0.2s ease-out forwards}
        @keyframes enemyHitFeedback{0%,100%{transform:scale(1) rotate(0)}50%{transform:scale(1.08) rotate(3deg)}}
        .enemy.dying{opacity:0 !important;transform:scale(0.6) rotate(-20deg) translateY(30px) !important;transition:opacity 0.4s ease-out, transform 0.4s cubic-bezier(0.6, -0.28, 0.735, 0.045);pointer-events:none; animation: none !important;}
        .enemy-word{position:absolute;bottom:calc(105% + 8px); left:50%;transform:translateX(-50%);background-color:rgba(0, 0, 0, 0.85);color:#fff;border:2px solid rgba(255, 255, 255, 0.5);padding:clamp(4px, 1vw, 5px) clamp(8px, 2vw, 10px);border-radius:6px;font-size:clamp(0.85em, 1.9vw, 1.1em);font-weight:bold;white-space:nowrap;text-shadow:1px 1px 2px rgba(0,0,0,0.9);z-index:var(--z-words);pointer-events:none;transition:background-color 0.15s linear, color 0.15s linear, transform 0.2s ease-out, box-shadow 0.2s ease-out, border-color 0.15s ease, opacity 0.2s ease-out}
        .enemy-hp-bar-container { position: absolute; bottom: 103%; left: 50%; transform: translateX(-50%); width: clamp(50px, 6vw, 60px); height: clamp(5px, 1vh, 6px); background-color: var(--color-hp-bar-bg); border: 1px solid rgba(0,0,0,0.5); border-radius: 3px; overflow: hidden; z-index: var(--z-hp-bar); pointer-events: none; box-shadow: 0 1px 2px rgba(0,0,0,0.6); transition: opacity 0.2s ease-out; }
        .enemy-hp-bar-fill { height: 100%; width: 100%; background-color: var(--color-hp-bar-fill); border-radius: 2px; transition: width 0.2s ease-out; }
        .enemy.paused .enemy-hp-bar-container { opacity: 0.7; }
        .enemy-word span { display: inline-block; transition: color 0.1s linear; color: var(--color-text-light); }
        .enemy-word span.typed { color: var(--color-letter-highlight); font-weight: bold; }
        .enemy.paused .enemy-word{opacity:0.7}
        .enemy.boss .enemy-word{font-size:clamp(0.95em, 2.3vw, 1.3em);padding:clamp(5px, 1.2vw, 7px) clamp(10px, 2.5vw, 12px);border-width:3px;}
        .enemy.boss .enemy-hp-bar-container { width: clamp(70px, 8vw, 80px); height: clamp(6px, 1.2vh, 8px); }
        .enemy-word.target { background-color: rgba(0, 0, 0, 0.85); color: var(--color-text-light); border-color: var(--color-target); transform: translateX(-50%) scale(1.15); box-shadow: 0 0 12px var(--color-target); z-index: calc(var(--z-words) + 1); }
        .enemy-word.target span { color: var(--color-text-light); }
        .enemy-word.target span.typed { color: var(--color-letter-highlight); font-weight: bold; }

        #message-display{position:absolute;top:45%;left:50%;transform:translate(-50%, -50%);font-size:clamp(1.6em, 4.5vw, 2.8em);color:var(--color-text-light);background-color:rgba(0, 0, 0, 0.9);padding:25px 40px;border-radius:12px;border:4px solid var(--color-ui-border);text-align:center;z-index:var(--z-message);display:none;width:85%;max-width:600px;white-space:pre-wrap;box-shadow:0 0 25px rgba(0,0,0,0.6);animation:messageFadeIn 0.3s ease-out;pointer-events:none}
        @keyframes messageFadeIn{from{opacity:0;transform:translate(-50%, -40%)}to{opacity:1;transform:translate(-50%, -50%)}}
        #message-display.wave-complete{color:var(--color-ui-accent);font-family:var(--font-title);font-size:clamp(1.8em, 5.5vw, 3.2em)}

        #particle-container{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;overflow:hidden;z-index:var(--z-particles)}
        .particle{position:absolute;width:8px;height:8px;border-radius:50%;background:white;opacity:1;will-change:transform, opacity;animation:particleAnim 0.8s ease-out forwards}
        .particle.sparkle{background:url('sprites/sFireball1.png') center/contain no-repeat;width:15px;height:15px;border-radius:0;background-color:transparent !important}
        .particle.streak{background:var(--color-streak);box-shadow:0 0 5px var(--color-streak)}
        .particle.hit{background:var(--color-correct);box-shadow:0 0 5px var(--color-correct)}
        .particle.death{background:#ffcc00;box-shadow:0 0 6px #ffcc00;width:12px;height:12px}
        .particle.powerup-get{width:20px;height:20px; animation-duration: 1.2s !important; }
        .particle.powerup-bomb{background-color:var(--color-bomb)}
        .particle.powerup-freeze{background-color:var(--color-freeze)}
        .particle.powerup-heal{background-color:var(--color-heal)}
        @keyframes particleAnim{0%{transform:translate(0, 0) scale(1);opacity:1}100%{transform:translate(var(--tx, 0), var(--ty, -80px)) scale(0);opacity:0}}

        .powerup{position:absolute;z-index:var(--z-powerups);width:clamp(45px, 5.5vw, 65px);height:clamp(45px, 5.5vw, 65px);border-radius:50%;border:4px solid white;cursor:pointer;opacity:0;transform:translateY(20px) scale(0.5);background-size:60%;background-repeat:no-repeat;background-position:center;box-shadow:0 0 15px 5px white;animation:powerupAppear 0.5s ease-out forwards, powerupPulse 1.5s infinite ease-in-out 0.5s;will-change:transform, opacity, box-shadow; display: flex; flex-direction: column; align-items: center; justify-content: center;}
        .powerup.paused{animation-play-state:paused !important}
        @keyframes powerupAppear{to{opacity:1;transform:translateY(0) scale(1)}}
        @keyframes powerupPulse{0%,100%{transform:scale(1);box-shadow:0 0 15px 5px var(--shadow-color, white)}50%{transform:scale(1.1);box-shadow:0 0 25px 10px var(--shadow-color, white)}}
        .powerup-word{position:relative; bottom: -115%; background:rgba(0,0,0,0.8);padding:clamp(2px, 0.8vw, 3px) clamp(6px, 1.5vw, 8px);border-radius:4px;font-weight:bold;font-size:clamp(0.8em, 1.8vw, 0.9em);color:white;border:1px solid white;pointer-events:none; white-space: nowrap;}
        .powerup-timer{position:relative; bottom: -120%; font-size: clamp(0.7em, 1.5vw, 0.75em); color: #eee; background: rgba(0,0,0,0.6); padding: 1px 4px; border-radius: 3px; margin-top: 3px; font-weight: normal;}
        .powerup-word span { display: inline-block; transition: color 0.1s linear; color: var(--color-text-light); }
        .powerup-word span.typed { color: var(--color-letter-highlight); font-weight: bold; }
        .powerup.target .powerup-word { border-color: var(--color-target); }
        .powerup.heal{background-color:var(--color-heal);border-color:var(--color-heal);--shadow-color:var(--color-heal);background-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white"><path fill-rule="evenodd" d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25zM12.75 9a.75.75 0 00-1.5 0v2.25H9a.75.75 0 000 1.5h2.25V15a.75.75 0 001.5 0v-2.25H15a.75.75 0 000-1.5h-2.25V9z" clip-rule="evenodd" /></svg>')}
        .powerup.bomb{background-color:var(--color-bomb);border-color:var(--color-bomb);--shadow-color:var(--color-bomb);background-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white"><path d="M11.47 1.72a.75.75 0 011.06 0l3 3a.75.75 0 01-1.06 1.06l-1.72-1.72V7.5h-1.5V4.06L9.53 5.78a.75.75 0 01-1.06-1.06l3-3zM11.25 9.75A5.25 5.25 0 006 15v.954l-1.447.868a.75.75 0 00-.448 1.103 9.05 9.05 0 0011.79 0 .75.75 0 00-.447-1.103L13.5 15.954V15a5.25 5.25 0 00-2.25-4.5V9.75z" /><path fill-rule="evenodd" d="M12.75 11.25a.75.75 0 00-1.5 0v1.856l-.41.247a6.75 6.75 0 00-5.59 6.578v.04c.006.016.012.032.02.047a.75.75 0 00.607.588A7.52 7.52 0 0012 21a7.52 7.52 0 006.623-3.414.75.75 0 00.608-.588c.008-.015.014-.03.02-.047v-.04a6.75 6.75 0 00-5.59-6.578l-.41-.247V11.25zM13.5 15.406l.15.09a5.25 5.25 0 014.33 5.097v.003a.75.75 0 01-.014.145 6.003 6.003 0 01-11.932 0A.75.75 0 016 20.596v-.003a5.25 5.25 0 014.33-5.097l.15-.09v-.001h2.984v.001z" clip-rule="evenodd" /></svg>')}
        .powerup.freeze{background-color:var(--color-freeze);border-color:var(--color-freeze);--shadow-color:var(--color-freeze);background-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white"><path fill-rule="evenodd" d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25zm-2.625 6c-.54 0-1.024.19-1.411.513l-1.36 1.36a.75.75 0 000 1.06l4.879 4.879a.75.75 0 001.06 0l1.36-1.36c.322-.387.513-.871.513-1.411v-2.625a.75.75 0 00-.75-.75h-2.625zm6 3a.75.75 0 00-1.06 0l-1.36 1.36a1.5 1.5 0 00-.513 1.411v2.625a.75.75 0 00.75.75h2.625c.54 0 1.024-.19 1.411-.513l1.36-1.36a.75.75 0 000-1.06l-4.879-4.879zM9.375 9.75a.75.75 0 000 1.5h1.875v1.875a.75.75 0 001.5 0V11.25h1.875a.75.75 0 000-1.5H12.75V9.375a.75.75 0 00-1.5 0v1.875H9.375z" clip-rule="evenodd" /></svg>')}

        .arrow { position: absolute; width: clamp(40px, 5vw, 50px); height: clamp(16px, 2.5vw, 20px); background: url('sprites/arrow.png') no-repeat center center / contain; z-index: var(--z-arrows); pointer-events: none; filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.5)); will-change: transform; transform-origin: center center;}
        .arrow-letter { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: clamp(0.9em, 2.2vw, 1.2em); font-weight: bold; color: var(--color-arrow-letter); background: rgba(0,0,0,0.7); padding: 0 clamp(3px, 1vw, 5px); border-radius: 3px; text-shadow: 1px 1px 1px #000; will-change: transform; }
        .arrow.paused { }
        .arrow.dying { transition: opacity 0.3s ease-out, transform 0.3s ease-out !important; opacity: 0 !important; transform: translate(var(--last-x, 0), var(--last-y, 0)) scale(0.5) rotate(30deg) !important; }
        .arrow.dying .arrow-letter { transform: translate(-50%, -50%) rotate(0deg) !important; }

        #pause-menu{z-index:var(--z-pause-menu);background:rgba(0,0,0,0.85)}
        #pause-menu-button { position: absolute; top: clamp(5px, 1.5vh, 8px); right: clamp(10px, 3vw, 15px); background: rgba(74, 59, 42, 0.7); border: 1px solid var(--color-ui-accent); color: var(--color-ui-accent); font-size: clamp(1.3em, 2.8vw, 2em); width: clamp(35px, 5vw, 40px); height: clamp(35px, 5vw, 40px); line-height: calc(clamp(35px, 5vw, 40px) - 2px); text-align: center; border-radius: 5px; cursor: pointer; z-index: calc(var(--z-ui) + 1); transition: background-color 0.2s; display: none; }
        #pause-menu-button:hover { background: rgba(74, 59, 42, 0.9); }
        #game-screen.playing #pause-menu-button { display: block; }
        .hidden{display:none !important}
    </style>
</head>
<body>
    <div id="app-container">
        <div id="main-menu" class="screen active"><h1>Typing Knight:<br>Apex</h1><div id="high-score-display">High Score: <span>0</span></div><button id="start-button" class="menu-button" disabled>Loading...</button><div id="loading-indicator" class="hidden">Loading Assets...</div></div>
        <div id="game-screen" class="screen"><div id="ui-bar"><div id="stats-left"><div id="health-display" title="Health"><span id="health-hearts"></span></div><div id="score-display" title="Score"><span class="score-icon"></span> <span id="score-value">0</span></div></div><div id="stats-right"><div id="wave-display" title="Wave">Wave: <span id="wave-value">1</span></div><div id="streak-display" title="Kill Streak">Streak: <span id="streak-value">x1</span></div></div><button id="pause-menu-button" title="Pause Game">☰</button></div><div id="input-display-area"><span id="current-input-display"></span></div><div id="game-area"><div id="bg-layer-1" class="parallax-bg"></div><div id="bg-layer-2" class="parallax-bg"></div><div id="bg-layer-3" class="parallax-bg"></div><div id="knight"></div><div id="particle-container"></div></div><div id="message-display" class="hidden"></div></div>
        <div id="game-over-screen" class="screen"><h2>Invasion Ended!</h2><div id="final-stats">Final Score: <span id="final-score">0</span><br>Highest Wave: <span id="final-wave">1</span><br>Highest Streak: <span id="final-streak">x1</span><br>Accuracy: <span id="final-accuracy">-%</span></div><button id="play-again-button" class="menu-button">Play Again</button><button id="main-menu-return-button" class="menu-button">Main Menu</button></div>
        <div id="pause-menu" class="screen"><h2>Paused</h2><button id="resume-button" class="menu-button">Resume</button><button id="pause-fullscreen-button" class="menu-button">Toggle Fullscreen</button><button id="pause-quit-button" class="menu-button">Quit to Menu</button></div>
    </div>
    <div style="display: none;">
        <input type="text" id="mobile-input-hack" autocapitalize="off" autocorrect="off" spellcheck="false" tabindex="-1">
        <audio id="audio-bgm" loop></audio>
        <audio id="audio-sfx-coin"></audio>
        <audio id="audio-sfx-enemy-hit"></audio>
        <audio id="audio-sfx-error"></audio>
        <audio id="audio-sfx-game-over"></audio>
        <audio id="audio-sfx-player-die"></audio>
        <audio id="audio-sfx-player-hurt"></audio>
        <audio id="audio-sfx-powerup-spawn"></audio>
        <audio id="audio-sfx-powerup-get"></audio>
        <audio id="audio-sfx-powerup-bomb"></audio>
        <audio id="audio-sfx-powerup-freeze"></audio>
        <audio id="audio-sfx-powerup-heal"></audio>
        <audio id="audio-sfx-enemy-dead-goblin"></audio>
        <audio id="audio-sfx-enemy-dead-knight"></audio>
        <audio id="audio-sfx-enemy-dead-boss"></audio>
        <audio id="audio-sfx-hit"></audio>
        <audio id="audio-sfx-move"></audio>
        <audio id="audio-sfx-select"></audio>
        <audio id="audio-sfx-shoot"></audio>
        <audio id="audio-sfx-start-beep"></audio>
        <audio id="audio-sfx-success"></audio>
        <audio id="audio-sfx-streak"></audio>
        <audio id="audio-sfx-wave-complete"></audio>
        <audio id="audio-sfx-arrow-hit"></audio>
        <audio id="audio-sfx-arrow-miss"></audio>
        <audio id="audio-sfx-arrow-spawn"></audio>
        <audio id="audio-sfx-type"></audio>
    </div>

    <script>
    (() => {
        const CONFIG = {
            INITIAL_PLAYER_HEALTH: 3,
            GAME_LOOP_INTERVAL: 16,
            KNIGHT_DEFENSE_BUFFER: 20,
            ENEMY_WARNING_DISTANCE: 180,
            POWERUP_CHANCE: 0.18,
            POWERUP_LIFETIME: 7500,
            POWERUP_TYPES: ['HEAL', 'BOMB', 'FREEZE'],
            STREAK_BONUS_THRESHOLD: 5,
            STREAK_MAX_MULTIPLIER: 5,
            BOSS_WAVE_INTERVAL: 5,
            WAVE_COMPLETE_DELAY: 2000,
            WAVE_START_DELAY: 1500,
            PARTICLE_COUNT_HIT: 10,
            PARTICLE_COUNT_DEATH: 18,
            PARTICLE_COUNT_STREAK: 12,
            PARTICLE_COUNT_POWERUP: 25,
            PARTICLE_COUNT_ARROW: 6,
            POWERUP_MIN_Y_PERCENT: 0.2,
            POWERUP_MAX_Y_PERCENT: 0.7,
            ARROW_SPAWN_BASE_CHANCE: 0.07,
            ARROW_SPAWN_WAVE_INCREASE: 0.012,
            ARROW_FLIGHT_DURATION_MIN: 2800,
            ARROW_FLIGHT_DURATION_MAX: 4500,
            ARROW_ARC_HEIGHT_MIN: 70,
            ARROW_ARC_HEIGHT_MAX: 170,
            ARROW_SCORE: 5,
            ENEMY_CONFIG: {
                'Pawn':   { baseHp: 1, baseSpeed: 1.5, score: 10, spritePrefixes: ['bPawn', 'wPawn'], deathSound: 'enemyDeadGoblin' },
                'Goblin': { baseHp: 1, baseSpeed: 1.7, score: 10, spritePrefixes: ['Goblin'], deathSound: 'enemyDeadGoblin' },
                'Knight': { baseHp: 2, baseSpeed: 1.3, score: 20, spritePrefixes: ['bKnight', 'wKnight'], deathSound: 'enemyDeadKnight' },
                'Rook':   { baseHp: 3, baseSpeed: 1.1, score: 25, spritePrefixes: ['bRook', 'wRook'], deathSound: 'enemyDeadKnight' },
                'Bishop': { baseHp: 2, baseSpeed: 1.6, score: 30, spritePrefixes: ['bBishop', 'wBishop'], deathSound: 'enemyDeadKnight' },
                'Queen':  { baseHp: 1, baseSpeed: 1.9, score: 100, spritePrefixes: ['bQueen', 'wQueen'], deathSound: 'enemyDeadBoss', isBoss: true, requiresSentence: true },
                'King':   { baseHp: 1, baseSpeed: 1.2, score: 150, spritePrefixes: ['bKing', 'wKing'], deathSound: 'enemyDeadBoss', isBoss: true, requiresSentence: true }
            },
            WAVE_SCALING: {
                spawnIntervalReduction: 160, minSpawnInterval: 650, baseSpawnInterval: 3300, speedIncrease: 0.065, hpIncreaseFactor: 0.11, baseEnemies: 4, enemiesIncrease: 1.25, wordLengthMinBonus: 0.12, wordLengthMaxBonus: 0.28
            }
        };

        const AUDIO_FILES = { bgm: 'audio/music_WormsTheme.mp3', coin: 'audio/coin.wav', enemyHit: 'audio/enemy_hit.wav', error: 'audio/Error.wav', gameOver: 'audio/GameOver.wav', playerDie: 'audio/player_die.wav', playerHurt: 'audio/player_hurt.wav', powerupSpawn: 'audio/powerup.wav', powerupGet: 'audio/Success.wav', powerupBomb: 'audio/sfxFireballHit.wav', powerupFreeze: 'audio/sfxFireballCast.wav', powerupHeal: 'audio/jump.wav', enemyDeadGoblin: 'audio/sfxGoblinDead.wav', enemyDeadKnight: 'audio/sfxHit.wav', enemyDeadBoss: 'audio/player_die.wav', hit: 'audio/sfxHit.wav', move: 'audio/sfxMove.wav', select: 'audio/sfxSelect.wav', shoot: 'audio/shoot.wav', startBeep: 'audio/start_beep.wav', success: 'audio/Success.wav', streak: 'audio/coin.wav', waveComplete: 'audio/Success.wav', arrowHit: 'audio/hit.wav', arrowMiss: 'audio/player_hurt.wav', arrowSpawn: 'audio/shoot.wav', type: 'audio/type.wav' };

        const WORD_LIST_SOURCE = [ "goblin", "attack", "knight", "sword", "shield", "magic", "danger", "quick", "type", "defend", "wave", "score", "castle", "arrow", "forest", "speed", "ogre", "troll", "dragon", "bash", "charge", "block", "enemy", "power", "haste", "invade", "retreat", "valor", "victory", "defeat", "elf", "dwarf", "orc", "beast", "monster", "human", "undead", "skeleton", "zombie", "ghoul", "imp", "demon", "angel", "wizard", "sorcerer", "witch", "warrior", "rogue", "ranger", "cleric", "paladin", "barbarian", "gnome", "sprite", "fairy", "giant", "cyclops", "minotaur", "griffin", "chimera", "strike", "cast", "heal", "dodge", "parry", "flee", "pursue", "summon", "banish", "enchant", "curse", "explore", "sneak", "ambush", "shoot", "throw", "swing", "slash", "stab", "crush", "guard", "protect", "reinforce", "counter", "advance", "flank", "surround", "conquer", "fortify", "axe", "mace", "spear", "dagger", "bow", "crossbow", "staff", "wand", "armor", "helmet", "gauntlets", "boots", "potion", "scroll", "amulet", "ring", "key", "map", "treasure", "gold", "gem", "crystal", "artifact", "relic", "standard", "banner", "catapult", "ram", "siege", "dungeon", "cave", "mountain", "swamp", "desert", "plains", "village", "city", "tower", "keep", "fortress", "ruins", "temple", "shrine", "abyss", "portal", "realm", "kingdom", "empire", "battlefield", "graveyard", "tavern", "inn", "shop", "strength", "agility", "wisdom", "courage", "fear", "chaos", "order", "light", "dark", "shadow", "fire", "water", "earth", "air", "ice", "lightning", "poison", "holy", "arcane", "divine", "ancient", "mythic", "legendary", "epic", "rage", "fury", "focus", "stealth", "cunning", "loyalty", "betrayal", "honor", "glory", "doom", "fate", "destiny", "quest", "mission", "bounty", "reward", "penalty", "brave", "fierce", "mighty", "hidden", "lost", "sacred", "corrupt", "noble", "savage", "wild", "tame", "free", "bound", "about", "above", "across", "action", "active", "actual", "always", "amount", "animal", "answer", "appear", "around", "author", "aware", "balance", "become", "before", "behind", "better", "between", "beyond", "border", "bring", "build", "button", "cable", "camera", "cancel", "carbon", "center", "change", "circle", "clean", "clear", "close", "coffee", "color", "common", "corner", "could", "cover", "create", "credit", "current", "cycle", "daily", "dance", "decide", "define", "degree", "delete", "depend", "detail", "differ", "direct", "divide", "doctor", "dollar", "double", "dream", "drive", "during", "early", "either", "empty", "enough", "enter", "equal", "error", "event", "every", "exact", "except", "exist", "expect", "explain", "extra", "factor", "family", "father", "field", "figure", "final", "floor", "follow", "force", "format", "forward", "friend", "front", "future", "gather", "general", "group", "guide", "happen", "happy", "heavy", "hello", "house", "however", "image", "impact", "import", "indeed", "index", "inform", "input", "inside", "issue", "itself", "jacket", "joint", "judge", "keyboard", "known", "label", "large", "later", "layer", "learn", "leave", "legal", "level", "listen", "little", "local", "logic", "longer", "lower", "lucky", "lunch", "major", "manage", "manual", "margin", "market", "master", "match", "maybe", "measure", "media", "member", "memory", "mention", "message", "metal", "method", "middle", "might", "minor", "minus", "minute", "mirror", "mobile", "model", "modify", "moment", "money", "month", "morning", "mother", "mouse", "movie", "music", "myself", "native", "nearby", "nearly", "network", "never", "noise", "normal", "north", "notice", "number", "object", "occur", "offer", "often", "online", "only", "open", "option", "order", "other", "output", "outside", "owner", "paint", "paper", "parent", "parse", "party", "pause", "peace", "people", "period", "person", "phase", "phone", "photo", "piece", "place", "plant", "please", "point", "policy", "pretty", "press", "price", "print", "prior", "private", "process", "proof", "proper", "public", "query", "quest", "radio", "raise", "range", "reach", "react", "ready", "really", "reason", "record", "refer", "region", "reject", "relate", "remove", "repeat", "reply", "report", "reset", "result", "return", "right", "round", "route", "sample", "scale", "scene", "scope", "screen", "search", "secure", "select", "sense", "series", "server", "service", "session", "setup", "share", "shift", "short", "should", "simple", "since", "single", "skill", "small", "smart", "smile", "solid", "solve", "sound", "south", "space", "speak", "special", "split", "sport", "stack", "stage", "stand", "start", "state", "static", "status", "still", "stock", "store", "story", "stream", "street", "study", "style", "subject", "sugar", "super", "supply", "support", "surely", "surface", "switch", "symbol", "system", "table", "target", "teach", "team", "thank", "their", "theme", "there", "these", "thick", "thing", "think", "third", "those", "though", "three", "through", "title", "today", "token", "total", "touch", "trace", "track", "trade", "train", "trend", "truck", "truly", "trust", "twice", "under", "union", "unique", "until", "update", "upper", "usual", "valid", "value", "video", "virus", "visit", "visual", "voice", "volume", "watch", "while", "white", "whole", "width", "window", "within", "without", "woman", "world", "worry", "worth", "would", "write", "wrong", "yellow", "yield", "young" ];

        const SENTENCE_LIST_SOURCE = [
            "the king demands your surrender now",
            "you cannot defeat royal power",
            "prepare for your final stand intruder",
            "my reign will last forevermore",
            "this castle is my sacred domain",
            "face the might of the true ruler",
            "your journey ends at my command",
            "swift justice for the defiant knight",
            "the queen sends her regards before doom",
            "victory belongs only to the crown"
        ];

        const ALPHABET = 'abcdefghijklmnopqrstuvwxyz';
        const GAME_STATES = { LOADING: 'loading', MENU: 'menu', STARTING_WAVE: 'startingWave', PLAYING: 'playing', PAUSED: 'paused', WAVE_COMPLETE: 'waveComplete', GAMEOVER: 'gameover' };

        const $ = (selector) => document.querySelector(selector);
        const $$ = (selector) => document.querySelectorAll(selector);
        const clamp = (num, min, max) => Math.min(Math.max(num, min), max);

        class AudioManager {
             constructor(elements) { this.elements = elements; this.musicVolume = 0.3; this.sfxVolume = 0.5; this.isMuted = false; this.assetsLoaded = false; this.isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0; }
             initVolumes() { const savedMusicVol = localStorage.getItem('typingKnight_musicVolume'); const savedSfxVol = localStorage.getItem('typingKnight_sfxVolume'); this.musicVolume = savedMusicVol !== null ? parseFloat(savedMusicVol) : this.musicVolume; this.sfxVolume = savedSfxVol !== null ? parseFloat(savedSfxVol) : this.sfxVolume; if(this.elements.bgm) this.elements.bgm.volume = this.musicVolume; }
             setMusicVolume(volume) { this.musicVolume = Number(volume); if (this.elements.bgm) this.elements.bgm.volume = this.musicVolume; localStorage.setItem('typingKnight_musicVolume', this.musicVolume.toString()); }
             setSfxVolume(volume) { this.sfxVolume = Number(volume); localStorage.setItem('typingKnight_sfxVolume', this.sfxVolume.toString()); }
             _playSound(audioElement, volume, loop = false) { if (!audioElement || !this.assetsLoaded || this.isMuted) return; try { audioElement.volume = volume; audioElement.loop = loop; if (!loop) { audioElement.currentTime = 0; } audioElement.play().catch((e)=>{}); } catch (error) { console.warn("Audio play error:", error); } }
             play(soundName, loop = false) { const element = this.elements[soundName]; if (element) { const volume = (soundName === 'bgm') ? this.musicVolume : this.sfxVolume; this._playSound(element, volume, loop); } else { console.warn(`Audio key not found: ${soundName}`); } }
             stop(soundName) { const element = this.elements[soundName]; if (element) { try { element.pause(); element.currentTime = 0; } catch(e){ console.warn("Audio stop error:", e); } } }
             stopAllSfx() { Object.entries(this.elements).forEach(([key, element]) => { if (key !== 'bgm' && element && !element.loop) { try { element.pause(); element.currentTime = 0; } catch (e) {} } }); }
             setPauseState(isPaused) { Object.values(this.elements).forEach(el => { if(el) { try { if(isPaused && !el.paused) { if (el.loop) el.pause(); else el.pause(); } else if (!isPaused && el.paused && el.loop) { el.play().catch(()=>{}); } } catch(e){} } }); }
             loadAssets() { return new Promise((resolve, reject) => { const assetKeys = Object.keys(AUDIO_FILES); let loadedCount = 0; let errorCount = 0; const totalAssets = assetKeys.length; let timedOut = false; if(totalAssets === 0) { this.assetsLoaded = true; resolve(); return; } const timeoutDuration = 15000; const checkCompletion = () => { if (timedOut) return; if (loadedCount + errorCount === totalAssets) { this.assetsLoaded = true; resolve(); clearTimeout(loadTimeout); } }; const onAssetLoad = (key) => { loadedCount++; checkCompletion(); }; const onAssetError = (key, e) => { console.warn(`Failed to load audio: ${key}`, e); errorCount++; checkCompletion(); }; const loadTimeout = setTimeout(() => { if (!this.assetsLoaded) { timedOut = true; console.warn(`Audio loading timed out after ${timeoutDuration}ms.`); this.assetsLoaded = true; reject(new Error("Audio loading timed out")); } }, timeoutDuration); assetKeys.forEach(key => { const element = this.elements[key]; const src = AUDIO_FILES[key]; if (element && src) { element.src = src; element.load(); element.addEventListener('loadeddata', () => onAssetLoad(key), { once: true }); element.addEventListener('error', (e) => onAssetError(key, e), { once: true }); } else { console.warn(`Audio element or src missing for key: ${key}`); errorCount++; checkCompletion(); } }); }); }
        }

        class ParticleManager {
             constructor(container) { this.container = container; this.isPaused = false; }
             createParticle(x, y, count, type = '', options = {}) { if (!this.container || this.isPaused) return; const { color, baseClass = 'particle', spread = 50, duration = 800, size = 8 } = options; requestAnimationFrame(() => { for (let i = 0; i < count; i++) { if (this.isPaused) break; const particle = document.createElement('div'); particle.className = `${baseClass} ${type}`; particle.style.left = `${x}px`; particle.style.top = `${y}px`; particle.style.width = `${size}px`; particle.style.height = `${size}px`; if (color) particle.style.background = color; const angle = Math.random() * Math.PI * 2; const distance = Math.random() * spread; const tx = Math.cos(angle) * distance; const ty = Math.sin(angle) * distance - (spread * 0.3); particle.style.setProperty('--tx', `${tx}px`); particle.style.setProperty('--ty', `${ty}px`); const finalDuration = (duration + Math.random() * 200); particle.style.animationDuration = `${finalDuration / 1000}s`; if (this.isPaused) { particle.style.animationPlayState = 'paused'; } this.container?.appendChild(particle); setTimeout(() => { particle.remove(); }, finalDuration + 50); } }); }
             emit(type, x, y) { if(!this.container || this.isPaused) return; const defaults = { size: 10, duration: 800, spread: 60 }; switch(type) { case 'hit': this.createParticle(x, y, CONFIG.PARTICLE_COUNT_HIT, 'hit sparkle', { ...defaults, size: 12, spread: 70 }); break; case 'death': this.createParticle(x, y, CONFIG.PARTICLE_COUNT_DEATH, 'death sparkle', { ...defaults, size: 16, spread: 90, duration: 1100 }); break; case 'streak': this.createParticle(x, y, CONFIG.PARTICLE_COUNT_STREAK, 'streak', { ...defaults, size: 11, spread: 80, duration: 950 }); break; case 'powerup-heal': this.createParticle(x, y, CONFIG.PARTICLE_COUNT_POWERUP, 'powerup-get powerup-heal', { ...defaults, size: 20, spread: 100, duration: 1300 }); break; case 'powerup-bomb': this.createParticle(x, y, CONFIG.PARTICLE_COUNT_POWERUP, 'powerup-get powerup-bomb', { ...defaults, size: 20, spread: 130, duration: 1100 }); break; case 'powerup-freeze': this.createParticle(x, y, CONFIG.PARTICLE_COUNT_POWERUP, 'powerup-get powerup-freeze', { ...defaults, size: 20, spread: 110, duration: 1500 }); break; case 'arrow-hit': this.createParticle(x, y, CONFIG.PARTICLE_COUNT_ARROW, 'hit', { ...defaults, size: 10, spread: 45, duration: 600 }); break; case 'type': break; } }
             setPauseState(isPaused) { this.isPaused = isPaused; this.container?.querySelectorAll('.particle').forEach(p => p.style.animationPlayState = isPaused ? 'paused' : 'running'); }
             clear() { if(this.container) this.container.innerHTML = ''; }
        }

        class UIManager {
             constructor(game, dom) { this.game = game; this.dom = dom; this.streakPulseTimeout = null;}
             showScreen(screenId) { Object.values(this.dom.screens).forEach(screen => screen?.classList.remove('active')); this.dom.screens[screenId]?.classList.add('active'); this.dom.game.screen?.classList.toggle('playing', screenId === 'game'); }
             updateGameUI(player, wave) {
                 if(!this.dom.game.scoreValue || !this.dom.game.waveValue || !this.dom.game.streakValue || !this.dom.game.healthHearts) return;
                 this.dom.game.scoreValue.textContent = player.score;
                 this.dom.game.waveValue.textContent = wave;
                 const oldStreak = parseInt(this.dom.game.streakValue.textContent.replace('x','') || '1');
                 const newStreak = player.streakMultiplier;
                 this.dom.game.streakValue.textContent = `x${newStreak}`;
                 if (newStreak > oldStreak && newStreak > 1) {
                     this.dom.game.streakValue.classList.add('pulse');
                     if (this.streakPulseTimeout) clearTimeout(this.streakPulseTimeout);
                     this.streakPulseTimeout = setTimeout(() => this.dom.game.streakValue?.classList.remove('pulse'), 400);
                 }
                 this.dom.game.streakValue.style.color = newStreak > 1 ? 'var(--color-streak)' : 'var(--color-text-light)';
                 this.dom.game.healthHearts.innerHTML = '';
                 for (let i = 0; i < player.maxHealth; i++) { const heart = document.createElement('span'); heart.className = `heart ${i >= player.health ? 'lost' : ''}`; this.dom.game.healthHearts.appendChild(heart); }
             }
             updateGameOverUI(player, wave) { if(!this.dom.gameOver.finalScore || !this.dom.gameOver.finalWave || !this.dom.gameOver.finalStreak || !this.dom.gameOver.finalAccuracy) return; this.dom.gameOver.finalScore.textContent = player.score; this.dom.gameOver.finalWave.textContent = wave; this.dom.gameOver.finalStreak.textContent = `x${player.maxStreakMultiplier}`; const accuracy = player.totalTyped === 0 ? 0 : clamp(((player.correctTyped / player.totalTyped) * 100), 0, 100); this.dom.gameOver.finalAccuracy.textContent = `${accuracy.toFixed(1)}%`; }
             showMessage(text, duration = 3000, type = '', callback = null) {
                 if (!this.dom.game.messageDisplay) return;
                 this.dom.game.messageDisplay.innerHTML = text.replace(/\n/g, '<br>');
                 this.dom.game.messageDisplay.className = 'message-display';
                 if (type) this.dom.game.messageDisplay.classList.add(type);
                 this.dom.game.messageDisplay.classList.remove('hidden');
                 if (this.dom.game.messageDisplay.hideTimeout) clearTimeout(this.dom.game.messageDisplay.hideTimeout);
                 if (duration > 0) { this.dom.game.messageDisplay.hideTimeout = setTimeout(() => { this.hideMessage(); if(callback) callback(); }, duration); }
                 else { this.dom.game.messageDisplay.hideTimeout = null; }
             }
             hideMessage() { if (!this.dom.game.messageDisplay) return; this.dom.game.messageDisplay.classList.add('hidden'); if (this.dom.game.messageDisplay.hideTimeout) { clearTimeout(this.dom.game.messageDisplay.hideTimeout); this.dom.game.messageDisplay.hideTimeout = null; } }
             setLoading(isLoading, message = "Loading Assets...") {
                 if(!this.dom.loadingIndicator || !this.dom.buttons.start) return;
                 this.dom.loadingIndicator.textContent = message;
                 this.dom.loadingIndicator.classList.toggle('hidden', !isLoading);
                 this.dom.buttons.start.disabled = isLoading;
                 this.dom.buttons.start.textContent = isLoading ? "Loading..." : "Start Invasion";
             }
             updateHighScore(score) { if(this.dom.highScoreDisplay) { const scoreSpan = this.dom.highScoreDisplay.querySelector('span'); if(scoreSpan) scoreSpan.textContent = score; } }
             updateInputDisplay(text, hasTarget) { if(this.dom.game.inputDisplay) { this.dom.game.inputDisplay.textContent = text; this.dom.game.inputDisplay.classList.toggle('has-target', hasTarget); } }
             clearInputDisplay() { if(this.dom.game.inputDisplay) { this.dom.game.inputDisplay.textContent = ''; this.dom.game.inputDisplay.classList.remove('has-target'); } }
             highlightTarget(target, isTarget) { target?.wordElement?.classList.toggle('target', isTarget); target?.element?.classList.toggle('target', isTarget && target instanceof PowerUp); }
             updateLetterHighlight(target, typedLength) { if(!target?.letterSpans) return; target.letterSpans.forEach((span, index) => { span.classList.toggle('typed', index < typedLength); }); }
             setPauseState(isPaused) {
                 this.dom.game.gameArea?.querySelectorAll('.parallax-bg, .enemy, .powerup, .arrow').forEach(el => el.classList.toggle('paused', isPaused));
             }
             triggerScreenShake() { this.dom.appContainer?.classList.remove('screen-shake'); void this.dom.appContainer?.offsetWidth; this.dom.appContainer?.classList.add('screen-shake'); }
        }

        class Player {
             constructor(maxHealth) { this.maxHealth = maxHealth; this.reset(); }
             reset() { this.health = this.maxHealth; this.score = 0; this.streak = 0; this.streakMultiplier = 1; this.maxStreakMultiplier = 1; this.correctTyped = 0; this.totalTyped = 0; }
             takeDamage(amount = 1) { this.health = Math.max(0, this.health - amount); this.resetStreak(); return this.health <= 0; }
             heal(amount = 1) { this.health = clamp(this.health + amount, 0, this.maxHealth); }
             increaseStreak() { this.streak++; this.streakMultiplier = clamp(1 + Math.floor(this.streak / CONFIG.STREAK_BONUS_THRESHOLD), 1, CONFIG.STREAK_MAX_MULTIPLIER); this.maxStreakMultiplier = Math.max(this.maxStreakMultiplier, this.streakMultiplier); }
             resetStreak() { if (this.streak > 0) { this.streak = 0; this.streakMultiplier = 1; return true; } return false; }
             addScore(baseScore) { this.score += baseScore * this.streakMultiplier; }
             recordTyping(isCorrect) { this.totalTyped++; if (isCorrect) this.correctTyped++; }
        }

        class Enemy {
             constructor(id, type, wave, gameAreaWidth, dom) { this.id = id; this.config = CONFIG.ENEMY_CONFIG[type]; this.dom = dom; if (!this.config) { console.error(`Invalid enemy type: ${type}`); this.config = CONFIG.ENEMY_CONFIG['Goblin']; type = 'Goblin'; } this.type = type; this.isBoss = this.config.isBoss || false; this.requiresSentence = this.config.requiresSentence || false; this.maxHp = this.requiresSentence ? 1 : Math.max(1, Math.round(this.config.baseHp + (this.config.baseHp * (wave - 1) * CONFIG.WAVE_SCALING.hpIncreaseFactor))); this.hp = this.maxHp; this.speed = this.config.baseSpeed * (1 + (wave - 1) * CONFIG.WAVE_SCALING.speedIncrease); this.scoreValue = this.config.score; const spriteName = this.config.spritePrefixes[Math.floor(Math.random() * this.config.spritePrefixes.length)]; this.spriteUrl = `sprites/${spriteName}.png`; this.deathSound = this.config.deathSound; this.element = this.createElement(); this.wordElement = this.element.querySelector('.enemy-word'); this.hpBarFill = this.element.querySelector('.enemy-hp-bar-fill'); this.element.style.backgroundImage = `url('${this.spriteUrl}')`; const baseBottom = 40 + (this.isBoss ? 5 : 0); const verticalVariance = 25; const randomBottom = baseBottom + (Math.random() * verticalVariance) - (verticalVariance / 2); this.element.style.bottom = `${clamp(randomBottom, 5, 100)}px`; this.xPosition = gameAreaWidth + Math.random() * 50 + (this.isBoss ? 70 : 25); this.element.style.left = `${this.xPosition}px`; this.isDying = false; this.isFrozen = false; this.freezeTimeout = null; this.letterSpans = []; this.word = ''; this.wordLower = ''; this.warningState = false; }
             createElement() { const el = document.createElement('div'); el.className = `enemy ${this.isBoss ? 'boss' : ''}`; el.id = `enemy-${this.id}`; const wordEl = document.createElement('div'); wordEl.className = 'enemy-word'; el.appendChild(wordEl); if (!this.requiresSentence && this.maxHp > 1) { const hpBarContainer = document.createElement('div'); hpBarContainer.className = 'enemy-hp-bar-container'; const hpBarFill = document.createElement('div'); hpBarFill.className = 'enemy-hp-bar-fill'; hpBarContainer.appendChild(hpBarFill); el.appendChild(hpBarContainer); } return el; }
             setWord(text) { this.word = text; this.wordLower = text.toLowerCase(); if(this.wordElement) { this.wordElement.innerHTML = ''; this.letterSpans = []; text.split('').forEach(char => { const span = document.createElement('span'); span.textContent = char === ' ' ? '\u00A0' : char; this.wordElement.appendChild(span); this.letterSpans.push(span); }); } }
             update(deltaTime, knightDefenseLine, warningLine, game) { if (this.isDying || this.isFrozen || game.state === GAME_STATES.PAUSED) return; const distance = this.speed * (deltaTime / (1000 / 60)); this.xPosition -= distance; if(this.element) this.element.style.left = `${this.xPosition}px`; if (this.xPosition <= knightDefenseLine) { game.handleEnemyReachedKnight(this); return; } const isInWarning = this.xPosition <= warningLine; if (isInWarning !== this.warningState) { this.warningState = isInWarning; this.element?.classList.toggle('warning', isInWarning); } }
             spawn() { if (!this.dom.game.gameArea || !this.element) return; try { this.dom.game.gameArea.appendChild(this.element); requestAnimationFrame(() => { this.element?.classList.add('spawned'); }); } catch (e) { console.error("Error spawning enemy:", e); } }
             takeDamage(amount = 1, game) { if (this.isDying || this.hp <= 0 || this.requiresSentence) return false; this.hp -= amount; if (this.hpBarFill) { const hpPercent = Math.max(0, (this.hp / this.maxHp) * 100); this.hpBarFill.style.width = hpPercent + '%'; } if (this.hp <= 0) { return true; } else { this.element?.classList.add('hit'); setTimeout(() => this.element?.classList.remove('hit'), 200); game.assignNewWordToEnemy(this); return false; } }
             die(killedByPlayer, game) { if (this.isDying) return; this.isDying = true; this.element?.classList.add('dying'); this.element?.classList.remove('warning'); this.wordElement?.remove(); this.element.querySelector('.enemy-hp-bar-container')?.remove(); clearTimeout(this.freezeTimeout); game.particleManager?.emit('death', this.xPosition + (this.element?.offsetWidth || 0) / 2, (this.element?.offsetTop || 0) + (this.element?.offsetHeight || 0) / 2); if(killedByPlayer && game.audioManager) { game.audioManager.play(this.deathSound); if (Math.random() < CONFIG.POWERUP_CHANCE && !this.requiresSentence) { game.spawnPowerUp(this.xPosition + (this.element?.offsetWidth || 0) / 2, (this.element?.offsetTop || 0) + (this.element?.offsetHeight || 0) / 2); } } setTimeout(() => { this.element?.remove(); }, 500); }
             freeze(duration) { if(this.isDying) return; if(this.isBoss) duration *= 0.6; this.isFrozen = true; this.element?.style.setProperty('filter', 'brightness(0.7) saturate(0) contrast(1.2) drop-shadow(3px 3px 3px rgba(0,0,0,0.5))'); this.element?.classList.remove('warning'); this.wordElement?.style.setProperty('border-color', 'var(--color-freeze)'); this.wordElement?.style.setProperty('color', 'var(--color-freeze)'); clearTimeout(this.freezeTimeout); this.freezeTimeout = setTimeout(() => this.unfreeze(), duration); }
             unfreeze() { clearTimeout(this.freezeTimeout); this.isFrozen = false; this.element?.style.removeProperty('filter'); this.wordElement?.style.removeProperty('border-color'); this.wordElement?.style.removeProperty('color'); }
        }

        class PowerUp {
             constructor(id, type, x, y, game) { this.id = id; this.type = type; this.word = type; this.wordLower = type.toLowerCase(); this.game = game; this.dom = game.dom; this.element = this.createElement(); this.wordElement = this.element.querySelector('.powerup-word'); this.timerElement = this.element.querySelector('.powerup-timer'); this.element.classList.add(type.toLowerCase()); this.element.id = `powerup-${id}`; this.element.style.left = `${x}px`; this.element.style.top = `${y}px`; this.clickHandler = () => this.game.handlePowerUpTyped(this); this.touchHandler = (e) => { e.preventDefault(); this.game.handlePowerUpTyped(this); }; this.element.addEventListener('click', this.clickHandler); this.element.addEventListener('touchstart', this.touchHandler, { passive: false }); this.letterSpans = []; this.word.split('').forEach(char => { const span = document.createElement('span'); span.textContent = char; this.wordElement.appendChild(span); this.letterSpans.push(span); }); this.spawnTime = performance.now(); this.lifetime = CONFIG.POWERUP_LIFETIME; this.isDying = false; this.isVisible = false; if(this.dom.game.gameArea) { this.dom.game.gameArea.appendChild(this.element); requestAnimationFrame(() => { if(this.element) { this.element.style.left = `${x - (this.element.offsetWidth / 2)}px`; this.element.style.top = `${y - (this.element.offsetHeight / 2)}px`; this.isVisible = true; } }); } game.audioManager?.play('powerupSpawn'); this.updateTimer(this.spawnTime); }
             createElement() { const el = document.createElement('div'); el.className = 'powerup'; el.style.transformOrigin = 'center center'; const wordEl = document.createElement('div'); wordEl.className = 'powerup-word'; const timerEl = document.createElement('div'); timerEl.className = 'powerup-timer'; el.appendChild(wordEl); el.appendChild(timerEl); return el; }
             updateTimer(currentTime) { if (this.isDying || !this.timerElement || !this.isVisible || this.game.state === GAME_STATES.PAUSED) return; const timeElapsed = currentTime - this.spawnTime; const timeLeftMs = Math.max(0, this.lifetime - timeElapsed); this.timerElement.textContent = `${(timeLeftMs / 1000).toFixed(1)}s`; if (timeLeftMs <= 0) { this.remove(false, true); } }
             remove(collected = false, expired = false) { if (this.isDying) return; this.isDying = true; this.element?.removeEventListener('click', this.clickHandler); this.element?.removeEventListener('touchstart', this.touchHandler); this.element?.remove(); this.game?.removePowerUp(this.id, collected); }
             activate() { if (this.game.state !== GAME_STATES.PLAYING || this.isDying || !this.game.audioManager) return; this.game.audioManager.play('powerupGet'); const centerX = this.element.offsetLeft + this.element.offsetWidth / 2; const centerY = this.element.offsetTop + this.element.offsetHeight / 2; const particleType = `powerup-${this.type.toLowerCase()}`; this.game.particleManager?.emit(particleType, centerX, centerY); switch (this.type) { case 'HEAL': this.game.player.heal(1); this.game.uiManager?.updateGameUI(this.game.player, this.game.wave); this.game.audioManager.play('powerupHeal'); break; case 'BOMB': this.game.enemies.slice().forEach(enemy => { if (!enemy.isDying) { const killed = enemy.requiresSentence ? true : enemy.takeDamage(100, this.game); if (killed) { this.game.handleEnemyKilled(enemy, true); } } }); this.game.audioManager.play('powerupBomb'); break; case 'FREEZE': this.game.enemies.forEach(enemy => { if (!enemy.isDying) enemy.freeze(4000); }); this.game.audioManager.play('powerupFreeze'); break; } this.remove(true); }
        }

        class Arrow {
            constructor(id, game) {
                this.id = id; this.game = game; this.dom = game.dom; this.element = this.createElement(); this.letterElement = this.element.querySelector('.arrow-letter'); this.letter = ALPHABET[Math.floor(Math.random() * ALPHABET.length)]; this.letterElement.textContent = this.letter.toUpperCase(); const gameAreaRect = this.dom.game.gameArea?.getBoundingClientRect(); const knightRect = this.dom.game.knight?.getBoundingClientRect(); if (!gameAreaRect || !knightRect || gameAreaRect.width <= 0 || knightRect.width <= 0) { this.startX = 800; this.startY = 200; this.endX = 100; this.endY = 250; console.warn("Could not get valid bounding rects for arrow setup, using defaults."); } else { this.startX = gameAreaRect.width; this.startY = Math.random() * (gameAreaRect.height * 0.65) + (gameAreaRect.height * 0.1); this.endX = (knightRect.left - gameAreaRect.left) + (knightRect.width * 0.5); this.endY = (knightRect.top - gameAreaRect.top) + (knightRect.height * 0.5); } this.duration = Math.random() * (CONFIG.ARROW_FLIGHT_DURATION_MAX - CONFIG.ARROW_FLIGHT_DURATION_MIN) + CONFIG.ARROW_FLIGHT_DURATION_MIN; this.arcHeight = Math.random() * (CONFIG.ARROW_ARC_HEIGHT_MAX - CONFIG.ARROW_ARC_HEIGHT_MIN) + CONFIG.ARROW_ARC_HEIGHT_MIN; this.spawnTime = performance.now(); this.isDying = false; this.lastX = this.startX; this.lastY = this.startY; this.element.style.transform = `translate(${this.startX}px, ${this.startY}px) rotate(0deg)`; if (this.dom.game.gameArea) { this.dom.game.gameArea.appendChild(this.element); } else { console.error("Game area not found for arrow spawn"); } game.audioManager?.play('arrowSpawn');
            }
            createElement() { const el = document.createElement('div'); el.className = 'arrow'; el.id = `arrow-${this.id}`; const letterEl = document.createElement('span'); letterEl.className = 'arrow-letter'; el.appendChild(letterEl); return el; }
            update(currentTime) {
                if (this.isDying || this.game.state === GAME_STATES.PAUSED) return;
                const elapsedTime = currentTime - this.spawnTime; const progress = Math.min(elapsedTime / this.duration, 1);
                const currentX = this.startX + (this.endX - this.startX) * progress;
                const parabolicFactor = 4 * progress * (1 - progress);
                const currentY = this.startY + (this.endY - this.startY) * progress - this.arcHeight * parabolicFactor;
                const dx = currentX - this.lastX; const dy = currentY - this.lastY;
                const angle = (dx === 0 && dy === 0 && progress > 0) ? parseFloat(this.element.style.transform.match(/rotate\(([^deg]+)deg\)/)?.[1] || '0') : Math.atan2(dy, dx) * (180 / Math.PI);
                this.element.style.transform = `translate(${currentX}px, ${currentY}px) rotate(${angle}deg)`;
                this.letterElement.style.transform = `translate(-50%, -50%) rotate(${-angle}deg)`;
                this.lastX = currentX; this.lastY = currentY;
                this.element.style.setProperty('--last-x', `${currentX}px`);
                this.element.style.setProperty('--last-y', `${currentY}px`);
                if (progress >= 1) { this.game.handleArrowReachedKnight(this); }
            }
            hit() {
                if (this.isDying || !this.game.audioManager) return; this.isDying = true;
                this.game.audioManager.play('arrowHit');
                this.game.particleManager?.emit('arrow-hit', this.lastX, this.lastY);
                this.element?.classList.add('dying');
                setTimeout(() => this.remove(), 300);
            }
            remove() { this.element?.remove(); this.game?.removeArrow(this.id); }
        }

        class Game {
            constructor(domCache) {
                this.dom = domCache;
                this.state = GAME_STATES.LOADING;
                this.wave = 1;
                this.enemies = [];
                this.powerups = [];
                this.arrows = [];
                this.availableWords = [];
                this.availableSentences = [];
                this.gameLoopTimerId = null;
                this.spawnTimerId = null;
                this.nextEnemyId = 0;
                this.nextPowerUpId = 0;
                this.nextArrowId = 0;
                this.knightDefenseLine = 80;
                this.enemyWarningLine = 180;
                this.currentTypingTarget = null;
                this.lastUpdateTime = 0;
                this.enemiesToSpawnThisWave = 0;
                this.enemiesSpawnedThisWave = 0;
                this.enemiesKilledThisWave = 0;
                this.isBossWave = false;
                this.highScore = 0;
                this.player = new Player(CONFIG.INITIAL_PLAYER_HEALTH);
                this.audioManager = null;
                this.uiManager = null;
                this.particleManager = null;
                this.currentInput = "";
                this.isMobile = false;
                this.isFocused = true;
            }

            async init() {
                if (!this.validateDOMCache()) { throw new Error("Critical DOM elements missing!"); }
                this.isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

                this.audioManager = new AudioManager(this.dom.audioElements);
                this.uiManager = new UIManager(this, this.dom);
                this.particleManager = new ParticleManager(this.dom.game.particleContainer);

                this.audioManager.initVolumes();
                this.loadHighScore();
                this.uiManager.updateHighScore(this.highScore);
                this.uiManager.setLoading(true, "Loading Assets...");

                try {
                    await this.audioManager.loadAssets();
                    this.uiManager.setLoading(false);
                    this.setupEventListeners();
                    this.calculateDefenseLines();
                    this.setState(GAME_STATES.MENU);
                } catch (err) {
                    console.error("Asset loading failed:", err);
                    this.uiManager.setLoading(false, "Error Loading!");
                }
            }

            validateDOMCache() {
                let allFound = true;
                const check = (el, name) => { if (!el) { console.error(`DOM element missing: ${name}`); allFound = false; } };
                check(this.dom.appContainer, 'appContainer'); check(this.dom.screens.menu, 'screens.menu'); check(this.dom.screens.game, 'screens.game'); check(this.dom.screens.gameOver, 'screens.gameOver'); check(this.dom.screens.pause, 'screens.pause'); check(this.dom.game.screen, 'game.screen'); check(this.dom.game.gameArea, 'game.gameArea'); check(this.dom.game.knight, 'game.knight'); check(this.dom.game.inputDisplay, 'game.inputDisplay'); check(this.dom.game.inputDisplayArea, 'game.inputDisplayArea'); check(this.dom.game.particleContainer, 'game.particleContainer'); check(this.dom.buttons.start, 'buttons.start'); check(this.dom.buttons.pauseMenu, 'buttons.pauseMenu'); check(this.dom.mobileInput, 'mobileInput');
                for(const key in this.dom.audioElements) { check(this.dom.audioElements[key], `audioElements.${key}`); }
                return allFound;
            }

            setState(newState) {
                if (this.state === newState) return;
                this.state = newState;

                switch (newState) {
                    case GAME_STATES.MENU:
                        this.stopGameLoop();
                        this.cleanupGameElements();
                        this.uiManager?.showScreen('menu');
                        this.uiManager?.updateHighScore(this.highScore);
                        this.audioManager?.stopAllSfx();
                        this.audioManager?.stop('bgm');
                        this.uiManager?.clearInputDisplay();
                        this.dom.screens.pause?.classList.remove('active');
                        this.dom.buttons.pauseMenu?.style.setProperty('display', 'none');
                        if (this.isMobile) this.dom.mobileInput?.blur();
                        break;
                    case GAME_STATES.STARTING_WAVE:
                         this.uiManager?.updateGameUI(this.player, this.wave);
                         this.currentTypingTarget = null;
                         this.currentInput = "";
                         this.uiManager?.clearInputDisplay();
                         this.isBossWave = (this.wave % CONFIG.BOSS_WAVE_INTERVAL === 0);
                         this.enemiesSpawnedThisWave = 0;
                         this.enemiesKilledThisWave = 0;
                         this.enemiesToSpawnThisWave = this.isBossWave ? 1 : Math.floor(CONFIG.WAVE_SCALING.baseEnemies + (this.wave -1) * CONFIG.WAVE_SCALING.enemiesIncrease);
                         const message = `Wave ${this.wave}${this.isBossWave ? '\n<span style="color: var(--color-health); font-size: 0.8em;">BOSS WAVE!</span>' : ''}<br>Get Ready!`;
                         this.uiManager?.showMessage(message, CONFIG.WAVE_START_DELAY - 200, 'wave-complete', () => {
                             if (this.state === GAME_STATES.STARTING_WAVE) {
                                 this.setState(GAME_STATES.PLAYING);
                                 this.scheduleNextSpawn(true);
                             }
                         });
                         break;
                    case GAME_STATES.PLAYING:
                        this.uiManager?.showScreen('game');
                        this.dom.buttons.pauseMenu?.style.setProperty('display', 'block');
                        this.startGameLoop();
                        this.audioManager?.setPauseState(false);
                        this.uiManager?.setPauseState(false);
                        this.particleManager?.setPauseState(false);
                        if (this.isMobile && this.isFocused) { this.focusMobileInput(); }
                        if (!this.audioManager?.elements.bgm?.playing) { this.audioManager?.play('bgm', true); }
                        break;
                    case GAME_STATES.PAUSED:
                        this.stopGameLoop();
                        clearTimeout(this.spawnTimerId); this.spawnTimerId = null;
                        this.dom.screens.pause?.classList.add('active');
                        this.audioManager?.setPauseState(true);
                        this.uiManager?.setPauseState(true);
                        this.particleManager?.setPauseState(true);
                        if (this.isMobile) this.dom.mobileInput?.blur();
                        break;
                    case GAME_STATES.WAVE_COMPLETE:
                        this.stopGameLoop();
                        clearTimeout(this.spawnTimerId); this.spawnTimerId = null;
                        this.audioManager?.play('waveComplete');
                        this.clearTarget();
                        this.wave++;
                        this.uiManager?.showMessage(`Wave ${this.wave - 1} Complete!`, CONFIG.WAVE_COMPLETE_DELAY - 200, 'wave-complete', () => {
                            if (this.state === GAME_STATES.WAVE_COMPLETE) {
                                this.setState(GAME_STATES.STARTING_WAVE);
                            }
                        });
                        break;
                    case GAME_STATES.GAMEOVER:
                        this.stopGameLoop();
                        clearTimeout(this.spawnTimerId); this.spawnTimerId = null;
                        this.saveHighScore();
                        this.audioManager?.stop('bgm');
                        this.audioManager?.play('gameOver');
                        this.audioManager?.stopAllSfx();
                        this.uiManager?.updateGameOverUI(this.player, this.wave);
                        this.uiManager?.showScreen('gameOver');
                        this.uiManager?.clearInputDisplay();
                        this.dom.screens.pause?.classList.remove('active');
                        this.dom.buttons.pauseMenu?.style.setProperty('display', 'none');
                        if (this.isMobile) this.dom.mobileInput?.blur();
                        setTimeout(() => this.cleanupGameElements(), 500);
                        break;
                }
            }

            loadHighScore() { this.highScore = parseInt(localStorage.getItem('typingKnight_highScore') || '0'); }
            saveHighScore() { if (this.player.score > this.highScore) { this.highScore = this.player.score; localStorage.setItem('typingKnight_highScore', this.highScore.toString()); this.uiManager?.updateHighScore(this.highScore); } }

            setupEventListeners() {
                this.dom.buttons.start.onclick = () => { this.audioManager?.play('select'); this.startNewGame(); };
                this.dom.buttons.playAgain.onclick = () => { this.audioManager?.play('select'); this.startNewGame(); };
                this.dom.buttons.mainMenuReturn.onclick = () => { this.audioManager?.play('select'); this.setState(GAME_STATES.MENU); };
                this.dom.buttons.pauseFullscreen.onclick = () => { this.audioManager?.play('select'); this.toggleFullscreen(); };
                this.dom.buttons.resume.onclick = () => { this.togglePause(); };
                this.dom.buttons.pauseQuit.onclick = () => { this.audioManager?.play('select'); if (this.state === GAME_STATES.PAUSED) this.togglePause(); this.setState(GAME_STATES.MENU); };
                this.dom.buttons.pauseMenu.onclick = () => { this.togglePause(); };

                window.onresize = () => this.handleResize();
                if (window.visualViewport) window.visualViewport.onresize = () => this.handleResize();
                document.onfullscreenchange = () => {};

                window.addEventListener('keydown', (e) => this.handleGlobalKeyPress(e));

                if (this.isMobile) {
                    const focusHandler = (e) => {
                         // Only prevent default if the target isn't already interactive (like a button)
                         if (!(e.target instanceof HTMLButtonElement) && this.state === GAME_STATES.PLAYING) {
                              e.preventDefault();
                              this.focusMobileInput();
                         }
                    };
                    // Attach listener to the game screen container
                    this.dom.game.screen?.addEventListener('touchstart', focusHandler, { passive: false });

                    this.dom.mobileInput?.addEventListener('input', (e) => this.handleMobileInput(e));
                    this.dom.mobileInput?.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') e.preventDefault(); });
                    this.dom.mobileInput?.addEventListener('blur', () => {});
                } else { if (this.dom.game.inputDisplayArea) this.dom.game.inputDisplayArea.style.cursor = 'default'; }

                document.addEventListener('visibilitychange', () => {
                    if (document.hidden && (this.state === GAME_STATES.PLAYING || this.state === GAME_STATES.STARTING_WAVE || this.state === GAME_STATES.WAVE_COMPLETE)) {
                        this.isFocused = false;
                        this.togglePause(true);
                    } else if (!document.hidden) {
                         this.isFocused = true;
                    }
                });
            }

            focusMobileInput() { if (this.isMobile && this.dom.mobileInput && this.state === GAME_STATES.PLAYING) { setTimeout(() => { try { this.dom.mobileInput.focus({ preventScroll: true }); } catch (e) { console.warn("Focus failed", e); } }, 50); } }
            handleResize() { requestAnimationFrame(() => this.calculateDefenseLines()); }
            calculateDefenseLines() {
                if (this.dom.game.knight && this.dom.game.gameArea) {
                    const knightRect = this.dom.game.knight.getBoundingClientRect();
                    const gameAreaRect = this.dom.game.gameArea.getBoundingClientRect();
                    if (knightRect.width > 0 && gameAreaRect.width > 0) {
                        this.knightDefenseLine = (knightRect.right - gameAreaRect.left) - CONFIG.KNIGHT_DEFENSE_BUFFER;
                        this.enemyWarningLine = this.knightDefenseLine + CONFIG.ENEMY_WARNING_DISTANCE;
                    } else { this.knightDefenseLine = 80; this.enemyWarningLine = 260; }
                } else { this.knightDefenseLine = 80; this.enemyWarningLine = 260; }
            }
            getRandomWord(wave) {
                 const minLen = 3 + Math.floor((wave - 1) * CONFIG.WAVE_SCALING.wordLengthMinBonus);
                 const maxLen = 6 + Math.floor((wave - 1) * CONFIG.WAVE_SCALING.wordLengthMaxBonus);
                 let potentialWords = this.availableWords.filter(w => w.length >= minLen && w.length <= maxLen);
                 if(potentialWords.length === 0) potentialWords = this.availableWords.filter(w => w.length >= minLen);
                 if(potentialWords.length === 0) potentialWords = this.availableWords;
                 if (potentialWords.length === 0) {
                     if (WORD_LIST_SOURCE.length > 0) { this.resetWordList(); potentialWords = this.availableWords; }
                     else { console.error("Word list exhausted!"); return "ERROR"; }
                 }
                 const randomIndex = Math.floor(Math.random() * potentialWords.length);
                 const word = potentialWords[randomIndex];
                 const mainIndex = this.availableWords.indexOf(word);
                 if(mainIndex > -1) this.availableWords.splice(mainIndex, 1);
                 if (this.availableWords.length < 50) this.resetWordList();
                 return word;
            }
             getRandomSentence() {
                 if (this.availableSentences.length === 0) {
                     if (SENTENCE_LIST_SOURCE.length > 0) { this.resetSentenceList(); }
                     else { console.error("Sentence list exhausted!"); return "SENTENCE ERROR"; }
                 }
                 const randomIndex = Math.floor(Math.random() * this.availableSentences.length);
                 const sentence = this.availableSentences[randomIndex];
                 this.availableSentences.splice(randomIndex, 1);
                 return sentence;
             }
            resetWordList() { if (WORD_LIST_SOURCE.length > 0) { this.availableWords = [...WORD_LIST_SOURCE]; } }
            resetSentenceList() { if (SENTENCE_LIST_SOURCE.length > 0) { this.availableSentences = [...SENTENCE_LIST_SOURCE]; } }

            startNewGame() {
                if (this.state === GAME_STATES.PLAYING || this.state === GAME_STATES.STARTING_WAVE) return;
                if (!this.audioManager?.assetsLoaded) { this.uiManager?.showMessage("Assets still loading...", 2000); return; }
                this.wave = 1;
                this.player.reset();
                this.cleanupGameElements();
                this.resetWordList();
                this.resetSentenceList();
                this.nextEnemyId = 0; this.nextPowerUpId = 0; this.nextArrowId = 0;
                this.uiManager?.updateGameUI(this.player, this.wave);
                this.uiManager?.hideMessage();
                this.audioManager?.play('startBeep');
                this.setState(GAME_STATES.STARTING_WAVE);
            }
            cleanupGameElements() {
                this.enemies.forEach(e => e.element?.remove()); this.enemies = [];
                this.powerups.forEach(p => p.remove(false, false)); this.powerups = [];
                this.arrows.forEach(a => a.remove()); this.arrows = [];
                this.particleManager?.clear();
                this.currentInput = ""; this.currentTypingTarget = null;
                clearTimeout(this.spawnTimerId); this.spawnTimerId = null;
                this.dom.game.knight?.classList.remove('hit');
            }

            scheduleNextSpawn(immediate = false) {
                 if (this.spawnTimerId) clearTimeout(this.spawnTimerId);
                 if (this.state !== GAME_STATES.PLAYING || this.enemiesSpawnedThisWave >= this.enemiesToSpawnThisWave) { return; }
                 if (immediate) { this.spawnEnemy(); return; }

                 const baseInterval = CONFIG.WAVE_SCALING.baseSpawnInterval;
                 const minInterval = CONFIG.WAVE_SCALING.minSpawnInterval;
                 const reduction = CONFIG.WAVE_SCALING.spawnIntervalReduction * (this.wave - 1);
                 let interval = Math.max(minInterval, baseInterval - reduction);
                 if(this.isBossWave && this.enemiesSpawnedThisWave === 0) interval *= 1.5;

                 this.spawnTimerId = setTimeout(() => {
                     if (this.state === GAME_STATES.PLAYING && this.enemiesSpawnedThisWave < this.enemiesToSpawnThisWave) {
                         this.spawnEnemy();
                     } else {
                          clearTimeout(this.spawnTimerId);
                          this.spawnTimerId = null;
                     }
                 }, interval);
            }
            spawnEnemy() {
                if(this.state !== GAME_STATES.PLAYING || this.enemiesSpawnedThisWave >= this.enemiesToSpawnThisWave) return;
                this.enemiesSpawnedThisWave++; this.nextEnemyId++;
                const gameAreaWidth = this.dom.game.gameArea?.offsetWidth || 800;
                let enemyType;
                if (this.isBossWave && this.enemiesSpawnedThisWave === 1) { enemyType = ((this.wave / CONFIG.BOSS_WAVE_INTERVAL) % 2 === 1) ? 'King' : 'Queen'; }
                else { const normalTypes = Object.keys(CONFIG.ENEMY_CONFIG).filter(t => !CONFIG.ENEMY_CONFIG[t].isBoss); enemyType = normalTypes.length > 0 ? normalTypes[Math.floor(Math.random() * normalTypes.length)] : 'Goblin'; }
                try {
                    const enemy = new Enemy(this.nextEnemyId, enemyType, this.wave, gameAreaWidth, this.dom);
                    let textToType;
                    if (enemy.requiresSentence) {
                        textToType = this.getRandomSentence();
                         if (textToType === "SENTENCE ERROR") { this.setState(GAME_STATES.GAMEOVER); return; }
                    } else {
                        textToType = this.getRandomWord(this.wave);
                         if (textToType === "ERROR") { this.setState(GAME_STATES.GAMEOVER); return; }
                    }
                    enemy.setWord(textToType); enemy.spawn(); this.enemies.push(enemy);
                } catch (e) { console.error("Error creating enemy:", e); }
                if (this.enemiesSpawnedThisWave < this.enemiesToSpawnThisWave) {
                     this.scheduleNextSpawn();
                }
            }
            spawnPowerUp(x, y) {
                if (this.state !== GAME_STATES.PLAYING || !this.dom.game.gameArea) return;
                const gameAreaHeight = this.dom.game.gameArea.offsetHeight;
                const minY = gameAreaHeight * CONFIG.POWERUP_MIN_Y_PERCENT; const maxY = gameAreaHeight * CONFIG.POWERUP_MAX_Y_PERCENT;
                const spawnY = clamp(y, minY, maxY); this.nextPowerUpId++;
                const type = CONFIG.POWERUP_TYPES[Math.floor(Math.random() * CONFIG.POWERUP_TYPES.length)];
                try { const powerup = new PowerUp(this.nextPowerUpId, type, x, spawnY, this); this.powerups.push(powerup); } catch(e) { console.error("Error creating powerup:", e); }
            }
            removePowerUp(id, collected) { const index = this.powerups.findIndex(p => p.id === id); if (index > -1) { if (this.currentTypingTarget === this.powerups[index]) { this.clearTarget(); } this.powerups.splice(index, 1); } }
            spawnArrow() { if (this.state !== GAME_STATES.PLAYING || !this.dom.game.gameArea) return; this.nextArrowId++; try { const arrow = new Arrow(this.nextArrowId, this); this.arrows.push(arrow); } catch(e) { console.error("Error creating arrow:", e); } }
            removeArrow(id) { const index = this.arrows.findIndex(a => a.id === id); if (index > -1) { this.arrows.splice(index, 1); } }
            assignNewWordToEnemy(enemy) { if (!enemy || enemy.isDying || enemy.requiresSentence) return; const newWord = this.getRandomWord(this.wave); if(newWord !== "ERROR") enemy.setWord(newWord); else { this.setState(GAME_STATES.GAMEOVER); return; } if(this.currentTypingTarget === enemy) { this.uiManager?.updateLetterHighlight(enemy, 0); this.clearInputBuffer(); this.clearTarget(false); } }

            handleMobileInput(event) { if (this.state !== GAME_STATES.PLAYING || !event.target) return; const typedChar = event.target.value.slice(-1).toLowerCase(); event.target.value = ''; if (typedChar && (typedChar.match(/[a-z0-9]/i) || typedChar === ' ')) { this.handleKeyPress(typedChar); } }
            handleGlobalKeyPress(event) {
                if (event.target instanceof HTMLInputElement && event.target !== this.dom.mobileInput) return;
                if (this.isMobile && event.target === this.dom.mobileInput && event.key !== 'Backspace') return;
                if (event.key === 'Escape') { event.preventDefault(); this.togglePause(); return; }
                if (this.state === GAME_STATES.PLAYING) { if (event.ctrlKey || event.altKey || event.metaKey) return; event.preventDefault(); this.handleKeyPress(event.key); }
                else if (this.state === GAME_STATES.PAUSED && event.key === 'Escape') { event.preventDefault(); this.togglePause(); }
            }

            handleKeyPress(key) {
                if (this.state !== GAME_STATES.PLAYING) return;

                const lowerKey = key.toLowerCase();

                if (key === 'Backspace') {
                    if (this.currentInput.length > 0) {
                        this.currentInput = this.currentInput.slice(0, -1);
                        this.processCurrentInput();
                    }
                } else if (key === 'Enter') {
                     // Allow enter to clear input/target, but not space unless it's needed for a sentence
                    this.clearInputBuffer();
                    this.clearTarget();
                } else if ((lowerKey.length === 1 && ALPHABET.includes(lowerKey)) || (lowerKey === ' ' && this.currentTypingTarget?.requiresSentence)) {
                    const character = (lowerKey === ' ' ? ' ' : lowerKey); // Get the actual character (space or letter)
                    const potentialInput = this.currentInput + character;
                    const potentialInputLower = potentialInput.toLowerCase();

                    if (this.currentTypingTarget) {
                        // Prioritize current target
                        if (this.currentTypingTarget.wordLower.startsWith(potentialInputLower)) {
                            // Correct character for the target
                            this.currentInput = potentialInput;
                            this.audioManager?.play('type');
                            this.processCurrentInput(); // Handles highlighting and completion
                            this.player.recordTyping(true);
                        } else {
                            // Incorrect character for the current target
                            this.handleMistype();
                        }
                    } else {
                        // No current target, check arrows first (only if it's a letter)
                        const arrowHit = (character !== ' ') ? this.tryHitArrow(character) : false;

                        if (!arrowHit) {
                            // Arrow not hit, or space was pressed. Check if this starts a new target.
                             const isValidPrefix = [...this.enemies, ...this.powerups].some(item => item && !item.isDying && item.wordLower.startsWith(potentialInputLower));
                            if (isValidPrefix) {
                                this.currentInput = potentialInput;
                                this.audioManager?.play('type');
                                this.processCurrentInput(); // Should acquire a target now
                                this.player.recordTyping(true);
                            } else {
                                // Doesn't start a valid target
                                this.handleMistype();
                            }
                        }
                        // If arrowHit was true, tryHitArrow handled score/streak etc. Input buffer was NOT cleared by tryHitArrow.
                    }
                } else if (lowerKey.length === 1 && lowerKey.match(/[0-9]/)) {
                    // Handle numbers (cannot be arrows)
                    const potentialInput = this.currentInput + lowerKey;
                    const potentialInputLower = potentialInput.toLowerCase();
                    const isValidPrefix = [...this.enemies, ...this.powerups].some(item => item && !item.isDying && item.wordLower.startsWith(potentialInputLower));
                    if (isValidPrefix || (this.currentTypingTarget && this.currentTypingTarget.wordLower.startsWith(potentialInputLower))) {
                        this.currentInput = potentialInput;
                        this.audioManager?.play('type');
                        this.processCurrentInput();
                        this.player.recordTyping(true);
                    } else {
                        this.handleMistype();
                    }
                }

                if (this.isMobile) { this.focusMobileInput(); }
            }


            handleMistype() {
                this.audioManager?.play('error');
                this.player.recordTyping(false);
                if (this.player.resetStreak()) {
                    this.uiManager?.updateGameUI(this.player, this.wave);
                }
            }

            tryHitArrow(letter) {
                let hit = false;
                let closestArrow = null;
                let minDistance = Infinity;
                this.arrows.forEach(arrow => {
                    if (!arrow.isDying && arrow.letter === letter) {
                        if (arrow.lastX < minDistance) {
                            minDistance = arrow.lastX;
                            closestArrow = arrow;
                        }
                    }
                });
                if (closestArrow) {
                    this.audioManager?.play('hit');
                    closestArrow.hit(); // Handles particles, sound, removal timer
                    this.player.addScore(CONFIG.ARROW_SCORE);
                    this.player.increaseStreak();
                    this.uiManager?.updateGameUI(this.player, this.wave);
                    this.player.recordTyping(true); // Count arrow typing as correct
                    hit = true;
                    // Intentionally DO NOT clear input/target here
                }
                return hit;
            }

            processCurrentInput() {
                 const currentInputLower = this.currentInput.toLowerCase();
                 this.uiManager?.updateInputDisplay(this.currentInput, !!this.currentTypingTarget);
                 if (this.currentInput === '') { this.clearTarget(); return; }
                 let bestMatch = null; let minDistance = Infinity;
                 if (this.currentTypingTarget && !this.currentTypingTarget.isDying && this.currentTypingTarget.wordLower.startsWith(currentInputLower)) { bestMatch = this.currentTypingTarget; }
                 else { const candidates = [...this.enemies, ...this.powerups].filter(item => item && !item.isDying && item.element && item.wordLower.startsWith(currentInputLower)); candidates.forEach(item => { const itemX = item.element.offsetLeft; if (itemX < minDistance) { minDistance = itemX; bestMatch = item; } }); }
                 if (bestMatch) {
                     if (this.currentTypingTarget !== bestMatch) { this.setTarget(bestMatch); }
                     if (this.currentTypingTarget) {
                         this.uiManager?.updateLetterHighlight(this.currentTypingTarget, this.currentInput.length);
                         if (currentInputLower === this.currentTypingTarget.wordLower) { // Compare lowercase for completion
                             this.handleWordCompletion();
                         }
                     }
                 } else {
                      // Only trigger mistype if we *had* a target but the input no longer matches its start
                      if (this.currentTypingTarget && !this.currentTypingTarget.wordLower.startsWith(currentInputLower)) {
                           this.handleMistype();
                      }
                      // If no target, and input doesn't match start of anything, do nothing (Backspace might have cleared it)
                 }
            }
            handleWordCompletion() { if (!this.currentTypingTarget || this.state !== GAME_STATES.PLAYING) return; this.audioManager?.play('shoot'); let completedTarget = this.currentTypingTarget; this.clearInputBuffer(); this.clearTarget(); if (completedTarget instanceof Enemy) { if (completedTarget.requiresSentence) { this.handleEnemyKilled(completedTarget, true); } else { this.handleEnemyTyped(completedTarget); } } else if (completedTarget instanceof PowerUp) { this.handlePowerUpTyped(completedTarget); } }
            handleEnemyTyped(enemy) { if (!enemy || enemy.isDying || enemy.requiresSentence) return; const killed = enemy.takeDamage(1, this); if (killed) { this.handleEnemyKilled(enemy, true); } else { this.audioManager?.play('enemyHit'); this.particleManager?.emit('hit', enemy.xPosition + (enemy.element?.offsetWidth || 0) / 2, (enemy.element?.offsetTop || 0) + (enemy.element?.offsetHeight || 0) / 2); } }
            handleEnemyKilled(enemy, byPlayerAction) {
                 if (!enemy || enemy.isDying) return;
                 const wasTarget = this.currentTypingTarget === enemy;
                 enemy.die(byPlayerAction, this);
                 if (byPlayerAction) { this.player.increaseStreak(); this.player.addScore(enemy.scoreValue); if(this.player.streakMultiplier > 1 && this.player.streak > 0 && this.player.streak % CONFIG.STREAK_BONUS_THRESHOLD === 0) { this.audioManager?.play('streak'); } }
                 this.enemiesKilledThisWave++; this.uiManager?.updateGameUI(this.player, this.wave);
                 const index = this.enemies.findIndex(e => e.id === enemy.id); if (index > -1) this.enemies.splice(index, 1);
                 if (wasTarget) { this.clearTarget(); }
                 if (this.enemiesSpawnedThisWave >= this.enemiesToSpawnThisWave && this.enemies.filter(e => !e.isDying).length === 0) { if(this.state === GAME_STATES.PLAYING) { this.setState(GAME_STATES.WAVE_COMPLETE); } }
            }
            handlePowerUpTyped(powerup) { if (!powerup || powerup.isDying || this.powerups.indexOf(powerup) === -1) return; const wasTarget = this.currentTypingTarget === powerup; powerup.activate(); if (wasTarget) { this.clearTarget(); } }
            handleEnemyReachedKnight(enemy) {
                 if (!enemy || enemy.isDying || this.state !== GAME_STATES.PLAYING) return;
                 const wasTarget = this.currentTypingTarget === enemy;
                 enemy.die(false, this); const index = this.enemies.findIndex(e => e.id === enemy.id); if (index > -1) this.enemies.splice(index, 1);
                 if (wasTarget) { this.clearTarget(); }
                 this.audioManager?.play('playerHurt'); this.uiManager?.triggerScreenShake(); this.dom.game.knight?.classList.add('hit'); setTimeout(() => this.dom.game.knight?.classList.remove('hit'), 400);
                 const isGameOver = this.player.takeDamage(1);
                 this.uiManager?.updateGameUI(this.player, this.wave);
                 if (isGameOver) { this.audioManager?.play('playerDie'); this.setState(GAME_STATES.GAMEOVER); }
            }
            handleArrowReachedKnight(arrow) {
                 if (!arrow || arrow.isDying || this.state !== GAME_STATES.PLAYING) return;
                 arrow.remove();
                 this.audioManager?.play('arrowMiss'); this.uiManager?.triggerScreenShake(); this.dom.game.knight?.classList.add('hit'); setTimeout(() => this.dom.game.knight?.classList.remove('hit'), 400);
                 const isGameOver = this.player.takeDamage(1);
                 this.uiManager?.updateGameUI(this.player, this.wave);
                 if (isGameOver) { this.audioManager?.play('playerDie'); this.setState(GAME_STATES.GAMEOVER); }
            }
            setTarget(target) { if (this.currentTypingTarget === target) return; this.clearTarget(false); this.currentTypingTarget = target; this.uiManager?.highlightTarget(target, true); this.uiManager?.updateInputDisplay(this.currentInput, true); this.uiManager?.updateLetterHighlight(target, this.currentInput.length); }
            clearTarget(clearInputToo = true) { if (this.currentTypingTarget) { this.uiManager?.highlightTarget(this.currentTypingTarget, false); this.uiManager?.updateLetterHighlight(this.currentTypingTarget, 0); this.currentTypingTarget = null; } if(clearInputToo) { this.clearInputBuffer(); } else { this.uiManager?.updateInputDisplay(this.currentInput, false); } }
            clearInputBuffer() { this.currentInput = ""; this.uiManager?.clearInputDisplay(); if(this.currentTypingTarget) { this.uiManager?.updateLetterHighlight(this.currentTypingTarget, 0); } }

            startGameLoop() {
                if (this.gameLoopTimerId) return; this.lastUpdateTime = performance.now();
                const loop = (now) => {
                    if (this.state !== GAME_STATES.PLAYING) { this.gameLoopTimerId = null; return; }
                    const deltaTime = Math.min(now - this.lastUpdateTime, 50); this.lastUpdateTime = now;
                    this.updateGame(deltaTime, now);
                    this.gameLoopTimerId = requestAnimationFrame(loop);
                };
                this.gameLoopTimerId = requestAnimationFrame(loop);
            }
            stopGameLoop() { if (this.gameLoopTimerId) cancelAnimationFrame(this.gameLoopTimerId); this.gameLoopTimerId = null; }
            updateGame(deltaTime, currentTime) {
                 if (this.state !== GAME_STATES.PLAYING) return;
                 this.enemies.forEach(enemy => enemy.update(deltaTime, this.knightDefenseLine, this.enemyWarningLine, this));
                 this.arrows.forEach(arrow => arrow.update(currentTime));
                 this.powerups.forEach(powerup => powerup.updateTimer(currentTime));
                 const arrowSpawnChance = (CONFIG.ARROW_SPAWN_BASE_CHANCE + (this.wave - 1) * CONFIG.ARROW_SPAWN_WAVE_INCREASE) * (deltaTime / 1000);
                 if (Math.random() < arrowSpawnChance) { this.spawnArrow(); }
            }
            togglePause(forcePauseWithoutMenu = false) {
                 if (this.state === GAME_STATES.GAMEOVER || this.state === GAME_STATES.LOADING || this.state === GAME_STATES.MENU) return;
                 if (this.state === GAME_STATES.PAUSED) { if (!forcePauseWithoutMenu) { this.setState(GAME_STATES.PLAYING); } }
                 else { if (!forcePauseWithoutMenu) { this.setState(GAME_STATES.PAUSED); } else { if (this.state !== GAME_STATES.PAUSED) { this.state = GAME_STATES.PAUSED; this.stopGameLoop(); clearTimeout(this.spawnTimerId); this.spawnTimerId = null; this.audioManager?.setPauseState(true); this.uiManager?.setPauseState(true); this.particleManager?.setPauseState(true); if (this.isMobile) this.dom.mobileInput?.blur(); } } }
            }
            toggleFullscreen() { try { if (!document.fullscreenElement) { this.dom.appContainer?.requestFullscreen().catch((err) => { console.warn("Fullscreen request failed:", err); }); } else { if(document.exitFullscreen) document.exitFullscreen(); } } catch(e) { console.warn("Fullscreen API error:", e); } }
        }

        function cacheDOM() {
             return {
                appContainer: $('#app-container'),
                screens: { menu: $('#main-menu'), game: $('#game-screen'), gameOver: $('#game-over-screen'), pause: $('#pause-menu') },
                buttons: { start: $('#start-button'), playAgain: $('#play-again-button'), mainMenuReturn: $('#main-menu-return-button'), resume: $('#resume-button'), pauseQuit: $('#pause-quit-button'), pauseMenu: $('#pause-menu-button'), pauseFullscreen: $('#pause-fullscreen-button') },
                game: { screen: $('#game-screen'), uiBar: $('#ui-bar'), scoreValue: $('#score-value'), waveValue: $('#wave-value'), healthHearts: $('#health-hearts'), streakValue: $('#streak-value'), inputDisplayArea: $('#input-display-area'), inputDisplay: $('#current-input-display'), gameArea: $('#game-area'), knight: $('#knight'), messageDisplay: $('#message-display'), particleContainer: $('#particle-container'), },
                gameOver: { finalScore: $('#final-score'), finalWave: $('#final-wave'), finalStreak: $('#final-streak'), finalAccuracy: $('#final-accuracy'), },
                highScoreDisplay: $('#high-score-display'),
                loadingIndicator: $('#loading-indicator'),
                mobileInput: $('#mobile-input-hack'),
                audioElements: { bgm: $('#audio-bgm'), coin: $('#audio-sfx-coin'), enemyHit: $('#audio-sfx-enemy-hit'), error: $('#audio-sfx-error'), gameOver: $('#audio-sfx-game-over'), playerDie: $('#audio-sfx-player-die'), playerHurt: $('#audio-sfx-player-hurt'), powerupSpawn: $('#audio-sfx-powerup-spawn'), powerupGet: $('#audio-sfx-powerup-get'), powerupBomb: $('#audio-sfx-powerup-bomb'), powerupFreeze: $('#audio-sfx-powerup-freeze'), powerupHeal: $('#audio-sfx-powerup-heal'), enemyDeadGoblin: $('#audio-sfx-enemy-dead-goblin'), enemyDeadKnight: $('#audio-sfx-enemy-dead-knight'), enemyDeadBoss: $('#audio-sfx-enemy-dead-boss'), hit: $('#audio-sfx-hit'), move: $('#audio-sfx-move'), select: $('#audio-sfx-select'), shoot: $('#audio-sfx-shoot'), startBeep: $('#audio-sfx-start-beep'), success: $('#audio-sfx-success'), streak: $('#audio-sfx-streak'), waveComplete: $('#audio-sfx-wave-complete'), arrowHit: $('#audio-sfx-arrow-hit'), arrowMiss: $('#audio-sfx-arrow-miss'), arrowSpawn: $('#audio-sfx-arrow-spawn'), type: $('#audio-sfx-type') }
             };
        }

        window.addEventListener('DOMContentLoaded', () => {
            try {
                 const domCache = cacheDOM();
                 const game = new Game(domCache);
                 game.init();
                 window.currentGame = game;
            } catch (e) {
                console.error("Fatal error during initial setup:", e);
                document.body.innerHTML = `<div style="color: red; padding: 20px; font-size: 1.5em; font-family: sans-serif;">Fatal Error: ${e.message}<br>Game cannot load. Check console (F12) for details.</div>`;
            }
        });

    })();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Kingsfall Chess</title>
    <style>
        :root {
            --bg-color: #09090b;
            --panel-bg: #18181b;
            --panel-text: #f4f4f5;
            --panel-border: #27272a;
            --button-bg: #27272a;
            --button-hover: #3f3f46;
            --button-text: #ffffff;
            --button-border: #3f3f46;
            --button-transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            --light-square: #eeeed2;
            --dark-square: #769656;
            --highlight-valid: rgba(59, 130, 246, 0.4);
            --highlight-capture: rgba(239, 68, 68, 0.4);
            --highlight-selected: rgba(59, 130, 246, 0.6);
            --highlight-move: rgba(59, 130, 246, 0.7);
            --highlight-last-start: rgba(0, 0, 0, 0.25);
            --highlight-last-end: rgba(255, 215, 0, 0.25);
            --highlight-check: rgba(239, 68, 68, 0.8);
            --grid-line: rgba(255, 255, 255, 0.08);
            --modal-overlay-bg: rgba(0, 0, 0, 0.7);
            --font-primary: 'Inter', system-ui, -apple-system, sans-serif;
            --board-base-size: min(520px, 95vw);
            --panel-width-side: 280px;
            --animation-speed: 0.35s;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--panel-text);
            font-family: var(--font-primary);
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100vw;
            height: 100vh;
            background-color: transparent;
            position: relative;
            perspective: 2000px;
        }


        /* Sprite CSS */
        .wKing {
            background-image: url('sprites/human/wKing.png');
        }

        .wQueen {
            background-image: url('sprites/human/wQueen.png');
        }

        .wRook {
            background-image: url('sprites/human/wRook.png');
        }

        .wBishop {
            background-image: url('sprites/human/wBishop.png');
        }

        .wKnight {
            background-image: url('sprites/human/wKnight.png');
        }

        .wPawn {
            background-image: url('sprites/human/wPawn.png');
        }

        .gKing {
            background-image: url('sprites/goblin/gKing.png');
        }

        .gQueen {
            background-image: url('sprites/goblin/gQueen.png');
        }

        .gRook {
            background-image: url('sprites/goblin/gRook.png');
        }

        .gBishop {
            background-image: url('sprites/goblin/gBishop.png');
        }

        .gKnight {
            background-image: url('sprites/goblin/gKnight.png');
        }

        .gPawn {
            background-image: url('sprites/goblin/gPawn.png');
        }

        .oKing {
            background-image: url('sprites/orc/oKing.png');
        }

        .oQueen {
            background-image: url('sprites/orc/oQueen.png');
        }

        .oRook {
            background-image: url('sprites/orc/oRook.png');
        }

        .oBishop {
            background-image: url('sprites/orc/oBishop.png');
        }

        .oKnight {
            background-image: url('sprites/orc/oKnight.png');
        }

        .oPawn {
            background-image: url('sprites/orc/oPawn.png');
        }

        .uKing {
            background-image: url('sprites/undead/uKing.png');
        }

        .uQueen {
            background-image: url('sprites/undead/uQueen.png');
        }

        .uRook {
            background-image: url('sprites/undead/uRook.png');
        }

        .uBishop {
            background-image: url('sprites/undead/uBishop.png');
        }

        .uKnight {
            background-image: url('sprites/undead/uKnight.png');
        }

        .uPawn {
            background-image: url('sprites/undead/uPawn.png');
        }

        .piece {
            width: 92%;
            height: 92%;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 5;
            cursor: grab;
            transition: transform 0.2s, filter 0.2s, opacity 0.15s;
        }

        .piece:hover {
            filter: brightness(1.25) drop-shadow(0 0 8px rgba(255, 255, 255, 0.4));
            transform: scale(1.05);
            cursor: pointer;
        }

        .piece.selected-piece {
            box-shadow: 0 0 0 4px #3b82f6, 0 0 20px rgba(59, 130, 246, 0.8);
            border-radius: 4px;
            filter: brightness(1.2);
            z-index: 100;
        }

        .square.selected {
            z-index: 50;
            /* Ensure selected square is above its neighbors */
            overflow: visible !important;
        }

        /* Mode Selection UI */
        #mode-selection {
            background-color: var(--panel-bg);
            border-radius: 12px;
            border: 1px solid var(--panel-border);
            width: 90%;
            max-width: 440px;
            padding: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }

        #mode-selection h2 {
            margin: 0 0 32px 0;
            font-size: 2.2rem;
            font-weight: 700;
        }

        .mode-type-selection {
            display: flex;
            width: 100%;
            gap: 12px;
            margin-bottom: 32px;
            flex-wrap: wrap;
        }

        .mode-type-selection button {
            flex: 1;
            padding: 16px;
            font-size: 1.1rem;
            min-width: 120px;
        }

        .mode-type-selection button.selected {
            background-color: #3b82f6;
            border-color: #3b82f6;
            color: #fff;
        }

        #cpu-options-container,
        #race-selection-container {
            display: none;
            flex-direction: column;
            gap: 24px;
            width: 100%;
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid var(--panel-border);
        }

        .menu-section h3 {
            margin: 0 0 12px 0;
            font-size: 0.9rem;
            text-transform: uppercase;
            color: #71717a;
            text-align: center;
        }

        .difficulty-buttons button.selected {
            background-color: #3b82f6;
            border-color: #3b82f6;
            color: #fff;
        }

        .difficulty-buttons {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .race-selector {
            display: flex;
            align-items: center;
            gap: 12px;
            background: #09090b;
            padding: 10px 16px;
            border-radius: 8px;
            border: 1px solid var(--panel-border);
        }

        .race-selector select {
            background: transparent;
            color: #fff;
            border: none;
            font-size: 0.95rem;
            flex-grow: 1;
            cursor: pointer;
            outline: none;
        }

        .race-selector select option {
            background-color: #18181b;
            color: #fff;
        }

        button {
            transition: var(--button-transition);
            cursor: pointer;
        }

        button:hover:not(:disabled) {
            filter: brightness(1.15);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        button:active:not(:disabled) {
            transform: translateY(0);
            filter: brightness(0.95);
        }

        .race-selector {
            transition: var(--button-transition);
        }

        .race-selector:hover {
            border-color: #3b82f6;
            background: #111114;
        }

        .race-selector img {
            width: 32px;
            height: 32px;
            border-radius: 4px;
        }

        #start-game-button {
            width: 100%;
            margin-top: 32px;
            padding: 18px;
            font-size: 1.25rem;
            font-weight: 600;
            background-color: #3b82f6;
            border-color: #3b82f6;
        }

        #start-game-button:disabled {
            background-color: #27272a;
            border-color: #27272a;
            color: #52525b;
        }

        /* Board Styling */
        #board-and-panels {
            display: flex;
            flex-direction: column;
            align-items: center;
            transform-style: preserve-3d;
            transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Flip is now handled logically in JS */

        #board {
            width: var(--board-base-size);
            height: var(--board-base-size);
            display: grid;
            grid-template-columns: repeat(var(--board-cols, 8), 1fr);
            grid-template-rows: repeat(var(--board-rows, 8), 1fr);
            background-color: var(--dark-square);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            transform-style: preserve-3d;
        }

        .obstacle,
        .coin-pickup {
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            opacity: 1;
        }

        .obstacle {
            background-image: url('sprites/wall.png');
        }

        .coin-pickup {
            background-image: url('sprites/coin.png');
            width: 35%;
            height: 35%;
            animation: pulse-coin 2s infinite ease-in-out;
        }

        @keyframes pulse-coin {

            0%,
            100% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(1.1);
                filter: brightness(1.2);
            }
        }

        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            transform-style: preserve-3d;
            box-sizing: border-box;
            border: 0.5px solid var(--grid-line);
        }

        .square.light {
            background-color: var(--light-square);
        }

        .square.dark {
            background-color: var(--dark-square);
        }

        /* No 3D flip for pieces */

        .piece.elite {
            filter: hue-rotate(240deg) brightness(1.2) contrast(1.1) drop-shadow(0 0 5px rgba(168, 85, 247, 0.4));
        }

        .piece.enemy-reskin {
            filter: brightness(0.8) sepia(1) hue-rotate(-50deg) saturate(3);
        }

        /* Highlights */
        .selected {
            background-color: var(--highlight-selected) !important;
        }

        .highlight::after {
            content: '';
            width: 40%;
            height: 40%;
            background: var(--highlight-move);
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
            pointer-events: none;
            /* Crucial for tooltips to pass through */
        }

        .highlight.capture {
            box-shadow: inset 0 0 0 4px var(--highlight-capture) !important;
        }

        .highlight.capture::after {
            display: none;
        }

        .check {
            box-shadow: inset 0 0 25px var(--highlight-check) !important;
        }

        .last-move-start::before,
        .last-move-end::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1;
            pointer-events: none;
        }

        .last-move-start::before {
            background-color: var(--highlight-last-start);
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.6);
        }

        .last-move-end::before {
            background-color: var(--highlight-last-end);
            box-shadow: inset 0 0 15px rgba(255, 215, 0, 0.35);
            border: 2px solid rgba(255, 215, 0, 0.5);
            box-sizing: border-box;
        }

        .scout-highlight::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(239, 68, 68, 0.3);
            border: 2px dashed rgba(239, 68, 68, 0.8);
            pointer-events: none;
            z-index: 5;
        }

        .side-header.side-gold {
            background: linear-gradient(135deg, #fbbf24 0%, #d97706 100%);
            color: #000;
            text-shadow: none;
        }

        .piece.has-bounty {
            filter: drop-shadow(0 0 5px #fbbf24);
        }

        .piece.shielded {
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.8);
            animation: shield-pulse 1s infinite;
        }

        @keyframes shield-pulse {

            0%,
            100% {
                box-shadow: 0 0 10px rgba(251, 191, 36, 0.6);
            }

            50% {
                box-shadow: 0 0 20px rgba(251, 191, 36, 1);
            }
        }

        .piece.frozen {
            filter: brightness(0.8) saturate(1.5) hue-rotate(180deg) drop-shadow(0 0 10px cyan);
            animation: freeze-pulse 1.5s infinite;
        }

        @keyframes freeze-pulse {

            0%,
            100% {
                filter: brightness(0.8) saturate(1.5) hue-rotate(180deg) drop-shadow(0 0 8px cyan);
            }

            50% {
                filter: brightness(1) saturate(1.2) hue-rotate(190deg) drop-shadow(0 0 15px cyan);
            }
        }

        .obstacle.temp-wall {
            filter: hue-rotate(190deg) saturate(2) brightness(1.3);
            box-shadow: 0 0 20px rgba(0, 100, 255, 0.8), inset 0 0 10px rgba(100, 180, 255, 0.5);
        }

        /* Panel Styling */
        #panel {
            width: var(--board-base-size);
            background-color: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-top: none;
            padding: 24px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 20px;
            transform-style: preserve-3d;
        }

        #spells-section {
            margin-top: 15px;
            display: none;
        }

        #active-spells-list {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            justify-items: center;
        }

        .spell-btn {
            position: relative;
            width: 100px;
            height: 100px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .spell-btn:hover {
            border-color: #fbbf24;
            background: rgba(251, 191, 36, 0.1);
            transform: translateY(-4px);
        }

        .spell-btn.active {
            border-color: #fbbf24;
            background: rgba(251, 191, 36, 0.2);
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.4);
        }

        .spell-count-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #d97706;
            color: white;
            font-size: 0.9rem;
            font-weight: 700;
            padding: 4px 8px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .shield-effect {
            position: absolute;
            inset: 0;
            border: 4px solid #3b82f6;
            border-radius: 8px;
            box-shadow: inset 0 0 15px #3b82f6;
            pointer-events: none;
            z-index: 10;
            animation: pulse-blue 2s infinite;
        }

        @keyframes pulse-blue {

            0%,
            100% {
                opacity: 0.6;
            }

            50% {
                opacity: 1;
            }
        }

        .freeze-effect {
            position: absolute;
            inset: 0;
            background: rgba(147, 197, 253, 0.4);
            border: 2px solid #60a5fa;
            border-radius: 4px;
            pointer-events: none;
            z-index: 10;
            backdrop-filter: blur(1px);
        }

        .piece-preview {
            opacity: 0.4;
            filter: grayscale(0.5) brightness(1.2);
            pointer-events: none;
            z-index: 5;
        }

        .area-preview {
            pointer-events: none !important;
            box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.1) !important;
        }

        .area-preview.shield {
            background: rgba(59, 130, 246, 0.2) !important;
            border: 1px dashed #3b82f6 !important;
        }

        .area-preview.freeze {
            background: rgba(147, 197, 253, 0.2) !important;
            border: 1px dashed #60a5fa !important;
        }

        .area-preview.swap,
        .area-preview.summon,
        .area-preview.fortify {
            background: rgba(251, 191, 36, 0.2) !important;
            border: 1px dashed #fbbf24 !important;
        }

        #board.spell-active .piece,
        #board.spell-active .shield-effect,
        #board.spell-active .freeze-effect,
        #board.spell-active .scout-highlight,
        #board.spell-active .obstacle,
        #board.spell-active .coin-pickup {
            pointer-events: none !important;
        }

        #current-level-display {
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #3b82f6;
            font-weight: 700;
            text-align: center;
            margin-bottom: -10px;
        }

        #status {
            font-size: 1.25rem;
            font-weight: 600;
            text-align: center;
        }

        #captured-pieces-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 50px;
            padding: 10px;
            background: #09090b;
            border-radius: 8px;
        }

        .captured-list {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            min-height: 20px;
        }

        .captured-piece {
            width: 20px;
            height: 20px;
            background-size: contain;
            background-repeat: no-repeat;
        }

        #panel-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .button-group {
            display: flex;
            gap: 8px;
        }

        .button-group button {
            flex: 1;
            padding: 12px;
            font-size: 0.9rem;
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--modal-overlay-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
            backdrop-filter: blur(8px);
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--panel-bg);
            padding: 40px;
            border-radius: 16px;
            border: 1px solid var(--panel-border);
            text-align: center;
            width: 90%;
            max-width: 400px;
            max-height: 85vh;
            overflow-y: auto;
        }

        /* Online Lobby Styles */
        .lobby-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 20px 0;
            max-height: 300px;
            overflow-y: auto;
            padding-right: 5px;
        }

        .lobby-player {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            transition: all 0.2s;
        }

        .lobby-player:hover {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.1);
        }

        .lobby-player span {
            font-weight: 600;
        }

        .lobby-player button {
            padding: 6px 12px;
            font-size: 0.85rem;
            background: #3b82f6;
            border-color: #3b82f6;
        }

        .lobby-player button:disabled {
            background: #27272a;
            border-color: #27272a;
            opacity: 0.6;
        }

        .form-input {
            width: 100%;
            padding: 12px;
            background: #09090b;
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            color: #fff;
            margin-bottom: 20px;
            font-size: 1rem;
            outline: none;
            box-sizing: border-box;
        }

        .form-input:focus {
            border-color: #3b82f6;
        }

        #invite-toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            border: 1px solid #3b82f6;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            z-index: 3000;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            min-width: 280px;
        }

        body.layout-desktop #game-container {
            flex-direction: row;
        }

        body.layout-desktop #board-and-panels {
            flex-direction: row;
        }

        body.layout-desktop #panel {
            width: var(--panel-width-side);
            height: var(--board-base-size);
            border-top: 1px solid var(--panel-border);
            border-left: none;
        }

        button {
            border: 1px solid var(--button-border);
            background: var(--button-bg);
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
        }

        button:hover:not(:disabled) {
            background: var(--button-hover);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .moving-piece {
            position: fixed;
            z-index: 1000;
            pointer-events: none;
            background-size: contain;
            transition: transform var(--animation-speed) cubic-bezier(0.23, 1, 0.32, 1);
        }

        #promotion-options {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .promotion-choice {
            width: 60px;
            height: 60px;
            cursor: pointer;
            background-size: contain;
            background-repeat: no-repeat;
            transition: transform 0.2s;
        }

        .promotion-choice:hover {
            transform: scale(1.1);
        }

        /* Shop Modal */
        #shop-modal .modal-content {
            max-width: 600px;
            background: linear-gradient(to bottom, #18181b, #09090b);
            border: 1px solid #71717a;
        }

        .shop-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 1px solid #27272a;
            padding-bottom: 10px;
        }

        .shop-tab {
            padding: 8px 16px;
            cursor: pointer;
            color: #71717a;
            font-weight: 600;
            transition: all 0.2s;
        }

        .shop-tab.active {
            color: #fbbf24;
            border-bottom: 2px solid #fbbf24;
        }

        .shop-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 15px;
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
        }

        .shop-item {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid #27272a;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            transition: transform 0.2s, border-color 0.2s;
        }

        .shop-item:hover {
            transform: translateY(-4px);
            border-color: #3f3f46;
        }

        .shop-item h4 {
            margin: 0 0 5px 0;
            color: #fff;
            font-size: 1rem;
        }

        .shop-item p {
            margin: 0 0 15px 0;
            font-size: 0.75rem;
            color: #a1a1aa;
            line-height: 1.3;
        }

        .shop-item .price {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            font-weight: 700;
            color: #fbbf24;
            margin-bottom: 12px;
        }

        .shop-item .price img {
            width: 14px;
            height: 14px;
        }

        .shop-item button {
            width: 100%;
            padding: 8px;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
        }

        .shop-item button.buy {
            background: #fbbf24;
            color: #000;
            border: none;
        }

        .shop-item button.owned {
            background: transparent;
            border: 1px solid #27272a;
            color: #71717a;
            cursor: default;
        }

        .shop-item button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Campaign Styles */
        #campaign-map {
            display: none;
            flex-direction: column;
            gap: 20px;
            width: 100%;
            max-width: 500px;
            padding: 20px;
            background: var(--panel-bg);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid var(--panel-border);
        }

        #level-list {
            display: flex;
            flex-direction: column;
            gap: 24px;
            max-height: 550px;
            overflow-y: auto;
            padding: 15px;
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            scrollbar-width: thin;
            scrollbar-color: #3b82f6 rgba(0, 0, 0, 0.2);
        }

        .campaign-chapter {
            width: 100%;
        }

        .chapter-header {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: #3b82f6;
            font-weight: 800;
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(59, 130, 246, 0.3);
        }

        .chapter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 10px;
        }

        .campaign-level {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: flex-start;
            padding: 10px 16px;
            background: #09090b;
            border: 1px solid var(--panel-border);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            min-height: 50px;
            gap: 15px;
        }

        .level-number {
            font-size: 1.1rem;
            font-weight: 800;
            color: #3b82f6;
            min-width: 25px;
        }

        .level-title {
            font-size: 0.95rem;
            font-weight: 500;
            color: #e4e4e7;
            flex-grow: 1;
        }

        .campaign-level:hover:not(.locked) {
            border-color: #3b82f6;
            background: #111827;
            transform: translateY(-2px);
        }

        .campaign-level.completed {
            border-color: rgba(16, 185, 129, 0.4);
            background: rgba(16, 185, 129, 0.05);
        }

        .campaign-level.completed .level-number {
            color: #10b981;
        }

        .campaign-level.completed:hover {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.1);
        }

        .campaign-level.active {
            border-color: #fbbf24;
            background: rgba(251, 191, 36, 0.05);
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.1);
        }

        .campaign-level.active .level-number {
            color: #fbbf24;
        }

        .campaign-level.active:hover {
            border-color: #fbbf24;
            background: rgba(251, 191, 36, 0.1);
        }

        .campaign-level.locked {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(1);
        }

        .level-number {
            font-size: 0.8rem;
            font-weight: 700;
            color: #3b82f6;
            opacity: 0.8;
            margin-bottom: 4px;
        }

        .level-title {
            font-size: 0.85rem;
            font-weight: 600;
            line-height: 1.2;
            color: #e4e4e7;
            text-align: left;
            word-break: break-word;
        }

        .xp-bar-container {
            width: 100%;
            height: 8px;
            background: #27272a;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        #xp-bar-fill {
            height: 100%;
            background: #3b82f6;
            width: 0%;
            transition: width 0.5s ease-out;
        }

        #campaign-stats {
            text-align: center;
            margin-bottom: 20px;
        }

        .tileset-selector {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 10px;
        }

        .tileset-btn {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            background-size: cover;
            border: 2px solid transparent;
            cursor: pointer;
        }

        .tileset-btn.selected {
            border-color: #3b82f6;
        }

        .tileset-btn.locked {
            filter: brightness(0.3) grayscale(1);
            position: relative;
        }

        .tileset-btn.locked::after {
            content: 'ðŸ”’';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
        }

        #tooltip {
            position: fixed;
            background: rgba(9, 9, 11, 0.95);
            color: #f4f4f5;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            pointer-events: none;
            z-index: 10000;
            border: 1px solid #3f3f46;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            visibility: hidden;
            font-weight: 500;
            white-space: nowrap;
        }

        #tooltip {
            position: fixed;
            background: rgba(9, 9, 11, 0.98);
            color: #f4f4f5;
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 0.85rem;
            pointer-events: none;
            z-index: 10000;
            border: 1px solid #3f3f46;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
            visibility: hidden;
            font-weight: 400;
            white-space: nowrap;
            font-family: var(--font-primary);
            line-height: 1.4;
            backdrop-filter: blur(4px);
        }

        #tooltip .side-header {
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 2px;
        }

        #tooltip .side-white {
            color: #60a5fa;
        }

        #tooltip .side-black {
            color: #f87171;
        }

        #tooltip .piece-info {
            font-weight: 500;
            font-size: 0.9rem;
            color: #fff;
        }
    </style>
</head>

<body>
    <div id="tooltip"></div>
    <div id="game-container">
        <div id="mode-selection">
            <h2>Kingsfall Chess</h2>
            <div class="mode-type-selection">
                <button id="mode-cpu">1 Player</button>
                <button id="mode-2p">2 Players (Local)</button>
                <button id="mode-online" style="border-color: #fbbf24; background: rgba(251, 191, 36, 0.1);">Online
                    Multiplayer</button>
            </div>
            <button id="mode-campaign"
                style="width: 100%; margin: 15px 0; padding: 18px; font-size: 1.2rem; border-color: #3b82f6; background: rgba(59, 130, 246, 0.1); font-weight: 700;">Adventure
                Mode</button>

            <div id="race-selection-container">
                <div class="menu-section">
                    <h3>Factions</h3>
                    <div class="race-selector">
                        <label>White</label>
                        <select id="white-race-select">
                            <option value="human" selected>Human</option>
                            <option value="goblin">Goblin</option>
                            <option value="orc">Orc</option>
                            <option value="undead">Undead</option>
                        </select>
                        <img id="white-race-preview" src="">
                    </div>
                    <div class="race-selector">
                        <label>Black</label>
                        <select id="black-race-select">
                            <option value="human">Human</option>
                            <option value="goblin" selected>Goblin</option>
                            <option value="orc">Orc</option>
                            <option value="undead">Undead</option>
                        </select>
                        <img id="black-race-preview" src="">
                    </div>
                </div>
                <div class="menu-section">
                    <h3>Board Theme</h3>
                    <div class="tileset-selector" id="tileset-container">
                        <!-- Themes will be injected here -->
                    </div>
                </div>
            </div>

            <div id="cpu-options-container">
                <div class="menu-section">
                    <h3>Difficulty</h3>
                    <div class="difficulty-buttons">
                        <button data-difficulty="CPU-easy">Easy</button>
                        <button data-difficulty="CPU-medium">Normal</button>
                        <button data-difficulty="CPU-hard">Hard</button>
                    </div>
                </div>
            </div>

            <button id="start-game-button" onclick="startGame()" disabled>Begin Conquest</button>
        </div>

        <div id="campaign-map"
            style="display: none; background-color: var(--panel-bg); border-radius: 12px; border: 1px solid var(--panel-border); width: 95%; max-width: 800px; padding: 30px; flex-direction: column; align-items: center; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);">
            <div id="campaign-stats">
                <div id="campaign-rank">Rank: Novice</div>
                <div class="xp-bar-container">
                    <div id="xp-bar-fill"></div>
                </div>
                <div id="xp-text" style="font-size: 0.8rem; color: #71717a; margin-top: 4px;">0 / 100 XP</div>
                <div id="campaign-coins"
                    style="margin-top: 10px; font-weight: 700; color: #fbbf24; display: flex; align-items: center; gap: 8px;">
                    <img src="sprites/coin.png" style="width: 20px; height: 20px;">
                    <span id="coin-count">0</span> Gold
                </div>
                <button onclick="toggleShop(true)"
                    style="margin-top: 15px; width: 100%; padding: 12px; background: rgba(251, 191, 36, 0.1); border: 1px solid #fbbf24; color: #fbbf24; font-weight: 700; border-radius: 8px; cursor: pointer;">Open
                    Kingsfall Emporium</button>
            </div>
            <div id="level-list" style="width: 100%;">
                <!-- Levels will be injected here -->
            </div>
            <button onclick="hideCampaignMap()" style="width: 100%; margin-top: 20px; padding: 12px;">Back to
                Menu</button>
        </div>

        <div id="game-area" style="display: none;">
            <div id="board-and-panels">
                <div id="board"></div>
                <div id="panel">
                    <div id="current-level-display">Level 1: Goblin Outpost</div>
                    <div id="status">Your Turn</div>
                    <div id="player-rating-display"
                        style="text-align: center; color: #71717a; font-size: 0.85rem; margin-top: -10px;">Rating: <span
                            id="rating-value">1000</span></div>
                    <div id="game-coin-display"
                        style="text-align: center; color: #fbbf24; font-weight: 700; margin-top: 5px; font-size: 0.9rem; display: none;">
                        <img src="sprites/coin.png"
                            style="width: 16px; height: 16px; vertical-align: middle; margin-right: 4px;">
                        <span class="coin-count-global">0</span> Gold
                    </div>
                    <div id="captured-pieces-container">
                        <div id="white-captured" class="captured-list"></div>
                        <div id="black-captured" class="captured-list"></div>
                    </div>
                    <div id="panel-buttons">
                        <div class="button-group">
                            <button id="undo-button" onclick="undoMove()">Undo</button>
                            <button id="flip-board-button" onclick="flipBoardView()">Flip</button>
                            <button onclick="toggleOptionsMenu()">Menu</button>
                        </div>
                        <div class="button-group">
                            <button id="resign-button" onclick="resignGame()">Resign</button>
                        </div>
                    </div>
                    <div id="spells-section" class="menu-section" style="margin-top: 15px; display: none;">
                        <h3 style="font-size: 0.9rem; margin-bottom: 10px; color: #fbbf24;">Tactical Spells</h3>
                        <div id="active-spells-list">
                            <!-- Spells will be injected here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="options-menu" class="modal-overlay">
        <div class="modal-content">
            <h2>Game Menu</h2>
            <button onclick="quitGame()" style="width: 100%; margin-bottom: 12px; padding: 14px;">Quit Match</button>
            <button onclick="toggleOptionsMenu(false)" style="width: 100%; padding: 14px;">Back to Battle</button>
        </div>
    </div>

    <div id="game-over-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="modal-title">Game Over</h2>
            <p id="modal-message"></p>
            <div id="game-over-buttons" style="display: flex; gap: 12px; justify-content: center; margin-top: 20px;">
                <button id="modal-undo-button" onclick="undoAndCloseModal()"
                    style="padding: 14px 28px; display: none; background: #3b82f6;">Undo Move</button>
                <button id="modal-back-to-map" onclick="quitToMap()" style="padding: 14px 28px; display: none;">Back to
                    Map</button>
                <button id="modal-next-level" onclick="goToNextLevel()"
                    style="padding: 14px 28px; display: none; background: #10b981;">Next Level</button>
                <button id="modal-main-menu" onclick="location.reload()" style="padding: 14px 28px;">Main Menu</button>
            </div>
        </div>
    </div>

    <div id="promotion-modal" class="modal-overlay">
        <div class="modal-content">
            <h2>Pawn Ascension</h2>
            <div id="promotion-options"></div>
        </div>
    </div>

    <div id="shop-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 style="color: #fbbf24; margin-top: 0;">Kingsfall Emporium</h2>
            <div class="shop-tabs">
                <div class="shop-tab active" onclick="switchShopTab('spells')">Tactical Spells</div>
                <div class="shop-tab" onclick="switchShopTab('upgrades')">Upgrades</div>
                <div class="shop-tab" onclick="switchShopTab('themes')">Board Themes</div>
            </div>
            <div id="shop-content" class="shop-grid">
                <!-- Shop items will be injected here -->
            </div>
            <div id="shop-gold-display"
                style="text-align: center; color: #fbbf24; font-weight: 700; font-size: 1.1rem; margin-top: 15px; padding: 12px; background: rgba(251, 191, 36, 0.1); border-radius: 8px; border: 1px solid rgba(251, 191, 36, 0.3);">
                <img src="sprites/coin.png"
                    style="width: 20px; height: 20px; vertical-align: middle; margin-right: 6px;"><span
                    id="shop-gold-amount">0</span> Gold Available
            </div>
            <div style="margin-top: 20px; text-align: right;">
                <button onclick="toggleShop(false)" style="padding: 10px 20px;">Exit Emporium</button>
            </div>
        </div>
    </div>

    <!-- Online Multiplayer Modals -->
    <div id="name-modal" class="modal-overlay">
        <div class="modal-content">
            <h2>Warrior's Name</h2>
            <p style="color: #a1a1aa; margin-bottom: 20px;">Enter your name to join the online lobby.</p>
            <input type="text" id="player-name-input" class="form-input" placeholder="Your Name" maxlength="15">
            <button id="join-online-btn" style="width: 100%; padding: 14px; background: #3b82f6;">Join Lobby</button>
            <button onclick="toggleModal('name-modal', false)"
                style="width: 100%; padding: 14px; margin-top: 10px; background: transparent; border-color: var(--panel-border);">Cancel</button>
        </div>
    </div>

    <div id="lobby-modal" class="modal-overlay">
        <div class="modal-content">
            <h2>Online Lobby</h2>
            <div id="lobby-status" style="font-size: 0.85rem; color: #3b82f6; margin-bottom: 10px;">Connected as: <span
                    id="my-name-display">-</span></div>
            <div class="lobby-list" id="player-list">
                <!-- Players will be injected here -->
                <div style="color: #71717a; padding: 20px;">Searching for other warriors...</div>
            </div>
            <button onclick="quitLobby()"
                style="width: 100%; padding: 14px; background: transparent; border-color: var(--panel-border);">Leave
                Lobby</button>
        </div>
    </div>

    <div id="invite-toast">
        <div style="font-weight: 700; font-size: 1.1rem;"><span id="inviter-name" style="color: #fbbf24;">Player</span>
            invites you!</div>
        <div style="display: flex; gap: 10px; width: 100%;">
            <button id="accept-invite-btn" style="flex: 1; padding: 12px; background: #10b981;">Accept</button>
            <button id="decline-invite-btn" style="flex: 1; padding: 12px; background: #ef4444;">Decline</button>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyAElkOkD_bLyrQ2WEkRuxzBM2wNa6Lf2OA",
            authDomain: "kingsfallchess.firebaseapp.com",
            databaseURL: "https://kingsfallchess-default-rtdb.firebaseio.com",
            projectId: "kingsfallchess",
            storageBucket: "kingsfallchess.firebasestorage.app",
            messagingSenderId: "437968448738",
            appId: "1:437968448738:web:d9073c849ec740d76382bb",
            measurementId: "G-NM1EW60BDP"
        };

        let db = null;
        let onlinePlayerId = null;
        let onlinePlayerName = "";
        let currentGameId = null;
        let isOnlineGame = false;
        let onlinePlayerColor = 'w';
        let invitationRef = null;

        function initFirebase() {
            if (db) return true;
            try {
                const app = firebase.initializeApp(firebaseConfig);
                db = firebase.database();
                return true;
            } catch (e) {
                console.error("Firebase init error:", e);
                return false;
            }
        }

        function toggleModal(id, show) {
            document.getElementById(id).classList.toggle('visible', show);
        }

        // Online Mode Initialization
        document.getElementById('mode-online').onclick = () => {
            if (!initFirebase()) return;
            toggleModal('name-modal', true);
        };

        document.getElementById('join-online-btn').onclick = async () => {
            const nameInput = document.getElementById('player-name-input');
            const name = nameInput.value.trim();
            if (!name) return alert("Please enter a name.");

            onlinePlayerName = name;
            document.getElementById('my-name-display').textContent = name;

            try {
                const user = await firebase.auth().signInAnonymously();
                onlinePlayerId = user.user.uid;

                // Register in lobby
                const playerRef = db.ref('lobby/' + onlinePlayerId);
                playerRef.set({
                    name: onlinePlayerName,
                    status: 'available',
                    lastSeen: firebase.database.ServerValue.TIMESTAMP
                });

                // Remove on disconnect
                playerRef.onDisconnect().remove();

                toggleModal('name-modal', false);
                toggleModal('lobby-modal', true);
                listenToLobby();
                listenToInvites();
            } catch (e) {
                console.error("Lobby join error:", e);
                alert("Failed to join lobby.");
            }
        };

        function listenToLobby() {
            db.ref('lobby').on('value', (snapshot) => {
                const players = snapshot.val() || {};
                const listEl = document.getElementById('player-list');
                listEl.innerHTML = '';

                let count = 0;
                for (let id in players) {
                    if (id === onlinePlayerId) continue;
                    const p = players[id];
                    if (p.status !== 'available') continue;

                    count++;
                    const div = document.createElement('div');
                    div.className = 'lobby-player';
                    div.innerHTML = `
                        <span>${p.name}</span>
                        <button onclick="sendInvite('${id}', '${p.name}')">Invite</button>
                    `;
                    listEl.appendChild(div);
                }

                if (count === 0) {
                    listEl.innerHTML = '<div style="color: #71717a; padding: 20px;">Searching for other warriors...</div>';
                }
            });
        }

        function sendInvite(targetId, targetName) {
            db.ref('invites/' + targetId).set({
                fromId: onlinePlayerId,
                fromName: onlinePlayerName,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            });
            alert("Invite sent to " + targetName);
        }

        function listenToInvites() {
            invitationRef = db.ref('invites/' + onlinePlayerId);
            invitationRef.on('value', (snapshot) => {
                const invite = snapshot.val();
                if (invite) {
                    document.getElementById('inviter-name').textContent = invite.fromName;
                    document.getElementById('invite-toast').style.display = 'flex';

                    document.getElementById('accept-invite-btn').onclick = () => acceptInvite(invite);
                    document.getElementById('decline-invite-btn').onclick = () => declineInvite();
                }
            });

            // Listen for accepted games
            db.ref('games').on('child_added', (snapshot) => {
                const game = snapshot.val();
                if (game.white === onlinePlayerId || game.black === onlinePlayerId) {
                    startOnlineGame(snapshot.key, game);
                }
            });
        }

        function acceptInvite(invite) {
            const gameId = 'game_' + Math.random().toString(36).substr(2, 9);
            const gameData = {
                white: invite.fromId, // Inviter is white
                black: onlinePlayerId, // Invitee is black
                whiteName: invite.fromName,
                blackName: onlinePlayerName,
                status: 'playing',
                currentPlayer: 'w',
                boardSeed: Math.random() // Seed for identical random coins
            };

            db.ref('games/' + gameId).set(gameData);
            db.ref('invites/' + onlinePlayerId).remove();
            document.getElementById('invite-toast').style.display = 'none';
        }

        function declineInvite() {
            db.ref('invites/' + onlinePlayerId).remove();
            document.getElementById('invite-toast').style.display = 'none';
        }

        function quitLobby() {
            if (onlinePlayerId) {
                db.ref('lobby/' + onlinePlayerId).remove();
                if (invitationRef) invitationRef.off();
                db.ref('lobby').off();
                db.ref('games').off();
            }
            toggleModal('lobby-modal', false);
        }

        function startOnlineGame(gameId, data) {
            currentGameId = gameId;
            isOnlineGame = true;
            onlinePlayerColor = (data.white === onlinePlayerId) ? 'w' : 'b';

            // Set global game state
            gameMode = 'ONLINE';
            playerColor = onlinePlayerColor;

            // Designate random seed if needed (for coins)
            this.onlineBoardSeed = data.boardSeed;

            // Hide UI
            toggleModal('lobby-modal', false);
            document.getElementById('mode-selection').style.display = 'none';
            document.getElementById('game-area').style.display = 'block';

            // Mark as busy in lobby
            db.ref('lobby/' + onlinePlayerId + '/status').set('playing');

            // Set up board and sync
            setupBoard();
            listenToMoves();
        }

        function listenToMoves() {
            db.ref('games/' + currentGameId + '/moves').on('child_added', (snapshot) => {
                const move = snapshot.val();
                if (move.player !== onlinePlayerColor) {
                    // Execute move from other player
                    executeMove(move.sr, move.sc, move.er, move.ec, true);
                }
            });

            // Listen for resign/exit
            db.ref('games/' + currentGameId + '/status').on('value', (snapshot) => {
                if (snapshot.val() === 'resigned' && !gameOver) {
                    const winner = onlinePlayerColor === 'w' ? 'White' : 'Black';
                    showGameOverModal('Opponent Resigned', winner + ' Wins!');
                    gameOver = true;
                }
            });
        }
    </script>

    <script>
        // --- CHESS ENGINE & LOGIC ---
        let board = [], currentPlayer = 'w', playerColor = 'w', boardOrientation = 'w';
        let currentlyDragging = { isDragging: false, pieceElement: null, startRow: -1, startCol: -1, pieceCode: null, validMoves: [] };
        let validMoves = [], kingPositions = { w: null, b: null }, checkStatus = { w: false, b: false };
        let castlingRights = { w: { K: true, Q: true }, b: { K: true, Q: true } }, enPassantTarget = null;
        let selectedSquare = null;
        let activeSpell = null, spellTargets = [];
        let enemyKingBounty = 0;
        let justDragged = false;
        let tempWalls = []; // { row, col, turnsLeft }
        let shieldedPieces = []; // [{ row, col, turnsLeft }]
        let frozenPieces = []; // [{ row, col, turnsLeft }]

        function handleSquareClick(e) {
            if (justDragged) return;
            if (currentlyDragging.isDragging || isAnimating || isComputerTurn || gameOver) return;

            // Critical: If a spell is active, we handle it on mousedown and prevent the 'click' event 
            // from triggering piece selection on the same square.
            if (activeSpell) {
                if (e.type === 'mousedown') {
                    const sq = e.target.closest('.square');
                    if (sq) {
                        const r = parseInt(sq.dataset.row), c = parseInt(sq.dataset.col);
                        handleSpellClick(r, c);
                    }
                    e.preventDefault();
                    e.stopPropagation();
                }
                return;
            }

            // Normal moves only on 'click'
            if (e.type === 'mousedown') return;

            const sq = e.target.closest('.square');
            if (!sq) return;
            const r = parseInt(sq.dataset.row), c = parseInt(sq.dataset.col);

            const clickedPiece = board[r][c];

            if (selectedSquare) {
                // Try to move to clicked square
                const move = validMoves.find(m => m.row === r && m.col === c);
                if (move) {
                    executeMove(selectedSquare.row, selectedSquare.col, r, c);
                    clearSelection();
                } else if (clickedPiece && clickedPiece[0] === currentPlayer) {
                    // Select a different piece
                    selectPiece(r, c, clickedPiece);
                } else {
                    clearSelection();
                }
            } else {
                // Select a piece
                if (clickedPiece && clickedPiece[0] === currentPlayer) {
                    selectPiece(r, c, clickedPiece);
                }
            }
        }

        function selectPiece(r, c, piece) {
            clearSelection();
            selectedSquare = { row: r, col: c };
            validMoves = calculateValidMoves(r, c, piece);
            const sq = boardElement.querySelector(`.square[data-row="${r}"][data-col="${c}"]`);
            if (sq) {
                sq.classList.add('selected');
                const pieceEl = sq.querySelector('.piece');
                if (pieceEl) pieceEl.classList.add('selected-piece');
            }
            highlightValidMoves();
        }

        function clearSelection() {
            selectedSquare = null;
            validMoves = [];
            document.querySelectorAll('.square.selected').forEach(el => el.classList.remove('selected'));
            document.querySelectorAll('.piece.selected-piece').forEach(el => el.classList.remove('selected-piece'));
            document.querySelectorAll('.square.highlight, .square.capture').forEach(el => el.classList.remove('highlight', 'capture'));
        }
        let isComputerTurn = false, gameOver = false, capturedPieces = { w: [], b: [] }, lastMove = { start: null, end: null };
        let moveHistory = [], isAnimating = false, playerRating = parseInt(localStorage.getItem('playerRating')) || 1000, gameMode = null;
        let computerMoveTimeout = null;
        let scoutActiveTurns = 0;
        let spellCooldowns = { swap: 0, summon: 0, fortify: 0, scout: 0, shield: 0, freeze: 0 };
        let hoveredSquare = null; // { r, c }

        // CPU Ratings by difficulty
        const cpuRatings = { 'CPU-easy': 800, 'CPU-medium': 1200, 'CPU-hard': 1600 };

        // ELO Calculation
        function calculateElo(playerRating, opponentRating, playerWon, isDraw = false) {
            const K = 32; // K-factor for rating adjustment
            const expectedScore = 1 / (1 + Math.pow(10, (opponentRating - playerRating) / 400));
            const actualScore = isDraw ? 0.5 : (playerWon ? 1 : 0);
            return Math.round(playerRating + K * (actualScore - expectedScore));
        }

        function updatePlayerRating(playerWon, isDraw = false) {
            if (gameMode === 'CAMPAIGN' || gameMode === '2P') return; // Only update for CPU games
            const diff = currentDifficulty;
            const opponentRating = cpuRatings[diff] || 1200;
            playerRating = calculateElo(playerRating, opponentRating, playerWon, isDraw);
            localStorage.setItem('playerRating', playerRating);
            updateRatingDisplay();
        }

        function updateRatingDisplay() {
            const ratingEl = document.getElementById('rating-value');
            if (ratingEl) ratingEl.textContent = playerRating;
            // Hide rating in Campaign mode
            const ratingContainer = document.getElementById('player-rating-display');
            if (ratingContainer) ratingContainer.style.display = gameMode === 'CAMPAIGN' ? 'none' : 'block';
        }
        let whiteRace = 'human', blackRace = 'goblin', promotionState = { active: false, row: -1, col: -1, callback: null };
        let selectedTileset = 'classic';
        let campaignLevel = null;

        const campaignLevels = [
            // GOBLIN CAMPAIGN (1-10)
            { id: 1, title: "Goblin Outpost", enemy: 'goblin', difficulty: 'CPU-easy', tileset: 'tile_grass.png', rows: 4, cols: 4, setup: [['br', 'bk', null, null], [null, null, null, null], ['wr', null, 'wp', null], [null, null, 'wk', null]], reward: "+100 XP", xp: 100 },
            { id: 2, title: "Rocky Path", enemy: 'goblin', difficulty: 'CPU-easy', tileset: 'tile_stone.png', rows: 4, cols: 4, setup: [['bp', 'bk', 'bp', null], [null, 'X', null, null], [null, null, 'X', null], [null, 'wk', null, 'wr']], reward: "+50 XP", xp: 50 },
            { id: 3, title: "Goblin Den", enemy: 'goblin', difficulty: 'CPU-easy', tileset: 'tile_grass.png', rows: 4, cols: 4, setup: [['bb', 'bk', 'bb', null], ['bp', 'bp', 'bp', null], [null, null, null, null], ['wr', 'wk', 'wr', null]], reward: "+60 XP", xp: 60 },
            { id: 4, title: "Muddy Banks", enemy: 'goblin', difficulty: 'CPU-medium', tileset: 'tile_grass.png', rows: 6, cols: 6, setup: [[null, 'br', 'bk', 'br', null, null], [null, 'bp', 'bp', 'bp', null, null], ['X', null, null, null, null, 'X'], ['X', null, null, null, null, 'X'], [null, null, 'wp', 'wp', null, null], [null, null, 'wr', 'wk', 'wr', null]], reward: "+80 XP", xp: 80 },
            { id: 5, title: "The High Road", enemy: 'goblin', difficulty: 'CPU-medium', tileset: 'tile_grass.png', rows: 6, cols: 6, setup: [['br', 'bn', 'bk', 'bn', 'br', null], ['bp', 'bp', 'bp', 'bp', 'bp', null], [null, null, 'X', 'X', null, null], [null, null, 'X', 'X', null, null], [null, 'wp', 'wp', 'wp', 'wp', null], [null, 'wr', 'wn', 'wk', 'wn', 'wr']], reward: "Unlock Grass Tileset", xp: 100 },
            { id: 6, title: "Goblin Bridge", enemy: 'goblin', difficulty: 'CPU-medium', tileset: 'tile_grass.png', rows: 8, cols: 8, setup: [['br', 'bn', 'bb', 'bk', 'bb', 'bn', 'br', null], ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'], ['X', 'X', null, null, null, null, 'X', 'X'], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], ['X', 'X', null, null, null, null, 'X', 'X'], ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'], ['wr', 'wn', 'wb', 'wk', 'wb', 'wn', 'wr', null]], reward: "+150 XP", xp: 150 },
            { id: 7, title: "Stone Circle", enemy: 'goblin', difficulty: 'CPU-medium', tileset: 'tile_stone.png', rows: 8, cols: 8, setup: [['bk', null, null, null, null, null, null, null], ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'], ['X', null, 'X', null, 'X', null, 'X', null], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], ['X', null, 'X', null, 'X', null, 'X', null], ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'], ['wk', null, null, null, null, null, null, null]], reward: "+200 XP", xp: 200 },
            { id: 8, title: "Misty Falls", enemy: 'goblin', difficulty: 'CPU-hard', tileset: 'tile_grass.png', rows: 8, cols: 8, setup: [['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'], ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'], [null, null, 'X', null, null, 'X', null, null], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], [null, null, 'X', null, null, 'X', null, null], ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'], ['wr', 'wn', null, 'wk', null, 'wn', 'wr', null]], reward: "+250 XP", xp: 250 },
            { id: 9, title: "Ambush Point", enemy: 'goblin', difficulty: 'CPU-hard', tileset: 'tile_grass.png', rows: 8, cols: 8, setup: [['X', null, 'bk', null, null, 'X', 'X', 'X'], ['bp', 'bp', null, 'bp', 'bp', 'bp', 'bp', 'bp'], [null, null, null, null, null, null, 'X', null], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], [null, null, 'X', null, 'X', null, null, 'X'], ['wp', 'wp', 'wp', 'wp', null, 'wp', 'wp', 'wp'], ['X', 'X', 'wk', null, 'X', 'X', 'X', 'X']], reward: "+300 XP", xp: 300 },
            { id: 10, title: "Goblin Throne", enemy: 'goblin', difficulty: 'CPU-hard', tileset: 'tile_stone.png', rows: 8, cols: 8, setup: [['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'], ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'], [null, null, null, null, null, null, null, null], [null, null, 'X', 'X', 'X', 'X', null, null], [null, null, 'X', 'X', 'X', 'X', null, null], [null, null, null, null, null, null, null, null], ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'], ['wr', 'wn', 'wb', 'wq', 'wk', null, 'wn', 'wr']], reward: "Unlock Goblins", unlockFaction: 'goblin', xp: 500 },

            // ORC CAMPAIGN (11-20)
            { id: 11, title: "Orcish Scouts", enemy: 'orc', difficulty: 'CPU-easy', tileset: 'tile_stone.png', rows: 4, cols: 4, setup: [['br', 'bk', null, null], [null, null, null, null], [null, null, null, null], [null, null, 'wk', 'wr']], reward: "+100 XP", xp: 100 },
            { id: 12, title: "Broad Pass", enemy: 'orc', difficulty: 'CPU-medium', tileset: 'tile_stone.png', rows: 6, cols: 6, setup: [['br', 'bk', 'br', null, null, null], ['bp', 'bp', 'bp', null, null, null], [null, null, null, null, null, null], [null, null, null, null, null, null], [null, null, null, 'wp', 'wp', 'wp'], [null, null, null, 'wr', 'wk', 'wr']], reward: "+150 XP", xp: 150 },
            { id: 13, title: "Orcish Border", enemy: 'orc', difficulty: 'CPU-medium', tileset: 'tile_stone.png', rows: 8, cols: 8, setup: [['br', 'bn', 'bk', 'bn', 'br', null, null, null], ['bp', 'bp', 'bp', 'bp', 'bp', null, null, null], [null, null, null, null, null, null, null, null], [null, null, 'X', 'X', null, null, null, null], [null, null, 'X', 'X', null, null, null, null], [null, null, null, null, null, null, null, null], [null, null, null, 'wp', 'wp', 'wp', 'wp', 'wp'], [null, null, null, 'wr', 'wn', 'wk', 'wn', 'wr']], reward: "+200 XP", xp: 200 },
            { id: 14, title: "The Gorge", enemy: 'orc', difficulty: 'CPU-medium', tileset: 'tile_wasteland.png', rows: 8, cols: 8, setup: [['bk', null, null, null, null, null, null, null], ['br', 'bp', 'bp', null, null, null, null, null], [null, null, 'X', null, 'X', null, 'X', null], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], [null, 'X', null, 'X', null, 'X', null, null], [null, null, null, null, null, 'wp', 'wp', 'wr'], [null, null, null, null, null, null, null, 'wk']], reward: "+250 XP", xp: 250 },
            { id: 15, title: "Mountain Fort", enemy: 'orc', difficulty: 'CPU-hard', tileset: 'tile_stone.png', rows: 8, cols: 8, setup: [['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'], ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'], ['X', 'X', null, null, null, null, 'X', 'X'], ['X', 'X', null, null, null, null, 'X', 'X'], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'], ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr']], reward: "Unlock Stone Tileset", xp: 300 },
            { id: 16, title: "Orcish Gauntlet", enemy: 'orc', difficulty: 'CPU-hard', tileset: 'tile_wasteland.png', rows: 8, cols: 8, setup: [['bk', null, 'X', 'X', 'X', 'X', null, null], [null, 'bp', 'bp', 'bp', 'bp', 'bp', null, null], ['X', 'X', null, null, null, null, 'X', 'X'], [null, null, null, null, null, null, null, null], ['X', 'X', null, null, null, null, 'X', 'X'], [null, 'wp', 'wp', 'wp', 'wp', 'wp', null, null], [null, null, 'X', 'X', 'X', 'X', null, 'wk'], ['wr', 'wn', 'wb', 'wq', null, null, null, null]], reward: "+350 XP", xp: 350 },
            { id: 17, title: "Great Plains", enemy: 'orc', difficulty: 'CPU-hard', tileset: 'tile_grass.png', rows: 8, cols: 8, setup: [['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'], ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'], [null, null, null, null, null, null, null, null], [null, null, null, 'X', 'X', null, null, null], [null, null, null, 'X', 'X', null, null, null], [null, null, null, null, null, null, null, null], ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'], ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr']], reward: "+400 XP", xp: 400 },
            { id: 18, title: "Orcish Siege", enemy: 'orc', difficulty: 'CPU-hard', tileset: 'tile_castle.png', rows: 8, cols: 8, setup: [['br', 'bn', 'bk', 'bq', 'bb', 'bn', null, null], ['bp', 'bp', null, null, 'bp', 'bp', null, null], ['X', 'X', null, null, null, null, 'X', 'X'], ['X', 'X', null, null, null, null, 'X', 'X'], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'], ['wr', 'wn', 'wk', 'wq', 'wb', 'wn', 'wr', null]], reward: "+450 XP", xp: 450 },
            { id: 19, title: "The Pit", enemy: 'orc', difficulty: 'CPU-hard', tileset: 'tile_wasteland.png', rows: 8, cols: 8, setup: [['bk', null, null, null, null, null, null, 'br'], ['bp', 'X', 'X', null, null, 'X', 'X', 'bp'], [null, 'X', null, null, null, null, 'X', null], [null, null, null, 'bq', null, null, null, null], [null, null, null, 'wq', null, null, null, null], [null, 'X', null, null, null, null, 'X', null], ['bp', 'X', 'X', null, null, 'X', 'X', 'bp'], ['wr', null, null, null, null, null, null, 'wk']], reward: "+500 XP", xp: 500 },
            { id: 20, title: "Orcish Warchief", enemy: 'orc', difficulty: 'CPU-hard', tileset: 'tile_wasteland.png', rows: 8, cols: 8, setup: [['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'], ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'], ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr']], reward: "Unlock Orcs", unlockFaction: 'orc', xp: 1000 },

            // UNDEAD CAMPAIGN (21-30)
            { id: 21, title: "Skeleton Scouts", enemy: 'undead', difficulty: 'CPU-medium', tileset: 'tile_wasteland.png', rows: 6, cols: 6, setup: [[null, 'br', 'bk', 'br', null, null], [null, 'bp', 'bp', 'bp', null, null], [null, null, null, null, null, null], [null, null, null, null, null, null], [null, null, 'wp', 'wp', null, null], [null, null, 'wr', 'wk', 'wr', null]], reward: "+200 XP", xp: 200 },
            { id: 22, title: "Blighted Woods", enemy: 'undead', difficulty: 'CPU-hard', tileset: 'tile_wasteland.png', rows: 8, cols: 8, setup: [['bk', null, null, null, null, null, null, null], ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'], ['X', null, 'X', null, 'X', null, 'X', null], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], ['X', null, 'X', null, 'X', null, 'X', null], ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'], ['wk', null, null, null, null, null, null, null]], reward: "+300 XP", xp: 300 },
            { id: 23, title: "The Necropolis", enemy: 'undead', difficulty: 'CPU-hard', tileset: 'tile_wasteland.png', rows: 8, cols: 8, setup: [['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'], ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'], ['X', 'X', null, null, null, null, 'X', 'X'], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], ['X', 'X', null, null, null, null, 'X', 'X'], ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'], ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr']], reward: "+400 XP", xp: 400 },
            { id: 24, title: "Bone Pass", enemy: 'undead', difficulty: 'CPU-hard', tileset: 'tile_snow.png', rows: 8, cols: 8, setup: [['bk', null, 'X', 'X', 'X', 'X', null, null], [null, 'bp', 'bp', null, null, null, null, null], ['X', 'X', null, null, 'bp', 'bp', 'X', 'X'], [null, null, null, null, null, null, null, null], ['X', 'X', null, null, null, null, 'X', 'X'], [null, null, null, null, 'wp', 'wp', null, null], [null, null, 'X', 'X', 'X', 'X', null, 'wk'], ['wr', 'wn', 'wb', 'wq', null, null, null, null]], reward: "+500 XP", xp: 500 },
            { id: 25, title: "The Frozen Grave", enemy: 'undead', difficulty: 'CPU-hard', tileset: 'tile_snow.png', rows: 8, cols: 8, setup: [['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'], ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'], [null, null, 'X', null, null, 'X', null, null], [null, 'X', null, 'X', 'X', null, 'X', null], [null, null, null, null, null, null, null, null], [null, null, 'X', null, null, 'X', null, null], ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', null], ['wr', 'wn', 'wb', 'wq', 'wk', null, 'wn', 'wr']], reward: "Unlock Wasteland Tileset", xp: 600 },
            { id: 26, title: "Spooky Marsh", enemy: 'undead', difficulty: 'CPU-hard', tileset: 'tile_wasteland.png', rows: 8, cols: 8, setup: [['X', 'X', 'bk', 'X', 'X', 'X', 'X', 'X'], ['bp', 'bp', null, 'bp', 'bp', 'bp', null, null], ['X', 'X', null, 'X', 'X', null, 'X', null], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], ['X', null, 'X', null, 'X', 'X', null, 'X'], ['wp', 'wp', null, 'wp', null, 'wp', 'wp', 'wp'], ['X', 'X', 'wk', null, 'X', 'X', 'X', 'X']], reward: "+700 XP", xp: 700 },
            { id: 27, title: "Lich King's Lair", enemy: 'undead', difficulty: 'CPU-hard', tileset: 'tile_castle.png', rows: 8, cols: 8, setup: [['br', 'bn', 'bk', 'bq', 'bb', null, null, null], ['bp', 'bp', null, null, null, null, null, null], ['X', 'X', null, null, null, null, 'X', 'X'], ['X', 'X', null, null, null, null, 'X', 'X'], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], ['wp', null, null, null, null, null, null, null], ['wr', 'wn', 'wk', 'wq', 'wb', 'wn', 'wr', null]], reward: "+800 XP", xp: 800 },
            { id: 28, title: "Shadow Valley", enemy: 'undead', difficulty: 'CPU-hard', tileset: 'tile_wasteland.png', rows: 8, cols: 8, setup: [['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'], [null, null, 'bp', null, null, 'bp', null, null], ['X', 'X', null, null, null, null, 'X', 'X'], [null, null, 'X', 'X', 'X', 'X', null, null], [null, null, 'X', 'X', 'X', 'X', null, null], ['X', 'X', null, null, null, null, 'X', 'X'], [null, null, 'wp', null, null, 'wp', null, null], [null, 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', null]], reward: "+900 XP", xp: 900 },
            { id: 29, title: "The Dark Gate", enemy: 'undead', difficulty: 'CPU-hard', tileset: 'tile_castle.png', rows: 8, cols: 8, setup: [['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'], ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'], [null, null, null, 'X', 'X', null, null, null], [null, null, 'X', 'X', 'X', 'X', null, null], [null, null, 'X', 'X', 'X', 'X', null, null], [null, null, null, 'X', 'X', null, null, null], ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'], ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr']], reward: "+1000 XP", xp: 1000 },
            { id: 30, title: "Eternity's End", enemy: 'undead', difficulty: 'CPU-hard', tileset: 'tile_snow.png', rows: 8, cols: 8, setup: [['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'], ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'], ['X', 'X', null, 'X', 'X', null, 'X', 'X'], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], ['X', 'X', null, 'X', 'X', null, 'X', 'X'], ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'], ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr']], reward: "Unlock Undead", unlockFaction: 'undead', xp: 2000 },

            // HIGHBORNE CAMPAIGN (31-40)
            { id: 31, title: "Royal Vanguard", enemy: 'highborne', difficulty: 'CPU-medium', tileset: 'tile_castle.png', rows: 6, cols: 6, setup: [[null, 'br', 'bk', 'br', null, null], [null, 'bp', 'bp', 'bp', null, null], [null, null, null, null, null, null], [null, null, null, null, null, null], [null, null, 'wp', 'wp', null, null], [null, null, 'wr', 'wk', 'wr', null]], reward: "+300 XP", xp: 300 },
            { id: 32, title: "Imperial Gardens", enemy: 'highborne', difficulty: 'CPU-hard', tileset: 'tile_grass.png', rows: 8, cols: 8, setup: [['bk', null, 'X', null, null, 'X', null, null], ['bp', 'bp', null, 'bp', 'bp', null, 'bp', 'bp'], [null, null, null, null, null, null, null, null], ['X', null, 'X', 'X', 'X', 'X', null, 'X'], ['X', null, 'X', 'X', 'X', 'X', null, 'X'], [null, null, null, null, null, null, null, null], ['wp', 'wp', null, 'wp', 'wp', null, 'wp', 'wp'], [null, null, 'X', null, null, 'X', null, 'wk']], reward: "+400 XP", xp: 400 },
            { id: 33, title: "The Gilded Hall", enemy: 'highborne', difficulty: 'CPU-hard', tileset: 'tile_castle.png', rows: 8, cols: 8, setup: [['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'], ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'], ['X', null, null, null, null, null, null, 'X'], [null, null, 'X', 'X', 'X', 'X', null, null], [null, null, 'X', 'X', 'X', 'X', null, null], ['X', null, null, null, null, null, null, 'X'], ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'], ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr']], reward: "+500 XP", xp: 500 },
            { id: 34, title: "Skyloft Bridge", enemy: 'highborne', difficulty: 'CPU-hard', tileset: 'tile_snow.png', rows: 8, cols: 8, setup: [['bk', 'bb', 'X', 'X', 'X', 'X', null, null], ['br', 'bp', 'bp', null, null, null, null, null], [null, null, null, null, null, null, null, null], ['X', 'X', null, 'X', 'X', null, 'X', 'X'], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], [null, null, null, null, null, 'wp', 'wp', 'wr'], [null, null, 'X', 'X', 'X', 'X', 'wb', 'wk']], reward: "+600 XP", xp: 600 },
            { id: 35, title: "Summit Citadel", enemy: 'highborne', difficulty: 'CPU-hard', tileset: 'tile_snow.png', rows: 8, cols: 8, setup: [['br', 'bn', 'bk', 'bq', 'bb', 'bn', 'br', null], ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'], ['X', 'X', null, null, null, null, 'X', 'X'], ['X', 'X', null, null, null, null, 'X', 'X'], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'], ['wr', 'wn', 'wk', 'wq', 'wb', 'wn', 'wr', null]], reward: "Unlock Snow Tileset", xp: 800 },
            { id: 36, title: "Palace Gauntlet", enemy: 'highborne', difficulty: 'CPU-hard', tileset: 'tile_castle.png', rows: 8, cols: 8, setup: [['bk', null, 'X', 'X', 'X', 'X', null, null], [null, 'bp', 'bp', 'bp', 'bp', 'bp', null, null], ['X', 'X', null, null, null, null, 'X', 'X'], [null, null, null, null, null, null, null, null], ['X', 'X', null, null, null, null, 'X', 'X'], [null, 'wp', 'wp', 'wp', 'wp', 'wp', null, null], [null, null, 'X', 'X', 'X', 'X', null, 'wk'], ['wr', 'wn', 'wb', 'wq', null, null, null, null]], reward: "+1000 XP", xp: 1000 },
            { id: 37, title: "Royal Maze", enemy: 'highborne', difficulty: 'CPU-hard', tileset: 'tile_stone.png', rows: 8, cols: 8, setup: [['bk', null, null, null, null, null, null, 'br'], ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'], [null, null, 'X', null, null, 'X', null, null], ['X', null, 'X', null, null, 'X', null, 'X'], ['X', null, 'X', null, null, 'X', null, 'X'], [null, null, 'X', null, null, 'X', null, null], ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'], ['wr', null, null, 'wq', 'wk', null, null, 'wr']], reward: "+1200 XP", xp: 1200 },
            { id: 38, title: "Court of Lions", enemy: 'highborne', difficulty: 'CPU-hard', tileset: 'tile_castle.png', rows: 8, cols: 8, setup: [['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'], ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'], [null, null, null, null, null, null, null, null], ['X', 'X', null, null, null, null, 'X', 'X'], ['X', 'X', null, null, null, null, 'X', 'X'], [null, null, null, null, null, null, null, null], ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', null, null], ['wr', 'wn', 'wb', 'wq', 'wk', null, 'wn', 'wr']], reward: "+1500 XP", xp: 1500 },
            { id: 39, title: "High King's Ascent", enemy: 'highborne', difficulty: 'CPU-hard', tileset: 'tile_snow.png', rows: 8, cols: 8, setup: [['br', 'bn', 'bb', 'bq', 'bk', null, 'bn', 'br'], ['bp', null, null, null, null, null, null, null], ['X', 'X', null, 'X', 'X', null, 'X', 'X'], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], ['X', 'X', null, 'X', 'X', null, 'X', 'X'], [null, null, null, null, null, null, null, 'bp'], ['wr', 'wn', 'wk', 'wq', 'wb', 'bb', 'wn', 'wr']], reward: "+2000 XP", xp: 2000 },
            { id: 40, title: "The High King's Sanctum", enemy: 'highborne', difficulty: 'CPU-hard', tileset: 'tile_castle.png', rows: 8, cols: 8, setup: [['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'], ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'], ['X', 'X', null, null, null, null, 'X', 'X'], [null, null, 'X', 'X', 'X', 'X', null, null], [null, null, 'X', 'X', 'X', 'X', null, null], ['X', 'X', null, null, null, null, 'X', 'X'], ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'], ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr']], reward: "+2000 XP", xp: 2000 },

            // CHAMPION CAMPAIGN (41-45) - 10x10 Boards
            {
                id: 41, title: "Grand Arena", enemy: 'highborne', difficulty: 'CPU-hard', tileset: 'tile_castle.png', rows: 10, cols: 10, setup: [
                    ['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br', null, null],
                    ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'],
                    [null, null, null, null, null, null, null, null, null, null],
                    [null, null, 'X', null, null, null, null, 'X', null, null],
                    [null, null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null, null],
                    [null, null, 'X', null, null, null, null, 'X', null, null],
                    [null, null, null, null, null, null, null, null, null, null],
                    ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'],
                    ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr', null, null]
                ], reward: "+2500 XP", xp: 2500
            },
            {
                id: 42, title: "Shadow Citadel", enemy: 'undead', difficulty: 'CPU-hard', tileset: 'tile_stone.png', rows: 10, cols: 10, setup: [
                    ['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br', 'bn', 'br'],
                    ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'],
                    ['X', 'X', null, null, 'X', 'X', null, null, 'X', 'X'],
                    [null, null, null, null, null, null, null, null, null, null],
                    ['X', 'X', null, null, 'X', 'X', null, null, 'X', 'X'],
                    [null, null, null, null, null, null, null, null, null, null],
                    ['X', 'X', null, null, 'X', 'X', null, null, 'X', 'X'],
                    [null, null, null, null, null, null, null, null, null, null],
                    ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'],
                    ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr', 'wn', 'wr']
                ], reward: "+3000 XP", xp: 3000
            },
            {
                id: 43, title: "The Iron Gauntlet", enemy: 'orc', difficulty: 'CPU-hard', tileset: 'tile_wasteland.png', rows: 10, cols: 10, setup: [
                    ['bk', 'bq', 'br', 'br', 'bn', 'bn', 'bb', 'bb', null, null],
                    ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'],
                    [null, 'X', null, 'X', null, 'X', null, 'X', null, 'X'],
                    [null, null, null, null, null, null, null, null, null, null],
                    ['X', null, 'X', null, 'X', null, 'X', null, 'X', null],
                    [null, null, null, null, null, null, null, null, null, null],
                    [null, 'X', null, 'X', null, 'X', null, 'X', null, 'X'],
                    [null, null, null, null, null, null, null, null, null, null],
                    ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'],
                    ['wk', 'wq', 'wr', 'wr', 'wn', 'wn', 'wb', 'wb', null, null]
                ], reward: "+3500 XP", xp: 3500
            },
            {
                id: 44, title: "Ancient Overpass", enemy: 'highborne', difficulty: 'CPU-hard', tileset: 'tile_snow.png', rows: 10, cols: 10, setup: [
                    ['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br', null, null],
                    ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'],
                    ['X', 'X', 'X', 'X', null, null, 'X', 'X', 'X', 'X'],
                    ['X', 'X', 'X', 'X', null, null, 'X', 'X', 'X', 'X'],
                    [null, null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null, null],
                    ['X', 'X', 'X', 'X', null, null, 'X', 'X', 'X', 'X'],
                    ['X', 'X', 'X', 'X', null, null, 'X', 'X', 'X', 'X'],
                    ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'],
                    ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr', null, null]
                ], reward: "+4000 XP", xp: 4000
            },
            {
                id: 45, title: "The King of Kings", enemy: 'highborne', difficulty: 'CPU-hard', tileset: 'tile_castle.png', rows: 10, cols: 10, setup: [
                    ['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br', 'bq', 'br'],
                    ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'],
                    [null, null, null, null, null, null, null, null, null, null],
                    ['X', 'X', null, null, 'X', 'X', null, null, 'X', 'X'],
                    [null, null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null, null],
                    ['X', 'X', null, null, 'X', 'X', null, null, 'X', 'X'],
                    [null, null, null, null, null, null, null, null, null, null],
                    ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'],
                    ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr', 'wq', 'wr']
                ], reward: "Unlock All Factions", xp: 10000
            }
        ];

        const availableTilesets = [
            { id: 'classic', name: 'Classic', texture: null, cost: 0 },
            { id: 'grass', name: 'Grass', texture: 'tile_grass.png', cost: 100 },
            { id: 'stone', name: 'Stone', texture: 'tile_stone.png', cost: 250 },
            { id: 'wasteland', name: 'Wasteland', texture: 'tile_wasteland.png', cost: 500 },
            { id: 'castle', name: 'Castle', texture: 'tile_castle.png', cost: 750 },
            { id: 'snow', name: 'Snow', texture: 'tile_snow.png', cost: 1000 }
        ];

        const availableSpells = [
            { id: 'swap', name: 'Tactical Swap', icon: 'spell_swap.png', description: 'Switch positions of two pieces.', cost: 50 },
            { id: 'summon', name: 'Summon Pawn', icon: 'spell_summon.png', description: 'Place a new pawn in your territory.', cost: 75 },
            { id: 'fortify', name: 'Fortify', icon: 'spell_fortify.png', description: 'Create a wall (lasts 3 turns).', cost: 75 },
            { id: 'scout', name: 'Scout', icon: 'spell_scout.png', description: 'See all enemy move options this turn.', cost: 50 },
            { id: 'shield', name: 'Shield', icon: 'spell_shield.png', description: 'Protect a piece from capture (1 turn).', cost: 60 },
            { id: 'freeze', name: 'Freeze', icon: 'spell_freeze.png', description: 'Prevent an enemy piece from moving (1 turn).', cost: 60 }
        ];

        const availableUpgrades = [
            { id: 'swap', name: 'Phase Swap', description: 'Allows swapping with enemy pieces.', cost: 300 },
            { id: 'summon', name: 'Reinforcements', description: 'Summons 2 pawns instead of 1.', cost: 400 },
            { id: 'fortify', name: 'Great Wall', description: 'Walls now last 5 full turns.', cost: 350 },
            { id: 'scout', name: 'Extended Scout', description: 'Scout duration increased to 3 turns.', cost: 250 },
            { id: 'shield', name: 'Vanguard Shield', description: 'Shields target and adjacent allies in a cross pattern.', cost: 400 },
            { id: 'freeze', name: 'Deep Freeze', description: 'Freezes a 2x2 area of enemies.', cost: 450 }
        ];

        let campaignData = {
            xp: 0,
            coins: 0,
            currentLevel: 1,
            unlockedFactions: ['human'],
            unlockedTilesets: ['classic'],
            spellLevels: { swap: 1, summon: 1, fortify: 1, scout: 1, shield: 1, freeze: 1 },
            inventory: {
                spells: { swap: 0, summon: 0, fortify: 0, scout: 0, shield: 0, freeze: 0 }
            }
        };

        function saveCampaign() {
            localStorage.setItem('kingsfall_campaign', JSON.stringify(campaignData));
        }

        function loadCampaign() {
            const saved = localStorage.getItem('kingsfall_campaign');
            if (saved) {
                const loadedData = JSON.parse(saved);
                // Recursive merge into default structure to handle schema updates
                const merge = (target, source) => {
                    for (const key in source) {
                        if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
                            if (!target[key]) target[key] = {};
                            merge(target[key], source[key]);
                        } else {
                            target[key] = source[key];
                        }
                    }
                };
                merge(campaignData, loadedData);
                updateUnlocksUI();
                renderCampaignLevels();
                renderTilesets();
                updateXpBar();
                updateEconomyUI();
            }
        }

        function updateRacePreviews() {
            const wSelect = document.getElementById('white-race-select');
            const bSelect = document.getElementById('black-race-select');
            if (!wSelect || !bSelect) return;
            const wRace = wSelect.value;
            const bRace = bSelect.value;
            if (typeof raceSpritePrefix !== 'undefined') {
                document.getElementById('white-race-preview').src = `sprites/${wRace}/${raceSpritePrefix[wRace]}King.png`;
                document.getElementById('black-race-preview').src = `sprites/${bRace}/${raceSpritePrefix[bRace]}King.png`;
            }
        }

        let currentDifficulty = 'CPU-medium';

        function updateUnlocksUI() {
            // Update faction selects
            const selects = ['white-race-select', 'black-race-select'];
            selects.forEach(id => {
                const select = document.getElementById(id);
                if (!select) return;
                Array.from(select.options).forEach(opt => {
                    const isUnlocked = campaignData.unlockedFactions.includes(opt.value);
                    opt.disabled = !isUnlocked;

                    // Add/Remove (Locked) label
                    if (!isUnlocked) {
                        if (!opt.textContent.includes('(Locked)')) opt.textContent += ' (Locked)';
                    } else {
                        opt.textContent = opt.textContent.replace(' (Locked)', '');
                    }
                });
                // Ensure selection is valid
                if (!campaignData.unlockedFactions.includes(select.value)) {
                    select.value = 'human';
                    if (id === 'white-race-select') whiteRace = 'human';
                    else blackRace = 'human';
                }
            });
            updateRacePreviews();
        }

        function renderCampaignLevels() {
            const list = document.getElementById('level-list');
            list.innerHTML = '';

            const chapters = [
                { id: "goblin", name: "Chapter 1: The Green Menace", enemy: "goblin" },
                { id: "orc", name: "Chapter 2: Blood and Iron", enemy: "orc" },
                { id: "undead", name: "Chapter 3: Shadows of the Grave", enemy: "undead" },
                { id: "highborne", name: "Chapter 4: The Royal Rebellion", enemy: "highborne" },
                { id: "champion", name: "Chapter 5: The King of Kings", enemy: "highborne", isChampion: true }
            ];

            chapters.forEach(chapter => {
                const chapterLevels = campaignLevels.filter(lvl => {
                    if (chapter.isChampion) return lvl.id > 40;
                    return lvl.enemy === chapter.enemy && lvl.id <= 40;
                });

                if (chapterLevels.length === 0) return;

                const chapterDiv = document.createElement('div');
                chapterDiv.className = 'campaign-chapter';

                const header = document.createElement('div');
                header.className = 'chapter-header';
                header.textContent = chapter.name;
                chapterDiv.appendChild(header);

                const grid = document.createElement('div');
                grid.className = 'chapter-grid';

                chapterLevels.forEach(lvl => {
                    const isCompleted = lvl.id < campaignData.currentLevel;
                    const isActive = lvl.id === campaignData.currentLevel;
                    const isLocked = lvl.id > campaignData.currentLevel;

                    const div = document.createElement('div');
                    div.className = `campaign-level ${isCompleted ? 'completed' : ''} ${isActive ? 'active' : ''} ${isLocked ? 'locked' : ''}`;
                    div.title = `Reward: ${lvl.reward}`;
                    div.innerHTML = `
                        <div class="level-number">${lvl.id}</div>
                        <div class="level-title">${lvl.title}</div>
                    `;
                    if (!isLocked) {
                        div.onclick = () => startCampaignLevel(lvl);
                    }
                    grid.appendChild(div);
                });

                chapterDiv.appendChild(grid);
                list.appendChild(chapterDiv);
            });
        }

        function renderTilesets() {
            const container = document.getElementById('tileset-container');
            container.innerHTML = '';
            availableTilesets.forEach(ts => {
                const isOwned = campaignData.unlockedTilesets.includes(ts.id);
                const isLocked = !isOwned;

                const btn = document.createElement('div');
                btn.className = `tileset-btn ${isLocked ? 'locked' : ''} ${selectedTileset === ts.id ? 'selected' : ''}`;
                if (ts.id === 'classic') {
                    btn.style.background = 'linear-gradient(45deg, #eeeed2 50%, #769656 50%)';
                } else if (ts.texture) {
                    btn.style.backgroundImage = `url('textures/${ts.texture}')`;
                    btn.style.backgroundSize = 'cover';
                }

                if (isLocked) {
                    btn.title = `${ts.name} (Purchase in Emporium)`;
                } else {
                    btn.title = ts.name;
                    btn.onclick = () => {
                        selectedTileset = ts.id;
                        renderTilesets();
                    };
                }
                container.appendChild(btn);
            });
        }

        function updateXpBar() {
            const rankNames = ["Novice", "Squire", "Knight", "Commander", "General", "King"];
            const rankIndex = Math.min(rankNames.length - 1, Math.floor(campaignData.xp / 200));
            document.getElementById('campaign-rank').textContent = `Rank: ${rankNames[rankIndex]}`;

            const xpInRank = campaignData.xp % 200;
            const progress = (xpInRank / 200) * 100;
            document.getElementById('xp-bar-fill').style.width = `${progress}%`;
            document.getElementById('xp-text').textContent = `${xpInRank} / 200 XP`;
        }

        function showCampaignMap() {
            document.getElementById('mode-selection').style.display = 'none';
            document.getElementById('campaign-map').style.display = 'flex';
            document.getElementById('mode-cpu').classList.remove('selected');
            document.getElementById('mode-2p').classList.remove('selected');
            document.getElementById('mode-campaign').classList.add('selected');
            renderCampaignLevels();
        }

        function hideCampaignMap() {
            document.getElementById('campaign-map').style.display = 'none';
            document.getElementById('mode-selection').style.display = 'flex';
            document.getElementById('mode-campaign').classList.remove('selected');
        }

        function startCampaignLevel(lvl) {
            campaignLevel = lvl;
            gameMode = 'CAMPAIGN';
            whiteRace = 'human';
            blackRace = lvl.enemy;
            // Set tile set based on level
            const ts = availableTilesets.find(t => t.texture === lvl.tileset);
            selectedTileset = ts ? ts.id : 'classic';

            // Update Level UI
            document.getElementById('current-level-display').textContent = `Level ${lvl.id}: ${lvl.title}`;
            document.getElementById('current-level-display').style.display = 'block';

            document.getElementById('campaign-map').style.display = 'none';
            document.getElementById('game-area').style.display = 'block';
            document.getElementById('game-coin-display').style.display = 'block';
            enemyKingBounty = 0; // Reset king bounty
            playerColor = 'w';
            currentPlayer = 'w';
            updateEconomyUI();
            setupBoard();
        }

        const pieceValues = { 'p': 100, 'n': 320, 'b': 330, 'r': 500, 'q': 900, 'k': 20000 };
        const pieceNameMap = { 'p': 'Pawn', 'n': 'Knight', 'b': 'Bishop', 'r': 'Rook', 'q': 'Queen', 'k': 'King' };
        const raceSpritePrefix = { 'human': 'w', 'goblin': 'g', 'orc': 'o', 'undead': 'u', 'highborne': 'w' };

        const boardElement = document.getElementById('board');
        const whiteRaceSelect = document.getElementById('white-race-select');
        const blackRaceSelect = document.getElementById('black-race-select');
        const startGameButton = document.getElementById('start-game-button');

        function setupBoard() {
            if (gameMode === 'CAMPAIGN' && campaignLevel && campaignLevel.setup) {
                board = JSON.parse(JSON.stringify(campaignLevel.setup));
            } else {
                board = Array(8).fill(null).map(() => Array(8).fill(null));
                board[0] = ['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'];
                board[1] = ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'];
                board[6] = ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'];
                board[7] = ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr'];
            }

            const rows = board.length;
            const cols = board[0].length;
            document.documentElement.style.setProperty('--board-rows', rows);
            document.documentElement.style.setProperty('--board-cols', cols);

            // Reset all game and spell states for a new match
            gameOver = false;
            isAnimating = false;
            activeSpell = null;
            spellTargets = [];
            hoveredSquare = null;
            selectedSquare = null;
            for (let s in spellCooldowns) spellCooldowns[s] = 0;
            boardElement.classList.remove('spell-active');
            boardElement.style.cursor = 'default';
            renderActiveSpells();
            renderBoard();

            if (gameMode !== 'CAMPAIGN' && gameMode !== 'ONLINE') {
                whiteRace = whiteRaceSelect.value;
                blackRace = blackRaceSelect.value;
                document.getElementById('current-level-display').style.display = 'none';
            } else if (gameMode === 'ONLINE') {
                // For online, everyone uses human for now to ensure consistency 
                // (or we can sync races in gameData later)
                whiteRace = 'human';
                blackRace = 'human';
                document.getElementById('current-level-display').style.display = 'block';
                document.getElementById('current-level-display').textContent = "Online Battle";
            }

            kingPositions = { w: findKing('w'), b: findKing('b') };
            currentPlayer = 'w';
            gameOver = false;
            capturedPieces = { w: [], b: [] };
            lastMove = { start: null, end: null };
            moveHistory = [];
            saveState();

            // Random Coin Pickups (Adventure Mode & Online Only)
            if (gameMode === 'CAMPAIGN' || gameMode === 'ONLINE') {
                let coinsPlaced = 0;
                let attempts = 0;

                // Use seed for online to ensure same coins for both players
                let seededRandom = () => {
                    if (gameMode === 'ONLINE') {
                        let x = Math.sin(this.onlineBoardSeed++) * 10000;
                        return x - Math.floor(x);
                    }
                    return Math.random();
                };

                while (coinsPlaced < 2 && attempts < 20) {
                    const r = Math.floor(seededRandom() * rows);
                    const c = Math.floor(seededRandom() * cols);
                    if (!board[r][c]) {
                        board[r][c] = 'coin';
                        coinsPlaced++;
                    }
                    attempts++;
                }
            }

            renderBoard();
            updateStatus();
            updateEconomyUI();
            renderActiveSpells();
            updateRatingDisplay();
        }

        function renderActiveSpells() {
            const list = document.getElementById('active-spells-list');
            if (!list) return;
            list.innerHTML = '';

            if (gameMode !== 'CAMPAIGN') return;

            const spells = campaignData.inventory.spells;
            let hasAny = false;
            list.innerHTML = '';
            for (let id in spells) {
                if (spells[id] > 0) {
                    hasAny = true;
                    const s = availableSpells.find(sp => sp.id === id);
                    const lvl = campaignData.spellLevels[id];
                    let desc = s.description;
                    if (lvl >= 2) {
                        const upg = availableUpgrades.find(u => u.id === id);
                        if (upg) desc = upg.description;
                    }

                    const btn = document.createElement('button');
                    const isCooldown = spellCooldowns[id] > 0;
                    btn.className = `spell-btn ${activeSpell === id ? 'active' : ''} ${isCooldown ? 'on-cooldown' : ''}`;
                    btn.disabled = isCooldown;

                    btn.innerHTML = `
                        <img src="sprites/${s.icon}" style="width: 80px; height: 80px; border-radius: 6px; ${isCooldown ? 'opacity: 0.5; filter: grayscale(1);' : ''}"> 
                        <span class="spell-count-badge">${spells[id]}</span>
                        ${lvl >= 2 ? '<div style="position: absolute; top: -5px; left: -5px; background: #fbbf24; color: #000; font-size: 0.7rem; font-weight: bold; padding: 2px 5px; border-radius: 4px; border: 1px solid #000; z-index: 5; box-shadow: 0 2px 4px rgba(0,0,0,0.5);">LVL 2</div>' : ''}
                        ${isCooldown ? `<div style="position: absolute; bottom: -5px; left: 50%; transform: translateX(-50%); background: #ef4444; color: #fff; font-size: 0.8rem; font-weight: bold; padding: 2px 8px; border-radius: 10px; border: 1px solid #fff; white-space: nowrap; z-index: 6;">â³ ${Math.ceil(spellCooldowns[id] / 2)}</div>` : ''}
                    `;
                    btn.dataset.tooltipSide = "Gold";
                    btn.dataset.tooltipInfo = `<strong style="color:#fbbf24; font-size:1.1rem;">${s.name} ${lvl >= 2 ? '(Mastered)' : ''}</strong><br><span style="color:#fff;">${desc}</span>`;
                    btn.onclick = () => activateSpell(id);
                    list.appendChild(btn);
                }
            }
            document.getElementById('spells-section').style.display = hasAny ? 'block' : 'none';
        }

        function activateSpell(id) {
            if (spellCooldowns[id] > 0) return; // safety check

            if (activeSpell === id) {
                activeSpell = null;
                spellTargets = [];
                boardElement.style.cursor = 'default';
                boardElement.classList.remove('spell-active');
                renderActiveSpells();
                renderBoard();
            } else if (id === 'scout') {
                // Scout activates immediately
                const lvl = campaignData.spellLevels.scout;
                scoutActiveTurns = (lvl >= 2) ? 6 : 1; // 3 full turns = 6 half-turns, 1 full turn (immediate/current) = 1 half-turn

                campaignData.inventory.spells.scout--;
                spellCooldowns.scout = 6; // 3 full turns
                saveCampaign();
                activeSpell = null;
                boardElement.style.cursor = 'default';
                boardElement.classList.remove('spell-active');
                renderActiveSpells();
                renderBoard();
            } else {
                activeSpell = id;
                spellTargets = [];
                boardElement.style.cursor = 'crosshair';
                boardElement.classList.add('spell-active');
                renderActiveSpells();
                renderBoard();
            }
        }

        function updateEconomyUI() {
            const counts = document.querySelectorAll('.coin-count-global, #coin-count');
            counts.forEach(el => el.textContent = campaignData.coins);
            // Also update shop gold display
            const shopGold = document.getElementById('shop-gold-amount');
            if (shopGold) shopGold.textContent = campaignData.coins;
        }

        function renderBoard() {
            boardElement.innerHTML = '';
            const ts = availableTilesets.find(t => t.id === selectedTileset);
            const textureUrl = ts && ts.texture ? `textures/${ts.texture}` : null;
            const rows = board.length;
            const cols = board[0].length;

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const r = boardOrientation === 'b' ? (rows - 1 - i) : i;
                    const c = boardOrientation === 'b' ? (cols - 1 - j) : j;
                    const code = board[r][c];

                    const square = document.createElement('div');
                    square.className = `square ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = r; square.dataset.col = c;

                    square.onmouseenter = (e) => {
                        if (activeSpell && e.buttons === 0 && (!hoveredSquare || hoveredSquare.r !== r || hoveredSquare.c !== c)) {
                            hoveredSquare = { r, c };
                            renderBoard();
                        } else if (!activeSpell && hoveredSquare) {
                            // Clear hover state if spell was canceled
                            hoveredSquare = null;
                            renderBoard();
                        }
                    };
                    square.onmouseleave = () => {
                        if (hoveredSquare) {
                            hoveredSquare = null;
                            if (activeSpell) renderBoard();
                        }
                    };

                    // Scout Highlight
                    if (scoutActiveTurns > 0) {
                        const opp = playerColor === 'w' ? 'b' : 'w';
                        const p = board[r][c];
                        // If square is attacked by enemy
                        const isAttacked = isSquareAttacked(r, c, opp);
                        if (isAttacked) square.classList.add('scout-highlight');
                    }

                    // Spell Previews
                    if (hoveredSquare && activeSpell) {
                        const hr = hoveredSquare.r, hc = hoveredSquare.c;
                        const lvl = campaignData.spellLevels[activeSpell] || 1;

                        if (activeSpell === 'summon') {
                            const isTerritory = playerColor === 'w' ? hr >= 4 : hr <= 3;
                            if (r === hr && c === hc && isTerritory && (!code || code === 'coin')) {
                                const preview = document.createElement('div');
                                const race = playerColor === 'w' ? whiteRace : blackRace;
                                const prefix = raceSpritePrefix[race];
                                preview.className = `piece ${prefix}Pawn ${race} piece-preview`;
                                square.appendChild(preview);
                            }
                        } else if (activeSpell === 'fortify') {
                            if (r === hr && c === hc && (!code || code === 'coin')) {
                                const preview = document.createElement('div');
                                preview.className = 'obstacle piece-preview';
                                square.appendChild(preview);
                            }
                        } else if (activeSpell === 'freeze') {
                            const isArea = lvl >= 2;
                            const isInArea = isArea ? (r >= hr && r < hr + 2 && c >= hc && c < hc + 2) : (r === hr && c === hc);
                            if (isInArea) {
                                square.classList.add('area-preview');
                                square.classList.add('freeze');
                            }
                        } else if (activeSpell === 'shield') {
                            const isArea = lvl >= 2;
                            let isInArea = false;
                            if (isArea) {
                                const dist = Math.abs(r - hr) + Math.abs(c - hc);
                                isInArea = (dist === 0 || (dist === 1 && (r === hr || c === hc)));
                            } else {
                                isInArea = (r === hr && c === hc);
                            }
                            if (isInArea) {
                                square.classList.add('area-preview');
                                square.classList.add('shield');
                            }
                        } else if (activeSpell === 'swap') {
                            if (r === hr && c === hc) {
                                square.classList.add('area-preview');
                                square.classList.add('swap');
                            }
                        }
                    }

                    if (textureUrl) {
                        square.style.backgroundImage = `url('${textureUrl}')`;
                        square.style.backgroundSize = 'cover';
                        // Add a slight overlay to maintain readability
                        square.style.boxShadow = 'inset 0 0 0 1000px rgba(0,0,0,0.15)';
                    }

                    if (code === 'X') {
                        const obstacle = document.createElement('div');
                        obstacle.className = 'obstacle';
                        // Check if this is a temp wall
                        const tempWall = tempWalls.find(w => w.row === r && w.col === c);
                        if (tempWall) {
                            obstacle.classList.add('temp-wall');
                            square.dataset.tooltipSide = "";
                            square.dataset.tooltipInfo = `Temporary Wall<br><span style="color:#60a5fa;">Turns left: ${Math.ceil(tempWall.turnsLeft / 2)}</span>`;
                        } else {
                            square.dataset.tooltipSide = "";
                            square.dataset.tooltipInfo = "Wall";
                        }
                        square.appendChild(obstacle);
                    } else if (code === 'coin') {
                        const coin = document.createElement('div');
                        coin.className = 'coin-pickup';
                        square.dataset.tooltipSide = "Gold";
                        square.dataset.tooltipInfo = "Gold Coin";
                        square.appendChild(coin);
                    } else if (code) {
                        const piece = document.createElement('div');
                        const isWhite = code[0] === 'w';
                        const type = code[1];
                        const bounty = code.includes('+') ? parseInt(code.split('+')[1]) : 0;
                        const race = isWhite ? whiteRace : blackRace;
                        const prefix = raceSpritePrefix[race];
                        const pieceName = pieceNameMap[type];

                        piece.className = `piece ${prefix}${pieceName}`;
                        if (race === 'highborne') piece.classList.add('elite');
                        if (bounty > 0) piece.classList.add('has-bounty');

                        // Reskin logic...
                        const isMirrorMatch = whiteRace === blackRace;
                        if (!isWhite && (race === 'human' || isMirrorMatch)) {
                            piece.classList.add('enemy-reskin');
                        }

                        piece.draggable = (code[0] === currentPlayer && !isComputerTurn && !gameOver && !isAnimating && !activeSpell);

                        // Tooltip data
                        const side = isWhite ? "White" : "Black";
                        const raceName = race.charAt(0).toUpperCase() + race.slice(1);
                        square.dataset.tooltipSide = side;
                        square.dataset.tooltipInfo = bounty > 0
                            ? `${raceName} ${pieceName}<br><span style="color:#fbbf24;">Bounty: +${bounty} Gold</span>`
                            : `${raceName} ${pieceName}`;

                        // Shielded/Frozen visual indicators
                        if (shieldedPieces.some(s => s.row === r && s.col === c)) {
                            const shield = document.createElement('div');
                            shield.className = 'shield-effect';
                            square.appendChild(shield);
                        }
                        if (frozenPieces.some(f => f.row === r && f.col === c)) {
                            const ice = document.createElement('div');
                            ice.className = 'freeze-effect';
                            square.appendChild(ice);
                        }

                        square.appendChild(piece);
                    }

                    // Spell Targets (Current selections)
                    if (spellTargets.some(t => t.r === r && t.c === c)) {
                        square.classList.add('highlight');
                    }

                    if (lastMove.start && lastMove.start.row === r && lastMove.start.col === c) square.classList.add('last-move-start');
                    if (lastMove.end && lastMove.end.row === r && lastMove.end.col === c) square.classList.add('last-move-end');
                    if ((code === 'wk' && checkStatus.w) || (code === 'bk' && checkStatus.b)) square.classList.add('check');
                    boardElement.appendChild(square);
                }
            }
        }

        function calculateValidMoves(r, c, p) {
            // Frozen pieces cannot move
            if (frozenPieces.some(f => f.row === r && f.col === c)) return [];

            const moves = [], color = p[0], type = p[1], opp = color === 'w' ? 'b' : 'w';
            const rows = board.length, cols = board[0].length;
            const addMove = (nr, nc) => {
                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                    const target = board[nr][nc];
                    if (target === 'X') return false; // Blocked by obstacle
                    // Cannot capture shielded pieces
                    if (shieldedPieces.some(s => s.row === nr && s.col === nc)) return false;
                    if (!target || target === 'coin' || target[0] !== color) moves.push({ row: nr, col: nc });
                    return !target || target === 'coin';
                }
                return false;
            };

            if (type === 'p') {
                const dir = color === 'w' ? -1 : 1, start = color === 'w' ? rows - 2 : 1;
                const f1 = r + dir;
                if (f1 >= 0 && f1 < rows && (!board[f1][c] || board[f1][c] === 'coin')) {
                    moves.push({ row: f1, col: c });
                    const f2 = r + 2 * dir;
                    if (r === start && f2 >= 0 && f2 < rows && (!board[f2][c] || board[f2][c] === 'coin') && (!board[f1][c] || board[f1][c] === 'coin')) {
                        moves.push({ row: f2, col: c });
                    }
                }
                [-1, 1].forEach(dc => {
                    const nc = c + dc;
                    if (nc >= 0 && nc < cols && r + dir >= 0 && r + dir < rows) {
                        const t = board[r + dir][nc];
                        // Cannot capture shielded pieces
                        const isShielded = shieldedPieces.some(s => s.row === r + dir && s.col === nc);
                        if (t && t !== 'X' && t[0] === opp && !isShielded) moves.push({ row: r + dir, col: nc });
                    }
                });
            } else if (type === 'n') { [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]].forEach(([dr, dc]) => addMove(r + dr, c + dc)); }
            else if (type === 'k') { [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]].forEach(([dr, dc]) => addMove(r + dr, c + dc)); }
            else {
                const dirs = type === 'r' ? [[1, 0], [-1, 0], [0, 1], [0, -1]] : type === 'b' ? [[1, 1], [1, -1], [-1, 1], [-1, -1]] : [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [1, -1], [-1, 1], [-1, -1]];
                dirs.forEach(([dr, dc]) => { for (let i = 1; i < Math.max(rows, cols); i++) if (!addMove(r + i * dr, c + i * dc)) break; });
            }
            return moves.filter(m => !isCheckAfterMove(r, c, m.row, m.col, color));
        }

        function isCheckAfterMove(sr, sc, er, ec, color) {
            const temp = board[er][ec], p = board[sr][sc];
            board[er][ec] = p; board[sr][sc] = null;
            const res = isKingAttacked(color);
            board[sr][sc] = p; board[er][ec] = temp;
            return res;
        }

        function isKingAttacked(color) {
            const kPos = findKing(color); if (!kPos) return false;
            return isSquareAttacked(kPos.row, kPos.col, color === 'w' ? 'b' : 'w');
        }

        function isSquareAttacked(r, c, attackerColor) {
            const rows = board.length, cols = board[0].length;
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const p = board[i][j];
                    if (p && p !== 'X' && p[0] === attackerColor) {
                        const moves = getPseudoMoves(i, j, p);
                        if (moves.some(m => m.row === r && m.col === c)) return true;
                    }
                }
            }
            return false;
        }

        function findKing(color) {
            const rows = board.length, cols = board[0].length;
            for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) if (board[r][c] === color + 'k') return { row: r, col: c };
            return null;
        }

        function getPseudoMoves(r, c, p) {
            const moves = [], color = p[0], type = p[1];
            const rows = board.length, cols = board[0].length;
            const add = (nr, nc) => {
                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                    const target = board[nr][nc];
                    if (target === 'X') return false;
                    moves.push({ row: nr, col: nc });
                    return !target || target === 'coin';
                }
                return false;
            };
            if (type === 'p') { const d = color === 'w' ? -1 : 1;[-1, 1].forEach(dc => add(r + d, c + dc)); }
            else if (type === 'n') { [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]].forEach(([dr, dc]) => add(r + dr, c + dc)); }
            else if (type === 'k') { [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]].forEach(([dr, dc]) => add(r + dr, c + dc)); }
            else {
                const dirs = type === 'r' ? [[1, 0], [-1, 0], [0, 1], [0, -1]] : type === 'b' ? [[1, 1], [1, -1], [-1, 1], [-1, -1]] : [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [1, -1], [-1, 1], [-1, -1]];
                dirs.forEach(([dr, dc]) => { for (let i = 1; i < Math.max(rows, cols); i++) if (!add(r + i * dr, c + i * dc)) break; });
            }
            return moves;
        }

        function handleDragStart(e) {
            if (isAnimating || isComputerTurn || gameOver) { e.preventDefault(); return; }
            const piece = e.target.closest('.piece'); if (!piece) return;
            const sq = piece.closest('.square');
            const r = parseInt(sq.dataset.row), c = parseInt(sq.dataset.col), code = board[r][c];

            // In VS CPU / Campaign, only allow moving player's pieces
            if (gameMode !== '2P' && code[0] !== playerColor) { e.preventDefault(); return; }

            if (!code || code[0] !== currentPlayer) { e.preventDefault(); return; }
            clearSelection(); // Clear any previous click-to-move selection
            currentlyDragging = { isDragging: true, pieceElement: piece, startRow: r, startCol: c, pieceCode: code, validMoves: calculateValidMoves(r, c, code) };
            validMoves = currentlyDragging.validMoves;
            e.dataTransfer.setData('text/plain', '');
            e.dataTransfer.effectAllowed = 'move';
            highlightValidMoves();
            setTimeout(() => piece.classList.add('dragging'), 0);
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation(); // Prevent click from firing
            if (!currentlyDragging.isDragging) return;
            const sq = e.target.closest('.square');
            if (sq) {
                const r = parseInt(sq.dataset.row), c = parseInt(sq.dataset.col);
                const move = currentlyDragging.validMoves.find(m => m.row === r && m.col === c);
                if (move) {
                    executeMove(currentlyDragging.startRow, currentlyDragging.startCol, r, c);
                }
            }
            handleDragEndCleanup();
        }

        function handleDragEnd(e) {
            e.stopPropagation(); // Prevent click from firing
            handleDragEndCleanup();
        }

        function executeMove(sr, sc, er, ec, isFromRemote = false) {
            const target = board[er][ec], p = board[sr][sc];

            // If online, sync move to Firebase
            if (isOnlineGame && !isFromRemote && p[0] === onlinePlayerColor) {
                db.ref('games/' + currentGameId + '/moves').push({
                    sr, sc, er, ec,
                    player: onlinePlayerColor,
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                });
            }

            // Handle specific interactions
            if (target === 'coin') {
                if (gameMode === 'CAMPAIGN') {
                    if (p[0] === playerColor) {
                        campaignData.coins += 1;
                        saveCampaign();
                        updateEconomyUI();
                    } else {
                        // Enemy steals the coin
                        if (p[1] !== 'k') { // Not a king
                            const currentBounty = p.includes('+') ? parseInt(p.split('+')[1]) : 0;
                            board[sr][sc] = p.split('+')[0] + '+' + (currentBounty + 1);
                        } else {
                            // King collects gold but stays 'bk' or 'wk'
                            enemyKingBounty++;
                        }
                    }
                }
                board[er][ec] = null; // Remove coin
            } else if (target && target !== 'X') {
                // Check if target is shielded
                if (shieldedPieces.some(s => s.row === er && s.col === ec)) {
                    // Cannot capture shielded piece - move is blocked
                    return;
                }

                // Capture
                capturedPieces[currentPlayer === 'w' ? 'w' : 'b'].push(target);
                if (gameMode === 'CAMPAIGN' && playerColor === currentPlayer) {
                    const coinValues = { 'p': 1, 'n': 2, 'b': 2, 'r': 3, 'q': 5, 'k': 0 };
                    const type = target[1];
                    let amt = coinValues[type] || 0;

                    // Bounty retrieval
                    if (target.includes('+')) {
                        amt += parseInt(target.split('+')[1]);
                    }

                    if (amt > 0) {
                        campaignData.coins += amt;
                        saveCampaign();
                        updateEconomyUI();
                    }
                }
            }

            board[er][ec] = board[sr][sc];
            board[sr][sc] = null;

            const finalPiece = board[er][ec];
            lastMove = { start: { row: sr, col: sc }, end: { row: er, col: ec } };

            // Check for promotion
            if (finalPiece[1] === 'p' && (er === 0 || er === 7)) {
                if (gameMode !== '2P' && finalPiece[0] !== playerColor) {
                    // Computer always chooses Queen
                    board[er][ec] = finalPiece[0] + 'q';
                    finalizeMove();
                } else {
                    showPromotionModal(er, ec, finalPiece[0], (choice) => {
                        board[er][ec] = finalPiece[0] + choice;
                        finalizeMove();
                    });
                }
            } else { finalizeMove(); }
        }

        function finalizeMove() {
            currentPlayer = currentPlayer === 'w' ? 'b' : 'w';
            checkStatus.w = isKingAttacked('w'); checkStatus.b = isKingAttacked('b');

            // Check for game over
            const allMoves = [];
            const rows = board.length, cols = board[0].length;
            for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) if (board[r][c] && board[r][c] !== 'X' && board[r][c].startsWith(currentPlayer)) {
                calculateValidMoves(r, c, board[r][c]).forEach(m => allMoves.push(m));
            }
            if (allMoves.length === 0) {
                gameOver = true;
                const inCheck = isKingAttacked(currentPlayer);
                if (inCheck) {
                    const winner = currentPlayer === 'w' ? 'Black' : 'White';
                    const playerWon = winner === 'White';
                    updatePlayerRating(playerWon, false);
                    if (gameMode === 'CAMPAIGN' && winner === 'White') {
                        handleCampaignWin();
                        showGameOverModal('Checkmate!', winner + ' Wins!', true);
                    } else {
                        showGameOverModal('Checkmate!', winner + ' Wins!');
                    }
                } else {
                    showGameOverModal('Stalemate!', 'The game is a draw. You can undo to continue.');
                    updatePlayerRating(false, true);
                    // Don't set gameOver = true for stalemate - allow undo
                    gameOver = false;
                }
                renderBoard(); updateStatus();
                return;
            }

            saveState(); renderBoard(); updateStatus();
            renderActiveSpells();

            // Clear scout highlights
            document.querySelectorAll('.scout-highlight').forEach(el => el.classList.remove('scout-highlight'));

            // Only decay spells at the START of player's turn (after enemy moved)
            if (currentPlayer === playerColor) {
                // Decay temporary walls
                tempWalls = tempWalls.filter(w => {
                    w.turnsLeft--;
                    if (w.turnsLeft <= 0) {
                        board[w.row][w.col] = null;
                        return false;
                    }
                    return true;
                });

                // Decay shielded piece
                // Decay shielded pieces
                shieldedPieces.forEach(s => s.turnsLeft--);
                shieldedPieces = shieldedPieces.filter(s => s.turnsLeft > 0);

                // Decay frozen pieces
                frozenPieces.forEach(f => f.turnsLeft--);
                frozenPieces = frozenPieces.filter(f => f.turnsLeft > 0);

                // Decay cooldowns
                for (let id in spellCooldowns) {
                    if (spellCooldowns[id] > 0) spellCooldowns[id]--;
                }

                // Decay scout
                if (scoutActiveTurns > 0) {
                    scoutActiveTurns--;
                }
            }

            renderBoard();

            if (gameMode !== '2P' && currentPlayer !== playerColor) {
                isComputerTurn = true;
                makeComputerMove();
            } else {
                isComputerTurn = false;
            }
        }

        function makeComputerMove() {
            const moves = [];
            const rows = board.length, cols = board[0].length;
            for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) if (board[r][c] && board[r][c] !== 'X' && board[r][c].startsWith(currentPlayer)) {
                calculateValidMoves(r, c, board[r][c]).forEach(m => moves.push({ sr: r, sc: c, er: m.row, ec: m.col }));
            }
            if (moves.length === 0) {
                gameOver = true;
                const inCheck = isKingAttacked(currentPlayer);
                if (inCheck) {
                    showGameOverModal('Checkmate!', (currentPlayer === 'w' ? 'Black' : 'White') + ' Wins!');
                } else {
                    showGameOverModal('Stalemate!', 'The game is a draw.');
                }
                return;
            }

            // Difficulty Logic
            const diff = gameMode === 'CAMPAIGN' ? campaignLevel.difficulty : currentDifficulty;
            let move;

            if (diff === 'CPU-easy') {
                move = moves[Math.floor(Math.random() * moves.length)];
            } else if (diff === 'CPU-medium') {
                // Normal: Prefer captures
                const captures = moves.filter(m => board[m.er][m.ec] && board[m.er][m.ec] !== 'X');
                if (captures.length > 0) move = captures[Math.floor(Math.random() * captures.length)];
                else move = moves[Math.floor(Math.random() * moves.length)];
            } else {
                // Hard: Highest value capture
                let bestVal = -1;
                let bestMoves = [];
                moves.forEach(m => {
                    const target = board[m.er][m.ec];
                    if (target && target !== 'X') {
                        const val = pieceValues[target[1]];
                        if (val > bestVal) { bestVal = val; bestMoves = [m]; }
                        else if (val === bestVal) { bestMoves.push(m); }
                    }
                });
                if (bestMoves.length > 0) move = bestMoves[Math.floor(Math.random() * bestMoves.length)];
                else move = moves[Math.floor(Math.random() * moves.length)];
            }

            if (computerMoveTimeout) clearTimeout(computerMoveTimeout);
            computerMoveTimeout = setTimeout(() => executeMove(move.sr, move.sc, move.er, move.ec), 1000);
        }

        function highlightValidMoves() {
            validMoves.forEach(m => { const el = boardElement.querySelector(`.square[data-row="${m.row}"][data-col="${m.col}"]`); el.classList.add('highlight'); if (board[m.row][m.col]) el.classList.add('capture'); });
        }

        function handleDragEndCleanup() {
            if (currentlyDragging.pieceElement) currentlyDragging.pieceElement.classList.remove('dragging');
            currentlyDragging = { isDragging: false, pieceElement: null, startRow: -1, startCol: -1, pieceCode: null, validMoves: [] };
            validMoves = [];
            selectedSquare = null; // Clear any selection state
            justDragged = true;
            setTimeout(() => { justDragged = false; }, 100); // Reset after 100ms
            document.querySelectorAll('.square.highlight, .square.capture, .square.selected').forEach(el => el.classList.remove('highlight', 'capture', 'selected'));
            document.querySelectorAll('.piece.selected-piece').forEach(el => el.classList.remove('selected-piece'));
        }

        function saveState() {
            moveHistory.push({
                board: JSON.parse(JSON.stringify(board)),
                currentPlayer: currentPlayer,
                capturedPieces: JSON.parse(JSON.stringify(capturedPieces)),
                checkStatus: JSON.parse(JSON.stringify(checkStatus)),
                lastMove: JSON.parse(JSON.stringify(lastMove))
            });
        }
        function undoMove() {
            if (moveHistory.length > 1) {
                if (computerMoveTimeout) clearTimeout(computerMoveTimeout);

                // Pop the current state (the one we are in)
                moveHistory.pop();

                // In CPU games, we always want to return to a state where it's the player's turn
                if (gameMode !== '2P') {
                    while (moveHistory.length > 1 && moveHistory[moveHistory.length - 1].currentPlayer !== playerColor) {
                        moveHistory.pop();
                    }
                }

                const state = moveHistory[moveHistory.length - 1];
                board = JSON.parse(JSON.stringify(state.board));
                currentPlayer = state.currentPlayer;
                capturedPieces = JSON.parse(JSON.stringify(state.capturedPieces));
                checkStatus = JSON.parse(JSON.stringify(state.checkStatus));
                lastMove = JSON.parse(JSON.stringify(state.lastMove));

                gameOver = false;
                isComputerTurn = false;
                isAnimating = false;
                renderBoard();
                updateStatus();
            }
        }
        function startGame() { document.getElementById('mode-selection').style.display = 'none'; document.getElementById('game-area').style.display = 'block'; setupBoard(); }
        function updateStatus() { document.getElementById('status').textContent = (currentPlayer === 'w' ? "White" : "Black") + "'s Turn"; }
        function flipBoardView() {
            const boardEl = document.getElementById('board');
            const newOrientation = boardOrientation === 'w' ? 'b' : 'w';

            // Full 180 degree rotation on Z axis (spin like a clock hand)
            boardEl.style.transition = 'transform 0.8s cubic-bezier(0.4, 0, 0.2, 1)';
            boardEl.style.transform = 'rotateZ(180deg)';

            // After animation completes, reset transform and redraw with new orientation
            setTimeout(() => {
                boardOrientation = newOrientation;
                boardEl.style.transition = 'none';
                boardEl.style.transform = 'none';
                renderBoard();
            }, 800);
        }
        function toggleOptionsMenu(show = true) { document.getElementById('options-menu').classList.toggle('visible', show); }
        function quitGame() { location.reload(); }
        function resignGame() {
            gameOver = true;
            // Cooldowns reset on match end
            for (let s in spellCooldowns) spellCooldowns[s] = 0;
            renderActiveSpells();
            const winner = currentPlayer === 'w' ? 'Black' : 'White';
            showGameOverModal('Resigned', winner + ' Wins!');
            renderBoard();
            updateStatus();
        }

        function quitToMap() {
            // Reset state on exit
            activeSpell = null;
            spellTargets = [];
            for (let s in spellCooldowns) spellCooldowns[s] = 0;

            document.getElementById('game-over-modal').classList.remove('visible');
            document.getElementById('game-area').style.display = 'none';
            document.getElementById('game-coin-display').style.display = 'none';
            showCampaignMap();
        }

        function handleCampaignWin() {
            if (!campaignLevel) return;

            const earnedXp = campaignLevel.xp;
            campaignData.xp += earnedXp;

            // Win Bonus Coins
            campaignData.coins += Math.floor(earnedXp / 2);
            campaignData.coins += enemyKingBounty; // Add king's collected coins
            enemyKingBounty = 0;

            if (campaignLevel.id === campaignData.currentLevel) {
                campaignData.currentLevel++;

                // Chapter Milestone Unlocks (Levels 10, 20, 30, 40)
                const milestoneRaces = {
                    10: 'goblin',
                    20: 'orc',
                    30: 'undead',
                    40: 'highborne'
                };

                const raceToUnlock = milestoneRaces[campaignLevel.id];
                if (raceToUnlock && !campaignData.unlockedFactions.includes(raceToUnlock)) {
                    campaignData.unlockedFactions.push(raceToUnlock);
                    // Update milestone unlock message to work with the main victory screen
                    const milestoneMsg = `The ${raceToUnlock.charAt(0).toUpperCase() + raceToUnlock.slice(1)} faction has been unlocked.`;
                    showGameOverModal('Chapter Complete!', milestoneMsg, true);
                }
            }

            saveCampaign();
            updateUnlocksUI();
            updateXpBar();
            updateEconomyUI();
        }

        function showGameOverModal(title, message, isCampaignVictory = false) {
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-message').textContent = message;

            const backToMapBtn = document.getElementById('modal-back-to-map');
            const nextLevelBtn = document.getElementById('modal-next-level');
            const mainMenuBtn = document.getElementById('modal-main-menu');
            const undoBtn = document.getElementById('modal-undo-button');

            // Reset visibilities
            backToMapBtn.style.display = 'none';
            nextLevelBtn.style.display = 'none';
            mainMenuBtn.style.display = 'block';
            undoBtn.style.display = 'none';

            if (gameMode === 'CAMPAIGN') {
                if (isCampaignVictory) {
                    // Two buttons: Back to Map (Left) and Next Level (Right)
                    backToMapBtn.style.display = 'block';
                    mainMenuBtn.style.display = 'none';
                    const nextLvl = campaignLevels.find(l => l.id === campaignLevel.id + 1);
                    if (nextLvl) {
                        nextLevelBtn.style.display = 'block';
                        // Ensure layout: Left and Right
                        document.getElementById('game-over-buttons').style.flexDirection = 'row';
                    }
                } else {
                    backToMapBtn.style.display = 'block';
                }
            }

            // Show undo button only for stalemates
            if (title === 'Stalemate!') {
                undoBtn.style.display = 'block';
            }

            document.getElementById('game-over-modal').classList.add('visible');
        }

        function goToNextLevel() {
            const nextLvl = campaignLevels.find(l => l.id === campaignLevel.id + 1);
            if (nextLvl) {
                document.getElementById('game-over-modal').classList.remove('visible');
                startCampaignLevel(nextLvl);
            }
        }

        function undoAndCloseModal() {
            document.getElementById('game-over-modal').classList.remove('visible');
            undoMove();
        }

        function showPromotionModal(r, c, color, callback) {
            promotionState = { active: true, row: r, col: c, callback: callback };
            const opts = document.getElementById('promotion-options'); opts.innerHTML = '';
            ['q', 'r', 'b', 'n'].forEach(p => {
                const div = document.createElement('div');
                div.className = `promotion-choice ${raceSpritePrefix[color === 'w' ? whiteRace : blackRace]}${pieceNameMap[p]}`;
                div.onclick = () => { document.getElementById('promotion-modal').classList.remove('visible'); callback(p); };
                opts.appendChild(div);
            });
            document.getElementById('promotion-modal').classList.add('visible');
        }


        let currentShopTab = 'spells';
        function toggleShop(show) {
            const modal = document.getElementById('shop-modal');
            modal.classList.toggle('visible', show);
            if (show) renderShop();
        }

        function switchShopTab(tab) {
            currentShopTab = tab;
            document.querySelectorAll('.shop-tab').forEach(t => {
                t.classList.toggle('active', t.textContent.toLowerCase().includes(tab));
            });
            renderShop();
        }

        function renderShop() {
            const container = document.getElementById('shop-content');
            container.innerHTML = '';

            // Update gold display in bottom panel
            const goldAmountEl = document.getElementById('shop-gold-amount');
            if (goldAmountEl) goldAmountEl.textContent = campaignData.coins;

            if (currentShopTab === 'spells') {
                availableSpells.forEach(spell => {
                    const ownedCount = campaignData.inventory.spells[spell.id] || 0;
                    const item = document.createElement('div');
                    item.className = 'shop-item';
                    item.innerHTML = `
                        <div style="width: 100%; height: 60px; border-radius: 6px; margin-bottom: 10px; background: url('sprites/${spell.icon}') center/contain no-repeat, rgba(0,0,0,0.3); border: 1px solid #3f3f46;"></div>
                        <h4>${spell.name}</h4>
                        <p style="font-size: 0.8rem; color: #a1a1aa; margin-top: 4px;">${spell.description}</p>
                        <div class="price">
                            <img src="sprites/coin.png">
                            ${spell.cost} Gold
                        </div>
                        <button class="buy" onclick="buyItem('spell', '${spell.id}')" ${campaignData.coins < spell.cost ? 'disabled' : ''}>
                            Purchase (Owned: ${ownedCount})
                        </button>
                    `;
                    container.appendChild(item);
                });
            } else if (currentShopTab === 'upgrades') {
                availableUpgrades.forEach(upg => {
                    const isOwned = campaignData.spellLevels[upg.id] >= 2;
                    const item = document.createElement('div');
                    item.className = 'shop-item';

                    const spell = availableSpells.find(s => s.id === upg.id);
                    const icon = spell ? spell.icon : 'spell_swap.png';

                    item.innerHTML = `
                        <div style="width: 100%; height: 60px; border-radius: 6px; margin-bottom: 10px; background: url('sprites/${icon}') center/contain no-repeat, rgba(0,0,0,0.3); border: 1px solid #3f3f46; position: relative;">
                            <div style="position: absolute; top: 5px; right: 5px; background: #fbbf24; color: #000; font-size: 0.7rem; font-weight: bold; padding: 2px 5px; border-radius: 4px;">LVL 2</div>
                        </div>
                        <h4>${upg.name}</h4>
                        <p style="font-size: 0.8rem; color: #a1a1aa; margin-top: 4px;">${upg.description}</p>
                        <div class="price">
                            ${isOwned ? '<span style="color: #4ade80;">Acquired</span>' : `<img src="sprites/coin.png"> ${upg.cost} Gold`}
                        </div>
                        <button class="${isOwned ? 'owned' : 'buy'}" onclick="${isOwned ? '' : `buyItem('spell-upgrade', '${upg.id}')`}" ${!isOwned && campaignData.coins < upg.cost ? 'disabled' : ''}>
                            ${isOwned ? 'Mastered' : 'Upgrade'}
                        </button>
                    `;
                    container.appendChild(item);
                });
            } else {
                availableTilesets.forEach(ts => {
                    if (ts.id === 'classic') return; // Default
                    const isOwned = campaignData.unlockedTilesets.includes(ts.id);
                    const item = document.createElement('div');
                    item.className = 'shop-item';

                    // Use tileset preview logic
                    let bgStyle = ts.texture ? `background-image: url('textures/${ts.texture}')` : `background: linear-gradient(45deg, #eeeed2 50%, #769656 50%)`;

                    item.innerHTML = `
                        <div style="width: 100%; height: 60px; border-radius: 6px; margin-bottom: 10px; ${bgStyle}; background-size: cover; border: 1px solid #3f3f46; ${!ts.texture ? 'background: linear-gradient(45deg, #eeeed2 50%, #769656 50%)' : ''}"></div>
                        <h4>${ts.name}</h4>
                        <div class="price">
                            ${isOwned ? '<span style="color: #4ade80;">Collected</span>' : `<img src="sprites/coin.png"> ${ts.cost} Gold`}
                        </div>
                        <button class="${isOwned ? 'owned' : 'buy'}" onclick="${isOwned ? '' : `buyItem('tileset', '${ts.id}')`}" ${!isOwned && campaignData.coins < ts.cost ? 'disabled' : ''}>
                            ${isOwned ? 'Acquired' : 'Purchase'}
                        </button>
                    `;
                    container.appendChild(item);
                });
            }
        }

        function buyItem(type, id) {
            if (type === 'spell') {
                const spell = availableSpells.find(s => s.id === id);
                if (campaignData.coins >= spell.cost) {
                    campaignData.coins -= spell.cost;
                    campaignData.inventory.spells[id]++;
                    saveCampaign();
                    updateEconomyUI();
                    renderShop();
                }
            } else if (type === 'spell-upgrade') {
                const upg = availableUpgrades.find(u => u.id === id);
                if (campaignData.coins >= upg.cost && campaignData.spellLevels[id] < 2) {
                    campaignData.coins -= upg.cost;
                    campaignData.spellLevels[id] = 2;
                    saveCampaign();
                    updateEconomyUI();
                    renderShop();
                }
            } else if (type === 'tileset') {
                const ts = availableTilesets.find(t => t.id === id);
                if (campaignData.coins >= ts.cost && !campaignData.unlockedTilesets.includes(id)) {
                    campaignData.coins -= ts.cost;
                    campaignData.unlockedTilesets.push(id);
                    saveCampaign();
                    updateEconomyUI();
                    renderShop();
                    renderTilesets(); // Update main menu list
                }
            }
        }

        function handleSpellClick(r, c) {
            const code = board[r][c];
            if (activeSpell === 'swap') {
                const lvl = campaignData.spellLevels.swap;
                const opp = playerColor === 'w' ? 'b' : 'w';
                const isValidTarget = (code && code !== 'X') && (code[0] === playerColor || (lvl >= 2 && code[0] === opp && code[1] !== 'k'));

                if (isValidTarget) {
                    if (spellTargets.length === 0) {
                        spellTargets.push({ r, c });
                        renderBoard();
                    } else {
                        const target1 = spellTargets[0];
                        const target2 = { r, c };
                        if (target1.r === target2.r && target1.c === target2.c) {
                            // Clicked same piece - unselect it
                            spellTargets = [];
                            renderBoard();
                            return;
                        }

                        const p1 = board[target1.r][target1.c];
                        const p2 = board[target2.r][target2.c];
                        board[target1.r][target1.c] = p2;
                        board[target2.r][target2.c] = p1;

                        campaignData.inventory.spells.swap--;
                        spellCooldowns.swap = 6;
                        saveCampaign();
                        activeSpell = null;
                        spellTargets = [];
                        boardElement.style.cursor = 'default';
                        boardElement.classList.remove('spell-active');
                        finalizeMove();
                    }
                } else if (spellTargets.length > 0) {
                    // Clicked something invalid while a piece was selected - clear it
                    spellTargets = [];
                    renderBoard();
                }
            } else if (activeSpell === 'summon') {
                const lvl = campaignData.spellLevels.summon;
                const isTerritory = playerColor === 'w' ? r >= 4 : r <= 3;
                if ((!code || code === 'coin') && isTerritory) {
                    board[r][c] = playerColor + 'p';
                    spellTargets.push({ r, c });

                    const needed = (lvl >= 2) ? 2 : 1;
                    if (spellTargets.length >= needed) {
                        campaignData.inventory.spells.summon--;
                        spellCooldowns.summon = 6;
                        saveCampaign();
                        activeSpell = null;
                        spellTargets = [];
                        boardElement.style.cursor = 'default';
                        boardElement.classList.remove('spell-active');
                        finalizeMove();
                    } else {
                        renderBoard();
                    }
                }
            } else if (activeSpell === 'fortify') {
                if (!code || code === 'coin') {
                    const lvl = campaignData.spellLevels.fortify;
                    const duration = (lvl >= 2) ? 10 : 6;
                    board[r][c] = 'X';
                    tempWalls.push({ row: r, col: c, turnsLeft: duration });

                    campaignData.inventory.spells.fortify--;
                    spellCooldowns.fortify = 6;
                    saveCampaign();
                    activeSpell = null;
                    boardElement.style.cursor = 'default';
                    boardElement.classList.remove('spell-active');
                    finalizeMove();
                }
            } else if (activeSpell === 'shield') {
                const lvl = campaignData.spellLevels.shield;
                const rows = board.length, cols = board[0].length;
                if (lvl >= 2) {
                    // Vanguard Shield: Click anywhere to shield pieces in the cross
                    const targets = [{ r, c }, { r: r - 1, c }, { r: r + 1, c }, { r, c: c - 1 }, { r, c: c + 1 }];
                    let anyShielded = false;
                    targets.forEach(t => {
                        if (t.r >= 0 && t.r < rows && t.c >= 0 && t.c < cols) {
                            const p = board[t.r][t.c];
                            if (p && p !== 'X' && p[0] === playerColor) {
                                shieldedPieces.push({ row: t.r, col: t.c, turnsLeft: 1 });
                                anyShielded = true;
                            }
                        }
                    });
                    // Only spend if at least one piece protected? 
                    // No, spend it anyway like freeze.
                    campaignData.inventory.spells.shield--;
                    spellCooldowns.shield = 6;
                    saveCampaign();
                    activeSpell = null;
                    boardElement.style.cursor = 'default';
                    boardElement.classList.remove('spell-active');
                    finalizeMove();
                } else {
                    if (code && code !== 'X' && code[0] === playerColor) {
                        shieldedPieces.push({ row: r, col: c, turnsLeft: 1 });
                        campaignData.inventory.spells.shield--;
                        spellCooldowns.shield = 6;
                        saveCampaign();
                        activeSpell = null;
                        boardElement.style.cursor = 'default';
                        boardElement.classList.remove('spell-active');
                        finalizeMove();
                    }
                }
            } else if (activeSpell === 'freeze') {
                const opp = playerColor === 'w' ? 'b' : 'w';
                const lvl = campaignData.spellLevels.freeze;
                const rows = board.length, cols = board[0].length;

                if (lvl >= 2) {
                    // Deep Freeze: 2x2 area (clicked square is top-left)
                    for (let i = 0; i < 2; i++) {
                        for (let j = 0; j < 2; j++) {
                            const nr = r + i, nc = c + j;
                            if (nr < rows && nc < cols) {
                                const piece = board[nr][nc];
                                if (piece && piece !== 'X' && piece[0] === opp && piece[1] !== 'k') {
                                    frozenPieces.push({ row: nr, col: nc, turnsLeft: 1 });
                                }
                            }
                        }
                    }
                    campaignData.inventory.spells.freeze--;
                    spellCooldowns.freeze = 6;
                    saveCampaign();
                    activeSpell = null;
                    boardElement.style.cursor = 'default';
                    boardElement.classList.remove('spell-active');
                    finalizeMove();
                } else {
                    if (code && code !== 'X' && code[0] === opp && code[1] !== 'k') {
                        frozenPieces.push({ row: r, col: c, turnsLeft: 1 });
                        campaignData.inventory.spells.freeze--;
                        spellCooldowns.freeze = 6;
                        saveCampaign();
                        activeSpell = null;
                        boardElement.style.cursor = 'default';
                        boardElement.classList.remove('spell-active');
                        finalizeMove();
                    }
                }
            }
        }

        function assessLayout() {
            const w = window.innerWidth, h = window.innerHeight;
            const isDesktop = w > h && w > 700;
            document.body.classList.toggle('layout-desktop', isDesktop);

            // Calculate optimal board size
            const panelSize = isDesktop ? 280 : 180;
            const margin = 20;
            let boardSize;

            if (isDesktop) {
                // Desktop: board + panel side by side
                const maxBoardWidth = w - panelSize - margin * 3;
                const maxBoardHeight = h - margin * 2;
                boardSize = Math.min(maxBoardWidth, maxBoardHeight);
            } else {
                // Mobile: board on top, panel below
                const maxBoardWidth = w - margin * 2;
                const maxBoardHeight = h - panelSize - margin * 3;
                boardSize = Math.min(maxBoardWidth, maxBoardHeight);
            }

            // Ensure minimum and maximum
            boardSize = Math.max(300, Math.min(800, boardSize));
            document.documentElement.style.setProperty('--board-base-size', boardSize + 'px');
        }

        document.addEventListener('DOMContentLoaded', () => {
            boardElement.addEventListener('click', handleSquareClick);
            boardElement.addEventListener('mousedown', handleSquareClick);

            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (activeSpell) {
                        activeSpell = null;
                        spellTargets = [];
                        boardElement.style.cursor = 'default';
                        renderActiveSpells();
                        renderBoard();
                    } else if (selectedSquare) {
                        clearSelection();
                    } else if (document.getElementById('shop-modal').classList.contains('visible')) {
                        toggleShop(false);
                    }
                }
            });
            boardElement.addEventListener('dragstart', handleDragStart);
            boardElement.addEventListener('dragover', e => {
                e.preventDefault();
                if (currentlyDragging.isDragging) e.dataTransfer.dropEffect = 'move';
            });
            boardElement.addEventListener('drop', handleDrop);
            boardElement.addEventListener('dragend', handleDragEnd);
            window.addEventListener('resize', assessLayout);
            assessLayout();

            // Custom Tooltip Engine
            const tooltipEl = document.getElementById('tooltip');
            window.addEventListener('mousemove', (e) => {
                const target = e.target.closest('[data-tooltip-side]');
                if (target) {
                    const side = target.dataset.tooltipSide;
                    const info = target.dataset.tooltipInfo;

                    if (side === 'Gold') {
                        tooltipEl.innerHTML = `<div class="piece-info" style="color: #fbbf24; font-weight: 700; border: none;">${info}</div>`;
                    } else {
                        const sideClass = side === 'White' ? 'side-white' : 'side-black';
                        tooltipEl.innerHTML = `
                            ${side ? `<div class="side-header ${sideClass}">${side}</div>` : ''}
                            <div class="piece-info">${info}</div>
                        `;
                    }

                    tooltipEl.style.visibility = 'visible';
                    tooltipEl.style.left = (e.clientX + 15) + 'px';
                    tooltipEl.style.top = (e.clientY + 15) + 'px';
                } else {
                    tooltipEl.style.visibility = 'hidden';
                }
            });

            document.getElementById('mode-cpu').onclick = () => {
                gameMode = 'CPU'; document.getElementById('mode-cpu').classList.add('selected'); document.getElementById('mode-2p').classList.remove('selected');
                document.getElementById('cpu-options-container').style.display = 'flex'; document.getElementById('race-selection-container').style.display = 'flex';
                document.getElementById('mode-campaign').style.display = 'block';
                startGameButton.disabled = false;
            };
            document.getElementById('mode-2p').onclick = () => {
                gameMode = '2P'; document.getElementById('mode-2p').classList.add('selected'); document.getElementById('mode-cpu').classList.remove('selected');
                document.getElementById('cpu-options-container').style.display = 'none'; document.getElementById('race-selection-container').style.display = 'flex';
                document.getElementById('mode-campaign').style.display = 'none';
                startGameButton.disabled = false;
            };
            document.getElementById('mode-campaign').onclick = showCampaignMap;
            // Difficulty selection
            const diffBtns = document.querySelectorAll('.difficulty-buttons button');
            diffBtns.forEach(btn => {
                btn.onclick = () => {
                    currentDifficulty = btn.dataset.difficulty;
                    diffBtns.forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                };
            });
            // Set default difficulty visual
            document.querySelector('[data-difficulty="CPU-medium"]').classList.add('selected');

            // Set default mode
            document.getElementById('mode-cpu').click();

            whiteRaceSelect.onchange = updateRacePreviews; blackRaceSelect.onchange = updateRacePreviews; updateRacePreviews();

            loadCampaign();
            renderTilesets();
            updateXpBar();

            // Cheat Codes
            window.addEventListener('keydown', (e) => {
                if (e.shiftKey && e.key.toLowerCase() === 't') {
                    if (gameMode === 'CAMPAIGN' && !gameOver && campaignLevel) {
                        e.preventDefault();
                        const nextId = campaignLevel.id + 1;
                        handleCampaignWin();
                        const nextLvl = campaignLevels.find(l => l.id === nextId);
                        if (nextLvl) {
                            startCampaignLevel(nextLvl);
                        } else {
                            quitToMap();
                        }
                    }
                }
                if (e.shiftKey && e.key.toLowerCase() === 'g') {
                    e.preventDefault();
                    campaignData.coins += 100;
                    saveCampaign();
                    updateEconomyUI();
                }
            });
        });
    </script>
</body>

</html>

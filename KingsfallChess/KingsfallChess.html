<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Kingsfall Chess</title>
    <style>
        /* --- Global Styles & Setup --- */
        :root {
            /* --- Sizing Variables --- */
            --board-base-size: min(480px, 90vw);
            --panel-width-side: 180px;
            --panel-width-side-fullscreen: 240px; /* Wider panel for fullscreen desktop */
            --panel-height-bottom: 180px; /* Approximate */

            /* --- Colors & Highlights (Classic) --- */
            --light-square: #f0d9b5;
            --dark-square: #b58863;
            --panel-bg: var(--light-square);
            --panel-text: #6a4a3a;
            --panel-border: #d3bfa8;
            --button-bg: rgba(181, 136, 99, 0.85);
            --button-bg-hover: var(--dark-square);
            --button-border: var(--dark-square);
            --button-text: #ffffff;
            --container-bg: #ffffff;
            --body-bg: #dcdcdc;
            --highlight-selected: rgba(30, 100, 200, 0.7);
            --highlight-move: rgba(0, 100, 0, 0.4);
            --highlight-capture: rgba(200, 0, 0, 0.5);
            --highlight-last-start: rgba(220, 220, 100, 0.35);
            --highlight-last-end: rgba(180, 220, 100, 0.4);
            --highlight-check: rgba(255, 0, 0, 0.5);
            --highlight-drag-over: rgba(70, 130, 180, 0.3);
            --animation-speed: 0.3s;

            /* --- Tile Art Variables (Defaults point to nothing initially) --- */
            --tile-light-bg-image: none;
            --tile-dark-bg-image: none;
        }

        html, body { height: 100%; overscroll-behavior: none; margin: 0; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; justify-content: center; align-items: center; padding: 10px; box-sizing: border-box; background-color: var(--body-bg); min-height: 100%; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; -webkit-touch-callout: none; -webkit-tap-highlight-color: transparent; }
        #game-container { display: flex; flex-direction: column; align-items: center; background-color: var(--container-bg); padding: 15px; border-radius: 10px; box-shadow: 0 5px 20px rgba(0,0,0,0.1); transition: all 0.3s ease-in-out; position: relative; width: 100%; max-width: calc(var(--board-base-size) + 30px); box-sizing: border-box; margin: auto; }

        /* --- Mode Selection Styling (Unchanged) --- */
        #mode-selection { background-color: var(--panel-bg); color: var(--panel-text); border-radius: 8px; margin-bottom: 20px; border: 1px solid var(--panel-border); width: 100%; height: auto; min-height: var(--board-base-size); max-height: 80vh; box-sizing: border-box; box-shadow: inset 0 0 10px rgba(0,0,0,0.05); display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 15px; overflow-y: auto; }
        #mode-selection h2 { margin-top: 0; margin-bottom: 15px; color: var(--dark-square); font-weight: 600; font-size: 1.4em; text-align: center;}
        .mode-type-selection { width: 100%; box-sizing: border-box; text-align: center; }
        .mode-type-selection button { display: block; width: 80%; max-width: 250px; margin: 8px auto; padding: 10px 15px; font-size: 1.0em; font-weight: 500; cursor: pointer; border: 1px solid var(--button-border); border-radius: 5px; background-color: rgba(255,255,255,0.4); color: var(--panel-text); transition: background-color 0.2s, box-shadow 0.2s; }
        .mode-type-selection button:hover { background-color: rgba(255,255,255,0.7); box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .mode-type-selection button.selected { background-color: var(--button-bg); color: var(--button-text); font-weight: bold; }
        #cpu-options-container { display: none; flex-direction: column; align-items: center; width: 100%; max-width: 400px; margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--panel-border); gap: 15px; transition: opacity 0.3s ease-in-out; }
        #cpu-options-container.options-disabled { opacity: 0.4; pointer-events: none; cursor: not-allowed; }
        #cpu-options-container.options-disabled button, #cpu-options-container.options-disabled .side-option { pointer-events: none; cursor: not-allowed; }
        #difficulty-choice { width: 100%; display: flex; flex-direction: column; align-items: center; gap: 8px; }
        #difficulty-choice h3 { font-size: 0.9em; margin-bottom: 5px; font-weight: 500; text-align: center; }
        #difficulty-choice button { padding: 6px 12px; width: 120px; font-size: 0.9em; cursor: pointer; border: 1px solid var(--panel-border); border-radius: 4px; background-color: #fff; color: var(--panel-text); transition: background-color 0.2s; }
        #difficulty-choice button:hover { background-color: #eee; }
        #difficulty-choice button.selected { background-color: var(--dark-square); color: white; font-weight: bold; border-color: var(--dark-square); }
        #player-side-choice { width: 100%; text-align: center; }
        #player-side-choice h3 { font-size: 0.9em; margin-bottom: 8px; font-weight: 500; }
        .side-option { display: inline-block; margin: 0 10px; padding: 5px; border-radius: 5px; cursor: pointer; transition: background-color 0.2s; text-align: center; vertical-align: top; }
        .side-option input[type="radio"] { display: none; }
        .side-option img { width: 35px; height: 35px; display: block; margin: 0 auto 3px auto; pointer-events: none; }
        .side-option label { font-weight: 500; pointer-events: none; display: block; font-size: 0.85em; }
        .side-option:hover { background-color: rgba(181, 136, 99, 0.1); }
        .side-option.selected { background-color: rgba(181, 136, 99, 0.25); }
        #start-button-container { margin-top: 20px; padding-top: 15px; border-top: 1px solid var(--panel-border); width: 90%; text-align: center; }
        #start-game-button { padding: 12px 30px; font-size: 1.1em; cursor: pointer; background-color: var(--button-bg); color: var(--button-text); border: 1px solid var(--button-border); border-radius: 5px; transition: background-color 0.2s; font-weight: bold; }
        #start-game-button:hover:not(:disabled) { background-color: var(--button-bg-hover); }
        #start-game-button:disabled { background-color: #ccc; border-color: #bbb; color: #777; cursor: not-allowed; opacity: 0.6; }

        /* --- Game Area --- */
        #game-area { display: none; width: 100%; }
        #board-and-panels { display: flex; flex-direction: column; align-items: center; width: 100%; }
        #board {
            width: var(--board-base-size);
            height: var(--board-base-size);
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 2px solid #333; /* Simplified borders */
            transition: transform 0.5s ease-in-out;
            box-sizing: border-box;
            background-color: #888; /* Fallback background */
            position: relative;
            overflow: hidden;
            touch-action: none;
            flex-shrink: 0;
            z-index: 2;
        }
        #board.board-flipped { transform: rotate(180deg); }

        /* --- Squares & Pieces --- */
        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            cursor: pointer;
            position: relative; /* Needed for dark overlay */
            transition: background-color 0.15s ease-in-out;
            overflow: hidden; /* Ensure overlay stays within bounds */
            background-size: cover; /* Set size for image tiles */
            background-position: center;
            background-repeat: no-repeat;
        }
        /* Classic Colors (Default - applied when themed-tiles is NOT present) */
        .square.light { background-color: var(--light-square); }
        .square.dark { background-color: var(--dark-square); }

        /* Themed Tile Styles */
        #board.themed-tiles .square { background-color: transparent; } /* Override classic color */
        #board.themed-tiles .square.light { background-image: var(--tile-light-bg-image); }
        #board.themed-tiles .square.dark { background-image: var(--tile-dark-bg-image); }
        /* Dark Square Overlay for Themed Tiles */
        #board.themed-tiles .square.dark::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.25); /* Adjust darkness */
            pointer-events: none;
            z-index: 1; /* Place below piece */
        }

        .board-flipped .square { transform: rotate(180deg); }
        .piece { width: 90%; height: 90%; background-size: contain; background-repeat: no-repeat; background-position: center; image-rendering: -webkit-optimize-contrast; image-rendering: crisp-edges; z-index: 5; /* Above dark overlay */ cursor: grab; touch-action: none; }
        .piece.dragging { cursor: grabbing; }
        .piece.piece-ghost { opacity: 0.3; transition: opacity 0.1s ease-out; }
        .piece.hidden-during-move { opacity: 0 !important; transition: none !important; }

        /* Highlights (Default) */
        .selected { outline: 3px solid var(--highlight-selected); outline-offset: -3px; background-color: rgba(80, 140, 220, 0.05) !important; }
        .highlight::after { content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 25%; height: 25%; background-color: var(--highlight-move); border-radius: 50%; pointer-events: none; z-index: 3; box-sizing: border-box; }
        .highlight.capture::after { width: 85%; height: 85%; background-color: transparent; border: 5px solid var(--highlight-capture); border-radius: 50%; }
        .check { box-shadow: inset 0 0 10px 5px var(--highlight-check); z-index: 2; } /* Ensure check is above dark overlay */
        .last-move-start { background-color: var(--highlight-last-start) !important; }
        .last-move-end { background-color: var(--highlight-last-end) !important; }
        .drag-over-highlight { background-color: var(--highlight-drag-over) !important; }
        .moving-piece { background-size: contain; background-repeat: no-repeat; background-position: center; image-rendering: -webkit-optimize-contrast; image-rendering: crisp-edges; transition: transform var(--animation-speed) ease-in-out; touch-action: none; z-index: 1000; }

        /* Highlight Adjustments for Themed Tiles */
        #board.themed-tiles .selected { outline-color: rgba(50, 150, 255, 0.9); outline-width: 4px; outline-offset: -4px; background-color: rgba(50, 150, 255, 0.1) !important; }
        #board.themed-tiles .highlight::after { background-color: rgba(255, 255, 255, 0.6); border: 1px solid rgba(0,0,0,0.5); box-shadow: 0 0 5px rgba(0,0,0,0.3); }
        #board.themed-tiles .highlight.capture::after { border-width: 6px; border-color: rgba(255, 50, 50, 0.8); background-color: rgba(255, 50, 50, 0.1); }
        #board.themed-tiles .check { box-shadow: inset 0 0 15px 8px rgba(255, 0, 0, 0.7); }
        #board.themed-tiles .last-move-start { background-color: rgba(255, 255, 150, 0.5) !important; }
        #board.themed-tiles .last-move-end { background-color: rgba(200, 255, 150, 0.55) !important; }
        #board.themed-tiles .drag-over-highlight { background-color: rgba(70, 130, 180, 0.4) !important; }

        /* Sprites (Unchanged) */
        .wp { background-image: url('sprites/wPawn.png'); } .wr { background-image: url('sprites/wRook.png'); } .wn { background-image: url('sprites/wKnight.png'); } .wb { background-image: url('sprites/wBishop.png'); } .wq { background-image: url('sprites/wQueen.png'); } .wk { background-image: url('sprites/wKing.png'); }
        .bp { background-image: url('sprites/bPawn.png'); } .br { background-image: url('sprites/bRook.png'); } .bn { background-image: url('sprites/bKnight.png'); } .bb { background-image: url('sprites/bBishop.png'); } .bq { background-image: url('sprites/bQueen.png'); } .bk { background-image: url('sprites/bKing.png'); }

        /* Panel Styling (Mobile First - Bottom Panel) */
        #panel {
            width: var(--board-base-size);
            height: auto;
            min-height: var(--panel-height-bottom);
            background-color: var(--panel-bg);
            padding: 10px;
            border-top: none; /* Board provides separator */
            border-left: 2px solid #333;
            border-right: 2px solid #333;
            border-bottom: 2px solid #333;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            color: var(--panel-text);
            flex-shrink: 0;
        }
        #status { font-size: 1.1em; font-weight: bold; min-height: 1.4em; text-align: center; margin-bottom: 8px; border-bottom: 1px solid var(--panel-border); padding-bottom: 8px; }
        #captured-heading { margin-top: 5px; margin-bottom: 3px; font-size: 0.85em; font-weight: normal; text-transform: uppercase; letter-spacing: 0.5px; border-bottom: none; padding-bottom: 0; text-align: center; }
        #captured-pieces-box { background-color: rgba(255, 255, 255, 0.3); border: 1px solid var(--panel-border); border-radius: 4px; padding: 6px; margin-bottom: 10px; min-height: 48px; max-height: 100px; display: flex; flex-direction: column; justify-content: space-between; gap: 4px; overflow-y: auto; flex-grow: 1; }
        .captured-list { display: flex; flex-wrap: wrap; gap: 3px; min-height: 20px; align-content: flex-start; }
        .captured-piece { width: 20px; height: 20px; background-size: contain; background-repeat: no-repeat; background-position: center; image-rendering: -webkit-optimize-contrast; image-rendering: crisp-edges; }
        #panel-buttons { margin-top: auto; padding-top: 10px; border-top: 1px solid var(--panel-border); display: flex; flex-wrap: wrap; justify-content: space-around; gap: 8px; }
        #panel button { padding: 8px 12px; font-size: 0.9em; cursor: pointer; border: 1px solid var(--button-border); border-radius: 4px; background-color: var(--button-bg); color: var(--button-text); transition: background-color 0.2s, opacity 0.2s; text-align: center; font-weight: bold; flex-basis: calc(50% - 10px); min-width: 100px; box-sizing: border-box; }
        #panel button svg { width: 14px; height: 14px; vertical-align: middle; fill: currentColor; }
        #quit-button { flex-basis: 100%; margin-top: 5px; }
        #panel button:hover:not(:disabled) { background-color: var(--button-bg-hover); }
        #panel button:disabled { background-color: rgba(181, 136, 99, 0.4); color: #eaddcf; cursor: not-allowed; border-color: rgba(181, 136, 99, 0.5); opacity: 0.7; }

        /* --- NEW: Options Menu Styles --- */
        #options-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--panel-bg);
            border: 2px solid var(--dark-square);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            z-index: 2010; /* Above modal overlay */
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 15px;
            min-width: 280px;
            max-width: 90vw;
            color: var(--panel-text);
        }
        #options-menu.visible { display: flex; }
        #options-menu h3 { margin: 0 0 10px 0; text-align: center; color: var(--dark-square); font-size: 1.2em; border-bottom: 1px solid var(--panel-border); padding-bottom: 8px; }
        .menu-section { display: flex; flex-direction: column; gap: 8px; }
        .menu-section label { font-weight: bold; font-size: 0.9em; margin-bottom: 4px; }
        #options-menu button, #options-menu .menu-button { /* Style buttons inside menu */
            padding: 8px 15px; font-size: 0.95em; cursor: pointer; border: 1px solid var(--button-border); border-radius: 4px; background-color: var(--button-bg); color: var(--button-text); transition: background-color 0.2s; font-weight: bold; width: 100%; box-sizing: border-box; text-align: center;
        }
        #options-menu button:hover, #options-menu .menu-button:hover { background-color: var(--button-bg-hover); }
        #options-menu button.selected, #options-menu .menu-button.selected { background-color: var(--dark-square); outline: 2px solid white; }
        #volume-control { display: flex; align-items: center; gap: 10px; }
        #volume-slider { flex-grow: 1; cursor: pointer; accent-color: var(--dark-square); }
        #volume-label { min-width: 30px; text-align: right; font-size: 0.9em; }
        #tile-art-options { display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 8px; }
        #close-menu-button { background-color: #aaa; border-color: #888; color: #fff; margin-top: 10px;}
        #close-menu-button:hover { background-color: #888; }

        /* Computer Thinking State */
        body.computer-thinking #board { cursor: wait; }
        body.computer-thinking .square { pointer-events: none !important; }
        body.computer-thinking .piece { cursor: wait !important; }
        body.computer-thinking #panel button { pointer-events: none !important; opacity: 0.5 !important; cursor: wait !important; }
        body.computer-thinking #menu-button { pointer-events: auto !important; opacity: 1 !important; cursor: pointer !important; } /* Allow opening menu */
        body.computer-thinking #options-menu { pointer-events: auto !important; } /* Allow using menu */
        body.computer-thinking #options-menu button:not(#close-menu-button) { /* Disable options within menu */
             /* pointer-events: none !important; */ /* Allow toggling FS etc */
             /* opacity: 0.6 !important; */
             /* cursor: wait !important; */
        }

        /* Game Over Modal Styles (Unchanged) */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: none; justify-content: center; align-items: center; z-index: 2000; opacity: 0; transition: opacity 0.3s ease-in-out; padding: 15px; box-sizing: border-box; }
        .modal-overlay.visible { display: flex; opacity: 1; }
        .modal-content { background-color: var(--panel-bg); padding: 25px 30px; border-radius: 8px; border: 2px solid var(--dark-square); text-align: center; color: var(--panel-text); box-shadow: 0 8px 25px rgba(0,0,0,0.4); max-width: 350px; width: 95%; transform: scale(0.9); transition: transform 0.3s ease-in-out; }
        .modal-overlay.visible .modal-content { transform: scale(1.0); }
        #modal-title { color: var(--dark-square); margin-top: 0; margin-bottom: 15px; font-size: 1.6em; font-weight: bold; }
        #modal-message { margin-bottom: 25px; font-size: 1.1em; line-height: 1.5; }
        #new-game-button { padding: 12px 30px; font-size: 1.1em; cursor: pointer; background-color: var(--button-bg); color: var(--button-text); border: 1px solid var(--button-border); border-radius: 5px; transition: background-color 0.2s; font-weight: bold; display: inline-block; }
        #new-game-button:hover { background-color: var(--button-bg-hover); }

        /* Media Query for Desktop Layout (Side Panel) */
        @media (min-width: 720px) {
            #game-container { max-width: calc(var(--board-base-size) + var(--panel-width-side) + 40px); /* Account for panel */ }
            #board-and-panels { flex-direction: row; align-items: flex-start; }
            #board { border-right: 2px solid #333; border-bottom: 2px solid #333; } /* Keep separator */
            #panel {
                width: var(--panel-width-side);
                height: var(--board-base-size);
                min-height: unset;
                border-top: 2px solid #333;
                border-left: none; /* Board provides left separator */
                margin-top: 0; margin-left: 0;
            }
            #panel-buttons { flex-direction: column; flex-wrap: nowrap; gap: 6px; }
            #panel button { flex-basis: auto; width: 100%; min-width: unset; }
            .button-row { display: flex; justify-content: space-between; gap: 6px; width: 100%; }
            .button-row button { flex: 1; width: auto; }
            #quit-button { margin-top: 6px; }
             /* Position menu relative to container edge maybe */
             #options-menu { /* Adjust position slightly for desktop */ top: 15px; left: auto; right: 15px; transform: none; }
        }

        /* Fullscreen Scaling */
        #game-container:fullscreen { padding: 0; border-radius: 0; box-shadow: none; width: 100vw; height: 100vh; max-width: none; display: flex; justify-content: center; align-items: center; overflow: hidden; background-color: var(--body-bg); }
        #game-container:fullscreen #game-area { width: auto; height: auto; display: contents; }
        #game-container:fullscreen #board-and-panels { width: auto; height: auto; max-width: 98vw; max-height: 98vh; }

        /* --- Combined Fullscreen Board & Panel Sizing --- */
        /* Default (Mobile / Stacked Panel) Fullscreen */
        #game-container:fullscreen #board {
             width: min(95vw, calc(95vh - var(--panel-height-bottom) - 10px));
             height: min(95vw, calc(95vh - var(--panel-height-bottom) - 10px));
             border: 2px solid #333; /* Consistent border */
        }
        #game-container:fullscreen #panel {
             width: min(95vw, calc(95vh - var(--panel-height-bottom) - 10px));
             height: auto;
             min-height: 100px; max-height: var(--panel-height-bottom);
             margin-top: 0; margin-left: 0;
             border: 2px solid #333; border-top: none;
             overflow: auto;
        }

        /* Desktop (Side Panel) Fullscreen */
        @media (min-width: 720px) {
             #game-container:fullscreen #board {
                  width: min(calc(95vw - var(--panel-width-side-fullscreen) - 10px), 95vh);
                  height: min(calc(95vw - var(--panel-width-side-fullscreen) - 10px), 95vh);
                  border: 2px solid #333; border-right: 2px solid #333; /* Separator */
             }
             #game-container:fullscreen #panel {
                  width: var(--panel-width-side-fullscreen);
                  height: min(calc(95vw - var(--panel-width-side-fullscreen) - 10px), 95vh);
                  min-height: unset; max-height: unset;
                  margin-left: 0; margin-top: 0;
                  border: 2px solid #333; border-left: none; border-top: 2px solid #333;
                  overflow: auto;
             }
             #game-container:fullscreen #panel #captured-pieces-box {
                  min-height: 220px; max-height: 450px; flex-grow: 1; padding: 8px; gap: 6px;
             }
             #game-container:fullscreen #panel #captured-pieces-box .captured-piece {
                 width: 28px; height: 28px;
             }
              #game-container:fullscreen #panel #captured-pieces-box .captured-list {
                 gap: 4px;
             }
             /* Position menu relative to viewport edge in FS desktop */
             #game-container:fullscreen #options-menu { top: 10px; right: 10px; transform: none; }
        }

        /* Small Screen Fine-tuning (Unchanged) */
        @media (max-width: 400px) { :root { --board-base-size: 92vw; } #mode-selection h2 { font-size: 1.3em; } .mode-type-selection button { font-size: 0.95em; padding: 8px 12px; } #difficulty-choice button { width: 100px; font-size: 0.85em; padding: 5px 10px;} .side-option img { width: 30px; height: 30px;} #start-game-button { font-size: 1em; padding: 10px 25px;} #status { font-size: 1em; } #captured-heading { font-size: 0.8em; } .captured-piece { width: 18px; height: 18px; } #panel button { font-size: 0.85em; padding: 7px 10px; min-width: 80px;} #modal-title { font-size: 1.5em; } #modal-message { font-size: 1em; } #new-game-button { font-size: 1em; padding: 10px 25px;} }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Mode Selection (HTML Unchanged) -->
        <div id="mode-selection">
            <h2>Kingsfall Chess</h2>
            <div class="mode-type-selection">
                <button id="mode-cpu">1 Player</button>
                <button id="mode-2p">2 Player</button>
            </div>
            <div id="cpu-options-container">
                <div id="difficulty-choice">
                    <h3>Select Difficulty:</h3>
                    <button data-difficulty="CPU-easy">Easy</button>
                    <button data-difficulty="CPU-medium">Medium</button>
                    <button data-difficulty="CPU-hard">Hard</button>
                </div>
                <div id="player-side-choice">
                    <h3>Choose your side:</h3>
                    <div class="side-option selected" id="side-human">
                        <input type="radio" name="playerSide" value="w" id="radio-human" checked>
                        <img src="sprites/wKing.png" alt="Human King">
                        <label for="radio-human">Human</label>
                    </div>
                    <div class="side-option" id="side-orc">
                        <input type="radio" name="playerSide" value="b" id="radio-orc">
                        <img src="sprites/bKing.png" alt="Orc King">
                        <label for="radio-orc">Orc</label>
                    </div>
                </div>
            </div>
            <div id="start-button-container">
                <button id="start-game-button" onclick="startGame()" disabled>Play</button>
            </div>
        </div> <!-- End mode-selection -->

        <div id="game-area">
            <div id="board-and-panels">
                <div id="board"></div>
                <div id="panel">
                    <div id="status">Game Status</div>
                    <h3 id="captured-heading">Captured</h3>
                    <div id="captured-pieces-box">
                        <div id="white-captured" class="captured-list"></div>
                        <div id="black-captured" class="captured-list"></div>
                    </div>
                    <div id="panel-buttons">
                        <div class="button-row">
                            <button id="undo-button" onclick="undoMove()" title="Undo Last Move">
                                Undo
                            </button>
                            <button id="menu-button" onclick="toggleOptionsMenu()" title="Open Menu">
                                <svg viewBox="0 0 24 24" style="width: 1.2em; height: 1.2em; vertical-align: middle; fill: currentColor;">
                                    <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                                </svg>
                                <span style="vertical-align: middle;"> Menu</span>
                            </button>
                        </div>
                        <button id="quit-button" onclick="quitGame()">Quit</button>
                    </div>
                </div>
            </div>
        </div> <!-- End game-area -->

        <!-- Options Menu (HTML Unchanged) -->
        <div id="options-menu">
            <h3>Options</h3>
            <div class="menu-section">
                <button id="menu-fullscreen-button" class="menu-button" onclick="toggleFullScreen()">
                    <svg id="fs-enter-icon-menu" viewBox="0 0 24 24" style="width: 1em; height: 1em; vertical-align: middle; fill: currentColor; display: inline-block;"> <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/> </svg>
                    <svg id="fs-exit-icon-menu" viewBox="0 0 24 24" style="width: 1em; height: 1em; vertical-align: middle; fill: currentColor; display: none;"> <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/> </svg>
                    <span id="fs-text-menu">Fullscreen</span>
                </button>
            </div>
            <div class="menu-section">
                <label for="volume-slider">Volume</label>
                <div id="volume-control">
                    <input type="range" id="volume-slider" min="0" max="1" step="0.05" value="0.7">
                    <span id="volume-label">70%</span>
                </div>
            </div>
            <div class="menu-section">
                <label>Tile Art</label>
                <div id="tile-art-options">
                    <button class="menu-button" data-theme="classic">Classic</button>
                    <button class="menu-button" data-theme="grass">Grass</button>
                    <button class="menu-button" data-theme="snow">Snow</button>
                    <button class="menu-button" data-theme="wasteland">Wasteland</button>
                    <button class="menu-button" data-theme="castle">Castle</button>
                </div>
            </div>
            <button id="close-menu-button" onclick="toggleOptionsMenu()">Close</button>
        </div>

        <!-- Game Over Modal HTML (Unchanged) -->
        <div id="game-over-modal" class="modal-overlay">
            <div class="modal-content">
                <h2 id="modal-title">Game Over!</h2>
                <p id="modal-message">Someone won!</p>
                <button id="new-game-button">Play Again</button>
            </div>
        </div>

        <!-- Hidden container for audio elements (optional, but good practice) -->
        <div id="audio-container" style="display: none;"></div>

    </div> <!-- End game-container -->

    <script>
        // --- NEW: Audio Manager using HTML <audio> elements ---
        const AudioManager = (() => {
            // --- Configuration ---
            const SFX_PATH = 'audio/'; // Adjust if needed
            const soundFiles = {
                move: 'move.wav',
                capture: 'capture.wav',
                check: 'check.wav',
                promote: 'promote.wav',
                game_start: 'game_start.wav',
                game_win: 'game_win.wav',
                game_loss: 'game_loss.wav',
                game_draw: 'game_draw.wav',
                invalid_move: 'invalid_move.wav',
                ui_click: 'ui_click.wav'
            };

            // --- State ---
            const audioElements = {}; // Stores the created <audio> elements
            let currentVolume = 0.7;  // Default/initial volume

            // --- Public Methods ---

            // Call this early (e.g., DOMContentLoaded)
            function init(initialVolume = 0.7) {
                console.log("AudioManager: Initializing...");
                currentVolume = Math.max(0, Math.min(1, parseFloat(initialVolume) || 0.7));
                const container = document.getElementById('audio-container'); // Get container div

                for (const [key, filename] of Object.entries(soundFiles)) {
                    try {
                        const audioElement = document.createElement('audio');
                        audioElement.src = SFX_PATH + filename;
                        // Preload 'auto' hints the browser to load the file.
                        // Actual loading behavior varies by browser.
                        audioElement.preload = 'auto';
                        audioElement.volume = currentVolume; // Set initial volume

                        // Error handling for loading
                        audioElement.addEventListener('error', (e) => {
                             console.error(`AudioManager: Error loading sound "${key}" from ${e.target.src}`);
                             // You could potentially remove the element or mark it as failed
                             // delete audioElements[key];
                        });

                        // Optional: Log when the browser thinks it *can* play the sound
                         audioElement.addEventListener('canplaythrough', () => {
                             // console.log(`AudioManager: Sound "${key}" ready.`);
                         });

                        audioElements[key] = audioElement;
                        // Append to hidden div (optional, but sometimes helps ensure loading)
                        if (container) {
                             container.appendChild(audioElement);
                        }

                    } catch (error) {
                        console.error(`AudioManager: Failed to create audio element for ${key}:`, error);
                    }
                }
                console.log("AudioManager: Initialization complete.");
            }

            function playSound(soundName) {
                const audioElement = audioElements[soundName];

                if (!audioElement) {
                    console.error(`AudioManager: Sound effect "${soundName}" not found or failed to initialize.`);
                    return;
                }

                try {
                    // Reset playback position to the start allows retriggering quickly
                    audioElement.currentTime = 0;
                    // play() returns a Promise which might reject if interrupted or blocked
                    const playPromise = audioElement.play();

                    if (playPromise !== undefined) {
                        playPromise.catch(error => {
                            // Autoplay was prevented. This is common before user interaction.
                            // The browser usually handles this automatically for subsequent plays
                            // initiated by user gestures, but we log it just in case.
                            if (error.name === 'NotAllowedError') {
                                console.warn(`AudioManager: Playback for "${soundName}" prevented. Needs user gesture.`);
                            } else {
                                console.error(`AudioManager: Error playing sound "${soundName}":`, error);
                            }
                        });
                    }
                } catch (error) {
                     console.error(`AudioManager: Exception trying to play sound "${soundName}":`, error);
                }
            }

            function setVolume(level) {
                currentVolume = Math.max(0, Math.min(1, parseFloat(level) || 0));
                // Apply volume to all managed audio elements
                for (const key in audioElements) {
                    if (audioElements.hasOwnProperty(key)) {
                        audioElements[key].volume = currentVolume;
                    }
                }
                console.log(`AudioManager: Volume set to ${Math.round(currentVolume * 100)}%`);
                return currentVolume; // Return the clamped value
            }

            function getVolume() {
                return currentVolume;
            }

            // Expose public interface
            return {
                init,
                playSound,
                setVolume,
                getVolume,
                // Removed isReady and getFailedSounds as they were Web Audio API specific
            };
        })();
        // --- END Audio Manager ---


        // --- DOM Element References ---
        console.log("Getting DOM elements...");
        const gameContainer = document.getElementById('game-container');
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        const modeSelectionElement = document.getElementById('mode-selection');
        const gameAreaElement = document.getElementById('game-area');
        const panelElement = document.getElementById('panel');
        const whiteCapturedElement = document.getElementById('white-captured');
        const blackCapturedElement = document.getElementById('black-captured');
        const undoButton = document.getElementById('undo-button');
        const quitButton = document.getElementById('quit-button');
        const menuButton = document.getElementById('menu-button');
        const optionsMenu = document.getElementById('options-menu');
        const menuFullscreenButton = document.getElementById('menu-fullscreen-button');
        const menuFsEnterIcon = document.getElementById('fs-enter-icon-menu');
        const menuFsExitIcon = document.getElementById('fs-exit-icon-menu');
        const menuFsText = document.getElementById('fs-text-menu');
        const volumeSlider = document.getElementById('volume-slider');
        const volumeLabel = document.getElementById('volume-label');
        const tileArtButtons = document.querySelectorAll('#tile-art-options button');
        const closeMenuButton = document.getElementById('close-menu-button');
        const mode2pButton = document.getElementById('mode-2p');
        const modeCpuButton = document.getElementById('mode-cpu');
        const cpuOptionsContainer = document.getElementById('cpu-options-container');
        const difficultyChoiceDiv = document.getElementById('difficulty-choice');
        const difficultyButtons = difficultyChoiceDiv ? difficultyChoiceDiv.querySelectorAll('button') : [];
        const playerSideChoiceDiv = document.getElementById('player-side-choice');
        const sideOptions = document.querySelectorAll('.side-option');
        const startGameButton = document.getElementById('start-game-button');
        const gameOverModal = document.getElementById('game-over-modal');
        const modalTitleElement = document.getElementById('modal-title');
        const modalMessageElement = document.getElementById('modal-message');
        const newGameButton = document.getElementById('new-game-button');
        console.log("DOM elements fetched.");

        // --- Game State Variables ---
        let board = []; let currentPlayer = 'w'; let playerColor = 'w'; let gameMode = null;
        let selectedSquare = null;
        let currentlyDragging = { pieceElement: null, startRow: -1, startCol: -1, pieceCode: null, validMoves: [], isDragging: false, touchIdentifier: null, offsetX: 0, offsetY: 0, ghostElement: null };
        let validMoves = [];
        let whiteKingPos = null; let blackKingPos = null;
        let isWhiteInCheck = false; let isBlackInCheck = false;
        let isComputerTurn = false;
        let gameOver = false; let capturedPieces = { w: [], b: [] }; let lastMove = { start: null, end: null };
        let moveHistory = [];
        let isAnimating = false;
        let currentTileTheme = 'classic';

        // --- Constants ---
        const pieceValues = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 1000 };
        const initialBoard = [
            ['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'], ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'],
            [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null],
            ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'], ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr']
        ];
        const pieceOrder = { p: 1, n: 2, b: 3, r: 4, q: 5 };
        const ANIMATION_DURATION_MS = 300;
        const LOCALSTORAGE_PREFIX = 'kingsfallChess_';
        const THEME_KEY = LOCALSTORAGE_PREFIX + 'theme';
        const VOLUME_KEY = LOCALSTORAGE_PREFIX + 'volume';

        // --- Mode Selection Logic ---
        let selectedDifficulty = null; let selectedModeType = null;
        function updateStartButtonState() {
            let ready = false;
            if (selectedModeType === '2P') {
                ready = true;
            } else if (selectedModeType === 'CPU' && selectedDifficulty) {
                ready = true;
            }
            if(startGameButton) {
                startGameButton.disabled = !ready;
            } else {
                 console.error("Start game button not found in updateStartButtonState!");
            }
        }
        function setupModeSelectionListeners() {
             console.log("Setting up mode selection listeners...");
             if (!mode2pButton || !modeCpuButton || !cpuOptionsContainer || !difficultyChoiceDiv || !playerSideChoiceDiv || !startGameButton || difficultyButtons.length === 0 || sideOptions.length === 0) {
                console.error("CRITICAL ERROR: One or more mode selection elements not found!");
                alert("Error setting up game modes. Check console.");
                return;
            }

             mode2pButton.addEventListener('click', () => {
                AudioManager.playSound('ui_click'); // <<< SFX via AudioManager
                selectedModeType = '2P'; gameMode = '2P'; selectedDifficulty = null;
                cpuOptionsContainer.style.display = 'flex';
                cpuOptionsContainer.classList.add('options-disabled');
                modeCpuButton.classList.remove('selected');
                mode2pButton.classList.add('selected');
                difficultyButtons.forEach(btn => btn.classList.remove('selected'));
                updateStartButtonState();
            });
             modeCpuButton.addEventListener('click', () => {
                 AudioManager.playSound('ui_click'); // <<< SFX via AudioManager
                 selectedModeType = 'CPU'; gameMode = null;
                 cpuOptionsContainer.style.display = 'flex';
                 cpuOptionsContainer.classList.remove('options-disabled');
                 mode2pButton.classList.remove('selected');
                 modeCpuButton.classList.add('selected');
                 const easyButton = difficultyChoiceDiv.querySelector('[data-difficulty="CPU-easy"]');
                 const isDifficultySelected = difficultyChoiceDiv.querySelector('.selected');
                 if (easyButton && !isDifficultySelected) {
                     easyButton.click(); // Will play its own sound
                 } else if (!isDifficultySelected) {
                     selectedDifficulty = 'CPU-easy'; gameMode = 'CPU-easy';
                     difficultyButtons.forEach(btn => btn.classList.remove('selected'));
                     if(easyButton) easyButton.classList.add('selected');
                 }
                 const humanSideOption = playerSideChoiceDiv.querySelector('#side-human');
                 const isSideSelected = playerSideChoiceDiv.querySelector('.selected');
                 if(humanSideOption && !isSideSelected) {
                      humanSideOption.click(); // Will play its own sound
                 }
                 updateStartButtonState();
             });
             difficultyButtons.forEach(button => {
                 button.addEventListener('click', () => {
                     AudioManager.playSound('ui_click'); // <<< SFX via AudioManager
                     selectedDifficulty = button.getAttribute('data-difficulty');
                     gameMode = selectedDifficulty;
                     difficultyButtons.forEach(btn => btn.classList.remove('selected'));
                     button.classList.add('selected');
                     updateStartButtonState();
                 });
             });
             sideOptions.forEach(option => {
                 option.addEventListener('click', () => {
                     AudioManager.playSound('ui_click'); // <<< SFX via AudioManager
                     if (cpuOptionsContainer.classList.contains('options-disabled')) return;
                     const radio = option.querySelector('input[type="radio"]');
                     if (radio) {
                         radio.checked = true;
                         sideOptions.forEach(opt => opt.classList.remove('selected'));
                         option.classList.add('selected');
                     }
                 });
             });
             console.log("Mode selection listeners attached.");
        }
        function startGame() {
             console.log("startGame function called.");
             AudioManager.playSound('ui_click'); // <<< SFX via AudioManager
             if (!gameMode) {
                 alert("Please select '2 Player' or choose a '1 Player' difficulty.");
                 return;
             }
             if (gameMode !== '2P') {
                 const selectedSideRadio = document.querySelector('input[name="playerSide"]:checked');
                 playerColor = selectedSideRadio ? selectedSideRadio.value : 'w';
             } else {
                 playerColor = 'w';
             }
             console.log(`[SETUP] Starting game. Mode: ${gameMode}, Player Side (if CPU): ${playerColor}`);

             if (modeSelectionElement) modeSelectionElement.style.display = 'none';
             else console.error("modeSelectionElement not found in startGame!");

             if (gameAreaElement) gameAreaElement.style.display = 'block';
             else { console.error("gameAreaElement not found in startGame!"); return; }

             if (!panelElement) console.error("panelElement not found in startGame - needed for setup?");

             setupBoard(); // This should run *after* game area is visible
             AudioManager.playSound('game_start'); // <<< SFX via AudioManager
         }

        // --- Core Game Functions ---
        function setupBoard() {
            console.log("[SETUP] Initializing game state...");
            board = JSON.parse(JSON.stringify(initialBoard));
            currentPlayer = 'w';
            selectedSquare = null;
            resetDraggingState();
            validMoves = [];
            whiteKingPos = findKingOnBoard('w', board);
            blackKingPos = findKingOnBoard('b', board);
            if (!whiteKingPos || !blackKingPos) { console.error("Kings not found!"); return; }
            isWhiteInCheck = false; isBlackInCheck = false;
            isComputerTurn = (gameMode !== '2P' && playerColor === 'b');
            gameOver = false;
            capturedPieces = { w: [], b: [] };
            lastMove = { start: null, end: null };
            moveHistory = [];
            isAnimating = false;

            document.body.classList.remove('computer-thinking');
            hideGameOverModal();
            if (boardElement) boardElement.classList.toggle('board-flipped', playerColor === 'b' && gameMode !== '2P');

            // Apply saved theme and volume - volume is applied via loadPreferences -> AudioManager
            loadPreferences();

            saveState();
            renderBoard();
            renderCapturedPieces();
            updateStatus();
            updateUndoButton();
            updateMenuButtonStates(); // Update menu button display

            console.log(`[SETUP] Game ready. Player: ${playerColor}. Turn: ${currentPlayer}. CompTurn? ${isComputerTurn}`);
            if (isComputerTurn) {
                if (statusElement) statusElement.textContent = `CPU thinking...`;
                document.body.classList.add('computer-thinking');
                setTimeout(makeComputerMove, 750);
            }
        }
        function findKingOnBoard(kingColor, currentBoard) { for(let r=0; r<8; r++){ for(let c=0; c<8; c++){ if(currentBoard[r][c] === kingColor + 'k'){ return {row: r, col: c}; } } } console.error(`!!! King ${kingColor}k not found!`); return null; }
        function saveState() { const state = { board: JSON.parse(JSON.stringify(board)), currentPlayer: currentPlayer, isWhiteInCheck: isWhiteInCheck, isBlackInCheck: isBlackInCheck, capturedPieces: JSON.parse(JSON.stringify(capturedPieces)), whiteKingPos: whiteKingPos ? { ...whiteKingPos } : null, blackKingPos: blackKingPos ? { ...blackKingPos } : null, lastMove: lastMove ? { start: lastMove.start ? { ...lastMove.start } : null, end: lastMove.end ? { ...lastMove.end } : null } : { start: null, end: null } }; moveHistory.push(state); }
        function undoMove() {
             AudioManager.playSound('ui_click'); // <<< SFX via AudioManager
             console.log("[UNDO] Attempting undo...");
             if (gameOver || document.body.classList.contains('computer-thinking') || isAnimating) { console.log("[UNDO] Blocked."); return; }
             let movesToUndo = 1;
             const wasPlayerMoveLast = (gameMode !== '2P' && currentPlayer !== playerColor);
             if (gameMode !== '2P' && wasPlayerMoveLast && moveHistory.length >= 3) { movesToUndo = 2; }
             else if (moveHistory.length < 2) { console.log("[UNDO] Blocked (not enough history)."); return; }
             console.log(`[UNDO] Undoing ${movesToUndo} move(s).`);
             if (moveHistory.length - movesToUndo <= 0) { console.log("[UNDO] Blocked (cannot undo initial state)."); return; }
             for (let i = 0; i < movesToUndo; i++) { moveHistory.pop(); }
             const prevState = moveHistory[moveHistory.length - 1];
             if (!prevState) { console.error("[UNDO] Error: No previous state!"); setupBoard(); return; }
             board = JSON.parse(JSON.stringify(prevState.board));
             currentPlayer = prevState.currentPlayer;
             isWhiteInCheck = prevState.isWhiteInCheck;
             isBlackInCheck = prevState.isBlackInCheck;
             capturedPieces = JSON.parse(JSON.stringify(prevState.capturedPieces));
             whiteKingPos = prevState.whiteKingPos ? { ...prevState.whiteKingPos } : null;
             blackKingPos = prevState.blackKingPos ? { ...prevState.blackKingPos } : null;
             lastMove = prevState.lastMove ? { start: prevState.lastMove.start ? { ...prevState.lastMove.start } : null, end: prevState.lastMove.end ? { ...prevState.lastMove.end } : null } : { start: null, end: null }; // Corrected end assignment
             isComputerTurn = (gameMode !== '2P' && currentPlayer !== playerColor);
             gameOver = false;
             console.log(`[UNDO] State restored to turn: ${currentPlayer}.`);
             selectedSquare = null; resetDraggingState(); validMoves = [];
             document.body.classList.remove('computer-thinking');
             renderBoard(); renderCapturedPieces(); updateStatus(); updateUndoButton();
             if (isComputerTurn) {
                console.warn("[UNDO] Computer's turn after undo?");
                document.body.classList.add('computer-thinking');
                setTimeout(makeComputerMove, 500);
             }
        }
        function updateUndoButton() { if (!undoButton) return; let canUndo = moveHistory.length > 1; undoButton.disabled = !canUndo || document.body.classList.contains('computer-thinking') || gameOver || isAnimating; }
        function renderCapturedPieces() { if (!whiteCapturedElement || !blackCapturedElement) return; const sortAndRender = (listElement, piecesArray) => { listElement.innerHTML = ''; const sortedPieces = [...piecesArray].sort((a, b) => (pieceOrder[a[1]] || 0) - (pieceOrder[b[1]] || 0)); sortedPieces.forEach(pieceCode => { const pieceElement = document.createElement('div'); pieceElement.className = `captured-piece ${pieceCode}`; listElement.appendChild(pieceElement); }); }; sortAndRender(whiteCapturedElement, capturedPieces.b); sortAndRender(blackCapturedElement, capturedPieces.w); }
        function renderBoard() {
            if (!boardElement) return;
            boardElement.innerHTML = ''; // Clear previous board
            const oldMovingPiece = gameContainer.querySelector('.moving-piece');
            if (oldMovingPiece) oldMovingPiece.remove();

            // Apply current theme class
            if (currentTileTheme === 'classic') {
                boardElement.classList.remove('themed-tiles');
            } else {
                boardElement.classList.add('themed-tiles');
            }
            boardElement.classList.toggle('board-flipped', playerColor === 'b' && gameMode !== '2P');

            if (!board || board.length !== 8) return;

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    try {
                        const square = document.createElement('div');
                        square.className = `square ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.row = r;
                        square.dataset.col = c;
                        const pieceCode = board[r][c];

                        if (pieceCode) {
                            const pieceElement = document.createElement('div');
                            pieceElement.className = `piece ${pieceCode}`;
                            pieceElement.draggable = true;
                            square.appendChild(pieceElement);
                            // Add drag/touch listeners to piece
                            pieceElement.addEventListener('dragstart', handleDragStart);
                            pieceElement.addEventListener('dragend', handleDragEnd);
                            pieceElement.addEventListener('touchstart', handleTouchStart, { passive: false });
                        }

                        // Add listeners to square
                        square.addEventListener('click', handleSquareClick);
                        square.addEventListener('dragover', handleDragOver);
                        square.addEventListener('dragleave', handleDragLeave);
                        square.addEventListener('drop', handleDrop);

                        // Highlight checks and last move
                        if ((pieceCode === 'wk' && isWhiteInCheck) || (pieceCode === 'bk' && isBlackInCheck)) {
                            square.classList.add('check');
                        }
                        if (lastMove.start && lastMove.start.row === r && lastMove.start.col === c) {
                            square.classList.add('last-move-start');
                        }
                        if (lastMove.end && lastMove.end.row === r && lastMove.end.col === c) {
                            square.classList.add('last-move-end');
                        }

                        boardElement.appendChild(square);
                    } catch (error) {
                        console.error(`Render error at ${r},${c}:`, error);
                    }
                }
            }

            // Re-apply selection and highlights if necessary
            if (selectedSquare) {
                const selEl = getSquareElement(selectedSquare.row, selectedSquare.col);
                if (selEl) {
                    selEl.classList.add('selected');
                    highlightValidMoves(); // Re-highlight moves based on current validMoves
                } else {
                    // Square doesn't exist? Clear selection
                    selectedSquare = null;
                    validMoves = [];
                    removeMoveHighlights();
                }
            } else {
                removeMoveHighlights(); // Ensure no highlights if nothing selected
            }

            // Ensure global touch listeners are attached (or re-attached if needed)
            document.removeEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.removeEventListener('touchend', handleTouchEnd);
            document.addEventListener('touchend', handleTouchEnd);
            document.removeEventListener('touchcancel', handleTouchEnd);
            document.addEventListener('touchcancel', handleTouchEnd);
        }

        // --- Modal Management ---
        function showGameOverModal(title, message) {
            if (!gameOverModal || !modalTitleElement || !modalMessageElement) return;
            modalTitleElement.textContent = title;
            modalMessageElement.textContent = message;
            gameOverModal.classList.add('visible');

            // --- Play Game Over Sounds ---
            if (title.includes("Checkmate")) {
                 const winnerColor = (currentPlayer === 'w') ? 'b' : 'w';
                 if (gameMode === '2P') {
                     AudioManager.playSound('game_win');
                 } else {
                     if (winnerColor === playerColor) {
                         AudioManager.playSound('game_win');
                     } else {
                         AudioManager.playSound('game_loss');
                     }
                 }
            } else if (title.includes("Stalemate")) {
                 AudioManager.playSound('game_draw');
            }
        }
        function hideGameOverModal() { if (!gameOverModal) return; gameOverModal.classList.remove('visible'); }

        // --- Event Handlers ---
        function handleSquareClick(event) {
            if (currentlyDragging.isDragging || isAnimating) return;
            if (gameOver || document.body.classList.contains('computer-thinking')) return;

            const isPlayerTurn = (gameMode === '2P' || currentPlayer === playerColor);

            if (!isPlayerTurn) {
                 AudioManager.playSound('invalid_move');
                 return;
            }

            const squareElement = event.currentTarget;
            const row = parseInt(squareElement.dataset.row);
            const col = parseInt(squareElement.dataset.col);
            const pieceOnSquare = board[row][col];

            if (selectedSquare) {
                const startRow = selectedSquare.row;
                const startCol = selectedSquare.col;
                const targetMove = validMoves.find(move => move.row === row && move.col === col);

                if (targetMove) {
                    initiateMove(startRow, startCol, row, col);
                    return;
                } else {
                    const clickedFriendlyPiece = pieceOnSquare && pieceOnSquare.startsWith(currentPlayer);

                    if (clickedFriendlyPiece) {
                        removePieceSelectionHighlight();
                        removeMoveHighlights();
                        selectedSquare = null;
                        validMoves = [];
                        selectPiece(row, col, pieceOnSquare);
                    } else {
                        AudioManager.playSound('invalid_move');
                        removePieceSelectionHighlight();
                        removeMoveHighlights();
                        selectedSquare = null;
                        validMoves = [];
                    }
                    return;
                }
            } else {
                if (pieceOnSquare && pieceOnSquare.startsWith(currentPlayer)) {
                    selectPiece(row, col, pieceOnSquare);
                } else {
                     AudioManager.playSound('invalid_move');
                }
            }
        }
        function handleDragStart(event) {
            if (gameOver || document.body.classList.contains('computer-thinking') || isAnimating) { event.preventDefault(); return; }
            const pieceElement = event.target;
            const squareElement = pieceElement.closest('.square');
            if (!squareElement) return;
            const startRow = parseInt(squareElement.dataset.row);
            const startCol = parseInt(squareElement.dataset.col);
            const pieceCode = board[startRow][startCol];
            const isPlayerTurn = (gameMode === '2P' || currentPlayer === playerColor);
            if (!pieceCode || !pieceCode.startsWith(currentPlayer) || !isPlayerTurn) {
                 AudioManager.playSound('invalid_move'); // <<< SFX (Tried to drag wrong piece/turn)
                 event.preventDefault();
                 return;
            }

             // Play 'move' sound slightly delayed
             setTimeout(() => AudioManager.playSound('move'), 50); // <<< SFX

             removePieceSelectionHighlight(); selectedSquare = null;
             currentlyDragging.isDragging = true; currentlyDragging.pieceElement = pieceElement;
             currentlyDragging.startRow = startRow; currentlyDragging.startCol = startCol;
             currentlyDragging.pieceCode = pieceCode;
             currentlyDragging.validMoves = calculateValidMoves(startRow, startCol, pieceCode);
             validMoves = currentlyDragging.validMoves;
             event.dataTransfer.effectAllowed = 'move';
             try { event.dataTransfer.setData('text/plain', pieceCode); } catch(e) { console.warn("Could not set drag data:", e)}
             const dragImage = pieceElement.cloneNode(true);
             const originalRect = pieceElement.getBoundingClientRect();
             dragImage.style.width = `${originalRect.width}px`; dragImage.style.height = `${originalRect.height}px`;
             dragImage.style.position = "absolute"; dragImage.style.top = "-9999px"; dragImage.style.left = "-9999px";
             dragImage.style.opacity = '0.8'; dragImage.style.pointerEvents = 'none';
             document.body.appendChild(dragImage);
             const offsetX = originalRect.width / 2; const offsetY = originalRect.height / 2;
             try{ event.dataTransfer.setDragImage(dragImage, offsetX, offsetY); } catch(e) {console.warn("Could not set drag image", e)}
             setTimeout(() => { if (dragImage.parentNode) dragImage.parentNode.removeChild(dragImage); }, 1);
             setTimeout(() => { if (currentlyDragging.pieceElement === pieceElement && currentlyDragging.isDragging) { pieceElement.classList.add('piece-ghost'); } }, 0);
             pieceElement.classList.add('dragging');
             highlightValidMoves();
        }
        function handleDragOver(event) { event.preventDefault(); if (!currentlyDragging.isDragging) return; const squareElement = event.currentTarget; const row = parseInt(squareElement.dataset.row); const col = parseInt(squareElement.dataset.col); const isValidTarget = currentlyDragging.validMoves.some(move => move.row === row && move.col === col); if (isValidTarget) { event.dataTransfer.dropEffect = 'move'; squareElement.classList.add('drag-over-highlight'); } else { event.dataTransfer.dropEffect = 'none'; squareElement.classList.remove('drag-over-highlight'); } }
        function handleDragLeave(event) { const squareElement = event.currentTarget; squareElement.classList.remove('drag-over-highlight'); }
        function handleDrop(event) {
            event.preventDefault();
            if (!currentlyDragging.isDragging || isAnimating) return;
            const squareElement = event.currentTarget;
            squareElement.classList.remove('drag-over-highlight');
            const endRow = parseInt(squareElement.dataset.row);
            const endCol = parseInt(squareElement.dataset.col);
            const startRow = currentlyDragging.startRow;
            const startCol = currentlyDragging.startCol;
            const isValidDrop = currentlyDragging.validMoves.some(move => move.row === endRow && move.col === endCol);
            if (isValidDrop) {
                initiateMove(startRow, startCol, endRow, endCol);
            } else {
                console.log(`[DRAG] Invalid drop at ${endRow},${endCol}`);
                AudioManager.playSound('invalid_move'); // <<< SFX
            }
             // handleDragEnd takes care of cleanup
        }
        function handleDragEnd(event) { if (!currentlyDragging.isDragging) return; const draggedElement = currentlyDragging.pieceElement; if (draggedElement) { draggedElement.classList.remove('piece-ghost', 'dragging'); } document.querySelectorAll('.piece-ghost').forEach(el => el.classList.remove('piece-ghost')); document.querySelectorAll('.drag-over-highlight').forEach(el => el.classList.remove('drag-over-highlight')); removeMoveHighlights(); resetDraggingState(); }
        function handleTouchStart(event) {
            if (gameOver || document.body.classList.contains('computer-thinking') || isAnimating || currentlyDragging.isDragging) { return; }
            if (currentlyDragging.touchIdentifier !== null) return;
            const pieceElement = event.target.closest('.piece');
            if (!pieceElement) return;
            const squareElement = pieceElement.closest('.square');
            if (!squareElement) return;
            const startRow = parseInt(squareElement.dataset.row);
            const startCol = parseInt(squareElement.dataset.col);
            const pieceCode = board[startRow][startCol];
            const isPlayerTurn = (gameMode === '2P' || currentPlayer === playerColor);
            if (!pieceCode || !pieceCode.startsWith(currentPlayer) || !isPlayerTurn) {
                 AudioManager.playSound('invalid_move'); // <<< SFX
                 return;
            }
            event.preventDefault();

             // Play 'move' sound slightly delayed
             setTimeout(() => AudioManager.playSound('move'), 50); // <<< SFX

             removePieceSelectionHighlight(); selectedSquare = null;
             const touch = event.changedTouches[0];
             currentlyDragging.touchIdentifier = touch.identifier; currentlyDragging.isDragging = true;
             currentlyDragging.pieceElement = pieceElement; currentlyDragging.startRow = startRow;
             currentlyDragging.startCol = startCol; currentlyDragging.pieceCode = pieceCode;
             currentlyDragging.validMoves = calculateValidMoves(startRow, startCol, pieceCode);
             validMoves = currentlyDragging.validMoves;
             const rect = pieceElement.getBoundingClientRect();
             currentlyDragging.ghostElement = pieceElement.cloneNode(true);
             currentlyDragging.ghostElement.style.position = 'fixed';
             currentlyDragging.ghostElement.style.width = `${rect.width}px`; currentlyDragging.ghostElement.style.height = `${rect.height}px`;
             currentlyDragging.ghostElement.style.pointerEvents = 'none'; currentlyDragging.ghostElement.style.zIndex = '1010';
             currentlyDragging.ghostElement.style.opacity = '0.8';
             currentlyDragging.offsetX = touch.clientX - rect.left; currentlyDragging.offsetY = touch.clientY - rect.top;
             currentlyDragging.ghostElement.style.left = `${touch.clientX - currentlyDragging.offsetX}px`; currentlyDragging.ghostElement.style.top = `${touch.clientY - currentlyDragging.offsetY}px`;
             document.body.appendChild(currentlyDragging.ghostElement);
             pieceElement.classList.add('piece-ghost');
             highlightValidMoves();
        }
        function handleTouchMove(event) { if (!currentlyDragging.isDragging || currentlyDragging.touchIdentifier === null) return; let currentTouch = null; for (let i = 0; i < event.changedTouches.length; i++) { if (event.changedTouches[i].identifier === currentlyDragging.touchIdentifier) { currentTouch = event.changedTouches[i]; break; } } if (!currentTouch) return; event.preventDefault(); if (currentlyDragging.ghostElement) { currentlyDragging.ghostElement.style.left = `${currentTouch.clientX - currentlyDragging.offsetX}px`; currentlyDragging.ghostElement.style.top = `${currentTouch.clientY - currentlyDragging.offsetY}px`; } const elementUnderTouch = document.elementFromPoint(currentTouch.clientX, currentTouch.clientY); const squareElement = elementUnderTouch ? elementUnderTouch.closest('.square') : null; document.querySelectorAll('.drag-over-highlight').forEach(el => el.classList.remove('drag-over-highlight')); if (squareElement) { const row = parseInt(squareElement.dataset.row); const col = parseInt(squareElement.dataset.col); const isValidTarget = currentlyDragging.validMoves.some(move => move.row === row && move.col === col); if (isValidTarget) { squareElement.classList.add('drag-over-highlight'); } } }
        function handleTouchEnd(event) {
            if (!currentlyDragging.isDragging || currentlyDragging.touchIdentifier === null) return;
            let endedTouch = null;
            for (let i = 0; i < event.changedTouches.length; i++) {
                if (event.changedTouches[i].identifier === currentlyDragging.touchIdentifier) {
                    endedTouch = event.changedTouches[i];
                    break;
                }
            }
            if (!endedTouch) return;

            if (currentlyDragging.ghostElement && currentlyDragging.ghostElement.parentNode) {
                currentlyDragging.ghostElement.parentNode.removeChild(currentlyDragging.ghostElement);
            }
            if (currentlyDragging.pieceElement) {
                currentlyDragging.pieceElement.classList.remove('piece-ghost');
            }
            document.querySelectorAll('.drag-over-highlight').forEach(el => el.classList.remove('drag-over-highlight'));
            removeMoveHighlights();

            const elementUnderTouch = document.elementFromPoint(endedTouch.clientX, endedTouch.clientY);
            const squareElement = elementUnderTouch ? elementUnderTouch.closest('.square') : null;
            let droppedOnValidSquare = false;

            if (squareElement && !isAnimating) {
                const endRow = parseInt(squareElement.dataset.row);
                const endCol = parseInt(squareElement.dataset.col);
                const startRow = currentlyDragging.startRow;
                const startCol = currentlyDragging.startCol;
                const isValidDrop = currentlyDragging.validMoves.some(move => move.row === endRow && move.col === endCol);

                if (isValidDrop) {
                    initiateMove(startRow, startCol, endRow, endCol);
                    droppedOnValidSquare = true;
                } else {
                    console.log(`[TOUCH] Invalid drop at ${endRow},${endCol}`);
                     AudioManager.playSound('invalid_move'); // <<< SFX
                }
            } else if (!squareElement) {
                 console.log("[TOUCH] Dropped outside valid square.");
                 AudioManager.playSound('invalid_move');
            }

             resetDraggingState();
        }
        function resetDraggingState() { if(currentlyDragging.ghostElement && currentlyDragging.ghostElement.parentNode) { currentlyDragging.ghostElement.parentNode.removeChild(currentlyDragging.ghostElement); } if(currentlyDragging.pieceElement) { currentlyDragging.pieceElement.classList.remove('piece-ghost', 'dragging'); } currentlyDragging.pieceElement = null; currentlyDragging.startRow = -1; currentlyDragging.startCol = -1; currentlyDragging.pieceCode = null; currentlyDragging.validMoves = []; currentlyDragging.isDragging = false; currentlyDragging.touchIdentifier = null; currentlyDragging.ghostElement = null; currentlyDragging.offsetX = 0; currentlyDragging.offsetY = 0; }

        // --- Move Execution and Animation ---
        function initiateMove(startRow, startCol, endRow, endCol) {
             if (isAnimating) return;
             console.log(`[MOVE] Initiating: ${startRow},${startCol} -> ${endRow},${endCol}`);
             isAnimating = true;
             updateUndoButton();
             const pieceCode = board[startRow][startCol];
             const captured = board[endRow][endCol];
             const isPromotion = (pieceCode === 'wp' && endRow === 0) || (pieceCode === 'bp' && endRow === 7);

             let soundToPlay = 'move';
             if (captured) soundToPlay = 'capture';
             if (isPromotion) soundToPlay = 'promote';

             const startSquareEl = getSquareElement(startRow, startCol);
             const endSquareEl = getSquareElement(endRow, endCol);
             removePieceSelectionHighlight(); selectedSquare = null; removeMoveHighlights();

             animateMove(startSquareEl, endSquareEl, pieceCode, () => {
                 makeMove(startRow, startCol, endRow, endCol);
                 AudioManager.playSound(soundToPlay); // <<< Play sound via AudioManager
                 saveState();
                 validMoves = [];
                 switchPlayer();
                 isAnimating = false;
                 updateUndoButton();
             });
        }
        function animateMove(startSquareEl, endSquareEl, pieceCode, onCompleteCallback) { if (!startSquareEl || !endSquareEl || !pieceCode || !boardElement || !gameContainer) { console.error("Animation error: Missing elements."); if (onCompleteCallback) onCompleteCallback(); return; } const boardRect = boardElement.getBoundingClientRect(); const startRect = startSquareEl.getBoundingClientRect(); const endRect = endSquareEl.getBoundingClientRect(); const pieceElToHide = startSquareEl.querySelector('.piece'); const movingPiece = document.createElement('div'); movingPiece.className = `moving-piece ${pieceCode}`; gameContainer.appendChild(movingPiece); const pieceWidth = startRect.width * 0.9; const pieceHeight = startRect.height * 0.9; const pieceOffsetX = (startRect.width - pieceWidth) / 2; const pieceOffsetY = (startRect.height - pieceHeight) / 2; const gameContainerRect = gameContainer.getBoundingClientRect(); const initialTopRelGameContainer = (startRect.top + pieceOffsetY) - gameContainerRect.top + gameContainer.scrollTop; const initialLeftRelGameContainer = (startRect.left + pieceOffsetX) - gameContainerRect.left + gameContainer.scrollLeft; const finalTopRelGameContainer = (endRect.top + pieceOffsetY) - gameContainerRect.top + gameContainer.scrollTop; const finalLeftRelGameContainer = (endRect.left + pieceOffsetX) - gameContainerRect.left + gameContainer.scrollLeft; const translateX = finalLeftRelGameContainer - initialLeftRelGameContainer; const translateY = finalTopRelGameContainer - initialTopRelGameContainer; movingPiece.style.position = 'absolute'; movingPiece.style.top = `${initialTopRelGameContainer}px`; movingPiece.style.left = `${initialLeftRelGameContainer}px`; movingPiece.style.width = `${pieceWidth}px`; movingPiece.style.height = `${pieceHeight}px`; movingPiece.style.transform = 'translate(0, 0)'; movingPiece.style.zIndex = '1000'; movingPiece.style.pointerEvents = 'none'; if (pieceElToHide) { pieceElToHide.classList.remove('piece-ghost'); pieceElToHide.classList.add('hidden-during-move'); } movingPiece.offsetHeight; requestAnimationFrame(() => { movingPiece.style.transform = `translate(${translateX}px, ${translateY}px)`; }); setTimeout(() => { if (movingPiece.parentNode) { movingPiece.remove(); } if (onCompleteCallback) { onCompleteCallback(); } }, ANIMATION_DURATION_MS); }
        function makeMove(startRow, startCol, endRow, endCol) { const piece = board[startRow][startCol]; const captured = board[endRow][endCol]; if (!piece) { console.error(`Move err: empty start ${startRow},${startCol}`); return; } if (captured) { capturedPieces[piece[0]].push(captured); } if (piece === 'wp' && endRow === 0) { board[endRow][endCol] = 'wq'; } else if (piece === 'bp' && endRow === 7) { board[endRow][endCol] = 'bq'; } else { board[endRow][endCol] = piece; } board[startRow][startCol] = null; if (piece === 'wk') whiteKingPos = {row: endRow, col: endCol}; else if (piece === 'bk') blackKingPos = {row: endRow, col: endCol}; lastMove = { start: {row: startRow, col: startCol}, end: {row: endRow, col: endCol} }; }

        // --- Selection and Highlighting ---
        function selectPiece(row, col, piece) {
            if (!selectedSquare || selectedSquare.row !== row || selectedSquare.col !== col) {
                 AudioManager.playSound('ui_click'); // <<< SFX for selecting piece
            }
            removePieceSelectionHighlight();
            removeMoveHighlights();
            selectedSquare = { row, col };
            validMoves = calculateValidMoves(row, col, piece);
            const sqEl = getSquareElement(row, col);
            if (sqEl) sqEl.classList.add('selected');
            highlightValidMoves();
        }
        function removePieceSelectionHighlight(){ if(selectedSquare){ const prevEl = getSquareElement(selectedSquare.row, selectedSquare.col); if(prevEl) prevEl.classList.remove('selected'); } document.querySelectorAll('.square.selected').forEach(el => el.classList.remove('selected')); }
        function removeMoveHighlights(){ document.querySelectorAll('.square.highlight').forEach(el => el.classList.remove('highlight', 'capture')); }
        function highlightValidMoves(){ removeMoveHighlights(); validMoves.forEach(m => { const s = getSquareElement(m.row, m.col); if (s) { s.classList.add('highlight'); const targetPiece = board[m.row][m.col]; if (targetPiece && getPieceColor(m.row, m.col) !== currentPlayer) { s.classList.add('capture'); } } }); }
        function getSquareElement(r, c){ if (!isValid(r, c)) return null; return boardElement ? boardElement.querySelector(`.square[data-row="${r}"][data-col="${c}"]`) : null; }

        // --- Player Switching and Game Over Check ---
        function switchPlayer() {
             const previousPlayer = currentPlayer;
             const wasWhiteInCheck = isWhiteInCheck;
             const wasBlackInCheck = isBlackInCheck;

             currentPlayer = (currentPlayer === 'w') ? 'b' : 'w';
             isWhiteInCheck = isKingInCheck('w');
             isBlackInCheck = isKingInCheck('b');

             console.log(`[TURN] Switched to ${currentPlayer}. W_Check: ${isWhiteInCheck}, B_Check: ${isBlackInCheck}`);

             if ((currentPlayer === 'w' && isWhiteInCheck && !wasWhiteInCheck) ||
                 (currentPlayer === 'b' && isBlackInCheck && !wasBlackInCheck)) {
                  AudioManager.playSound('check'); // <<< SFX
             }

             const availableMoves = calculateAllValidMoves(currentPlayer);
             if (availableMoves.length === 0) {
                 gameOver = true;
                 const loserColor = currentPlayer;
                 let isCheckmate = (loserColor === 'w' && isWhiteInCheck) || (loserColor === 'b' && isBlackInCheck);

                 if (isCheckmate) {
                     const winnerName = (previousPlayer === 'w' ? 'Human' : 'Orc');
                     showGameOverModal("Checkmate!", `${winnerName} wins by checkmate!`);
                 } else {
                     showGameOverModal("Stalemate!", "The game is a draw by stalemate.");
                 }

                 renderBoard();
                 renderCapturedPieces();
                 updateUndoButton();
                 return;
             }

             renderBoard();
             renderCapturedPieces();
             updateStatus();
             isComputerTurn = (gameMode !== '2P' && currentPlayer !== playerColor);
             updateUndoButton();

             if (isComputerTurn && !gameOver) {
                 console.log("[TURN] CPU's turn starting...");
                 document.body.classList.add('computer-thinking');
                 updateStatus();
                 setTimeout(makeComputerMove, 500);
             } else {
                 document.body.classList.remove('computer-thinking');
                 console.log("[TURN] Player's turn.");
                 updateStatus();
             }
        }
        function updateStatus() { if (!statusElement || gameOver) return; let turnText = ""; const currentSideName = currentPlayer === 'w' ? 'Human' : 'Orc'; const isInCheck = (currentPlayer === 'w' && isWhiteInCheck) || (currentPlayer === 'b' && isBlackInCheck); if (gameMode === '2P') { turnText = `${currentSideName}'s Turn`; } else { if (document.body.classList.contains('computer-thinking')) { turnText = `CPU thinking...`; } else if (currentPlayer === playerColor) { turnText = `Your Turn`; } else { turnText = `CPU's Turn`; } } if (isInCheck) { turnText += " (Check!)"; } statusElement.textContent = turnText; }

        // --- Move Calculation & Check Logic (Unchanged) ---
        function isValid(r, c) { return r >= 0 && r < 8 && c >= 0 && c < 8; }
        function getPieceColor(r, c) { if (!isValid(r, c)) return null; const p = board[r][c]; return p ? p[0] : null; }
        function addSlidingMoves(moves, r, c, color, dr, dc, currentBoard) { let cr = r + dr; let cc = c + dc; while (isValid(cr, cc)) { const targetPiece = currentBoard[cr][cc]; if (targetPiece === null) { moves.push({ row: cr, col: cc }); } else { if (targetPiece[0] !== color) { moves.push({ row: cr, col: cc }); } break; } cr += dr; cc += dc; } }
        function getPawnMoves(r, c, color, currentBoard) { const moves = []; const dir = color === 'w' ? -1 : 1; const startRow = color === 'w' ? 6 : 1; const nextRow = r + dir; if (isValid(nextRow, c) && currentBoard[nextRow][c] === null) { moves.push({ row: nextRow, col: c }); const twoStepRow = r + 2 * dir; if (r === startRow && isValid(twoStepRow, c) && currentBoard[twoStepRow][c] === null) { moves.push({ row: twoStepRow, col: c }); } } const captureCols = [c - 1, c + 1]; captureCols.forEach(capCol => { if (isValid(nextRow, capCol)) { const targetPiece = currentBoard[nextRow][capCol]; if (targetPiece && targetPiece[0] !== color) { moves.push({ row: nextRow, col: capCol }); } } }); return moves; }
        function getRookMoves(r, c, color, currentBoard) { const moves = []; const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; directions.forEach(([dr, dc]) => addSlidingMoves(moves, r, c, color, dr, dc, currentBoard)); return moves; }
        function getBishopMoves(r, c, color, currentBoard) { const moves = []; const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]]; directions.forEach(([dr, dc]) => addSlidingMoves(moves, r, c, color, dr, dc, currentBoard)); return moves; }
        function getQueenMoves(r, c, color, currentBoard) { const moves = []; const directions = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]]; directions.forEach(([dr, dc]) => addSlidingMoves(moves, r, c, color, dr, dc, currentBoard)); return moves; }
        function getKnightMoves(r, c, color, currentBoard) { const moves = []; const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]]; knightMoves.forEach(([dr, dc]) => { const nr = r + dr; const nc = c + dc; if (isValid(nr, nc)) { const targetPiece = currentBoard[nr][nc]; if (!targetPiece || targetPiece[0] !== color) { moves.push({ row: nr, col: nc }); } } }); return moves; }
        function getKingMoves(r, c, color, currentBoard) { const moves = []; const kingMoves = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]; kingMoves.forEach(([dr, dc]) => { const nr = r + dr; const nc = c + dc; if (isValid(nr, nc)) { const targetPiece = currentBoard[nr][nc]; if (!targetPiece || targetPiece[0] !== color) { moves.push({ row: nr, col: nc }); } } }); return moves; }
        function calculateValidMoves(r, c, piece, currentBoard = board) { const legalMoves = []; if (!piece) return legalMoves; const type = piece[1]; const color = piece[0]; let pseudoLegalMoves = []; switch (type) { case 'p': pseudoLegalMoves = getPawnMoves(r, c, color, currentBoard); break; case 'r': pseudoLegalMoves = getRookMoves(r, c, color, currentBoard); break; case 'n': pseudoLegalMoves = getKnightMoves(r, c, color, currentBoard); break; case 'b': pseudoLegalMoves = getBishopMoves(r, c, color, currentBoard); break; case 'q': pseudoLegalMoves = getQueenMoves(r, c, color, currentBoard); break; case 'k': pseudoLegalMoves = getKingMoves(r, c, color, currentBoard); break; default: return legalMoves; } pseudoLegalMoves.forEach(move => { if (!moveLeavesKingInCheck(r, c, move.row, move.col, color, currentBoard)) { legalMoves.push(move); } }); return legalMoves; }
        function isSquareAttacked(r, c, attackerColor, currentBoard) { const pawnDir = attackerColor === 'w' ? 1 : -1; const pawnAttackSources = [{ dr: pawnDir, dc: -1 }, { dr: pawnDir, dc: 1 }]; for (const { dr, dc } of pawnAttackSources) { const sr = r + dr; const sc = c + dc; if (isValid(sr, sc) && currentBoard[sr][sc] === attackerColor + 'p') return true; } const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]]; for (const [dr, dc] of knightMoves) { const sr = r + dr; const sc = c + dc; if (isValid(sr, sc) && currentBoard[sr][sc] === attackerColor + 'n') return true; } const rookDirs = [[-1, 0], [1, 0], [0, -1], [0, 1]]; const bishopDirs = [[-1, -1], [-1, 1], [1, -1], [1, 1]]; function checkSliding(directions, pieceTypes) { for (const [dr, dc] of directions) { let cr = r + dr; let cc = c + dc; while (isValid(cr, cc)) { const p = currentBoard[cr][cc]; if (p !== null) { if (p[0] === attackerColor && pieceTypes.includes(p[1])) return true; break; } cr += dr; cc += dc; } } return false; } if (checkSliding(rookDirs, ['r', 'q'])) return true; if (checkSliding(bishopDirs, ['b', 'q'])) return true; const kingMoves = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]; for (const [dr, dc] of kingMoves) { const sr = r + dr; const sc = c + dc; if (isValid(sr, sc) && currentBoard[sr][sc] === attackerColor + 'k') return true; } return false; }
        function findKing(kingColor, currentBoard = board) { if (currentBoard === board) { const cachedPos = kingColor === 'w' ? whiteKingPos : blackKingPos; if (cachedPos && isValid(cachedPos.row, cachedPos.col) && currentBoard[cachedPos.row][cachedPos.col] === kingColor + 'k') { return cachedPos; } } const foundPos = findKingOnBoard(kingColor, currentBoard); if (currentBoard === board && foundPos) { if (kingColor === 'w') whiteKingPos = foundPos; else blackKingPos = foundPos; } return foundPos; }
        function isKingInCheck(kingColor, currentBoard = board) { const kingPos = findKing(kingColor, currentBoard); if (!kingPos) { console.error(`Cannot check king: ${kingColor}k not found!`); return false; } const attackerColor = kingColor === 'w' ? 'b' : 'w'; return isSquareAttacked(kingPos.row, kingPos.col, attackerColor, currentBoard); }
        function moveLeavesKingInCheck(startRow, startCol, endRow, endCol, pieceColor, boardToCheck) { const tempBoard = JSON.parse(JSON.stringify(boardToCheck)); const piece = tempBoard[startRow][startCol]; tempBoard[endRow][endCol] = piece; tempBoard[startRow][startCol] = null; let kingPosToCheck = findKing(pieceColor, tempBoard); if (!kingPosToCheck) { if(piece === pieceColor + 'k') kingPosToCheck = {row: endRow, col: endCol}; else { console.error("Check validation error: King position unknown after simulated move!"); return true; } } const check = isSquareAttacked(kingPosToCheck.row, kingPosToCheck.col, pieceColor === 'w' ? 'b' : 'w', tempBoard); return check; }
        function calculateAllValidMoves(playerColor, currentBoard = board) { const allMoves = []; for (let r = 0; r < 8; r++) { for (let c = 0; c < 8; c++) { const piece = currentBoard[r][c]; if (piece && piece.startsWith(playerColor)) { const moves = calculateValidMoves(r, c, piece, currentBoard); moves.forEach(move => allMoves.push({ piece: piece, startRow: r, startCol: c, endRow: move.row, endCol: move.col })); } } } return allMoves; }

        // --- AI Logic (Unchanged) ---
        function evaluateBoardFromState(boardState) { let score = 0; for (let r = 0; r < 8; r++) { for (let c = 0; c < 8; c++) { const piece = boardState[r][c]; if (piece) { const value = pieceValues[piece[1]] || 0; score += (piece[0] === 'w' ? value : -value); } } } return score; }
        function simulateMoveOnState(currentBoardState, move) { let newBoardState = JSON.parse(JSON.stringify(currentBoardState)); const piece = newBoardState[move.startRow][move.startCol]; if (!piece) { return [newBoardState, null]; } const captured = newBoardState[move.endRow][move.endCol]; if (piece === 'wp' && move.endRow === 0) newBoardState[move.endRow][move.endCol] = 'wq'; else if (piece === 'bp' && move.endRow === 7) newBoardState[move.endRow][move.endCol] = 'bq'; else newBoardState[move.endRow][move.endCol] = piece; newBoardState[move.startRow][move.startCol] = null; return [newBoardState, captured]; }
        function minimax(depth, boardState, alpha, beta, maximizingPlayer, playerToDoMove) { if (depth === 0) { return evaluateBoardFromState(boardState); } const availableMoves = calculateAllValidMoves(playerToDoMove, boardState); if (availableMoves.length === 0) { if (isKingInCheck(playerToDoMove, boardState)) { return maximizingPlayer ? -Infinity - depth : Infinity + depth; } else { return 0; } } if (playerToDoMove === 'w') { let maxEval = -Infinity; for (const move of availableMoves) { const [nextBoardState, _] = simulateMoveOnState(boardState, move); const evaluation = minimax(depth - 1, nextBoardState, alpha, beta, maximizingPlayer, 'b'); maxEval = Math.max(maxEval, evaluation); alpha = Math.max(alpha, evaluation); if (beta <= alpha) { break; } } return maxEval; } else { let minEval = Infinity; for (const move of availableMoves) { const [nextBoardState, _] = simulateMoveOnState(boardState, move); const evaluation = minimax(depth - 1, nextBoardState, alpha, beta, maximizingPlayer, 'w'); minEval = Math.min(minEval, evaluation); beta = Math.min(beta, evaluation); if (beta <= alpha) { break; } } return minEval; } }
        function makeComputerMove() { if (gameOver || !isComputerTurn || isAnimating) { if (!isComputerTurn && !gameOver) { document.body.classList.remove('computer-thinking'); updateStatus(); } return; } console.log(`[AI] ${gameMode} calculating for ${currentPlayer}...`); const aiColor = currentPlayer; const availableMoves = calculateAllValidMoves(aiColor, board); if (availableMoves.length === 0) { console.error("AI Error: No moves available, but game wasn't over?"); isComputerTurn = false; document.body.classList.remove('computer-thinking'); updateStatus(); updateUndoButton(); return; } let bestMove = null; if (gameMode === 'CPU-easy') { bestMove = availableMoves[Math.floor(Math.random() * availableMoves.length)]; } else if (gameMode === 'CPU-medium') { let bestScore = -Infinity; let candidateMoves = []; availableMoves.forEach(move => { let moveScore = 0; const targetPiece = board[move.endRow][move.endCol]; if (targetPiece) { moveScore += (pieceValues[targetPiece[1]] || 0) * 10; } const [nextBoardState, _] = simulateMoveOnState(board, move); const opponentColor = aiColor === 'w' ? 'b' : 'w'; if (isKingInCheck(opponentColor, nextBoardState)) { moveScore += 5; } moveScore += Math.random() * 0.5; if (moveScore > bestScore) { bestScore = moveScore; candidateMoves = [move]; } else if (moveScore === bestScore) { candidateMoves.push(move); } }); bestMove = candidateMoves.length > 0 ? candidateMoves[Math.floor(Math.random() * candidateMoves.length)] : availableMoves[Math.floor(Math.random() * availableMoves.length)]; } else if (gameMode === 'CPU-hard') { let bestScore = (aiColor === 'w') ? -Infinity : Infinity; let depth = 2; let candidateMoves = []; const isAiMaximizing = (aiColor === 'w'); availableMoves.forEach(move => { const [nextBoardState, _] = simulateMoveOnState(board, move); const opponentColor = (aiColor === 'w' ? 'b' : 'w'); const score = minimax(depth -1, nextBoardState, -Infinity, Infinity, isAiMaximizing, opponentColor); if (isAiMaximizing) { if (score > bestScore) { bestScore = score; candidateMoves = [move]; } else if (score === bestScore) { candidateMoves.push(move); } } else { if (score < bestScore) { bestScore = score; candidateMoves = [move]; } else if (score === bestScore) { candidateMoves.push(move); } } }); bestMove = candidateMoves.length > 0 ? candidateMoves[Math.floor(Math.random() * candidateMoves.length)] : availableMoves[Math.floor(Math.random() * availableMoves.length)]; console.log(`[AI Hard] Best score: ${bestScore}, Moves: ${candidateMoves.length}`); } if (bestMove) { console.log(`[AI] Chosen Move: ${bestMove.piece} ${bestMove.startRow},${bestMove.startCol} -> ${bestMove.endRow},${bestMove.endCol}`); initiateMove(bestMove.startRow, bestMove.startCol, bestMove.endRow, bestMove.endCol); } else { console.error("AI failed to select a move!"); isComputerTurn = false; document.body.classList.remove('computer-thinking'); updateStatus(); updateUndoButton(); } }

        // --- Game Control ---
        function quitGame() {
             AudioManager.playSound('ui_click'); // <<< SFX
             console.log("[CONTROL] Quitting game...");
             hideGameOverModal();
             toggleOptionsMenu(false);
             if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) { if (document.exitFullscreen) document.exitFullscreen(); else if (document.mozCancelFullScreen) document.mozCancelFullScreen(); else if (document.webkitExitFullscreen) document.webkitExitFullscreen(); else if (document.msExitFullscreen) document.msExitFullscreen(); }
             updateMenuButtonStates();
             gameOver = true; isAnimating = false;
             document.body.classList.remove('computer-thinking');
             if (gameAreaElement) gameAreaElement.style.display = 'none';
             if (modeSelectionElement) modeSelectionElement.style.display = 'flex';
             if (boardElement) boardElement.innerHTML = '';
             if (whiteCapturedElement) whiteCapturedElement.innerHTML = '';
             if (blackCapturedElement) blackCapturedElement.innerHTML = '';
             board = []; currentPlayer = 'w'; playerColor = 'w'; gameMode = null;
             selectedSquare = null; resetDraggingState(); validMoves = [];
             whiteKingPos = null; blackKingPos = null; isWhiteInCheck = false; isBlackInCheck = false;
             isComputerTurn = false; capturedPieces = { w: [], b: [] }; lastMove = { start: null, end: null };
             moveHistory = [];
             selectedDifficulty = null; selectedModeType = null;
             if (boardElement) boardElement.classList.remove('board-flipped');
             if (statusElement) statusElement.textContent = "Select mode to start";
             if (mode2pButton) mode2pButton.classList.remove('selected');
             if (modeCpuButton) modeCpuButton.classList.remove('selected');
             if (difficultyButtons) difficultyButtons.forEach(b => b.classList.remove('selected'));
             if (sideOptions) { sideOptions.forEach(o => o.classList.remove('selected')); const sideHuman = document.getElementById('side-human'); if (sideHuman) sideHuman.classList.add('selected'); const sideHumanRadio = document.getElementById('radio-human'); if (sideHumanRadio) sideHumanRadio.checked = true; }
             if (cpuOptionsContainer) { cpuOptionsContainer.style.display = 'none'; cpuOptionsContainer.classList.remove('options-disabled'); }
             updateUndoButton(); if (startGameButton) startGameButton.disabled = true;
        }

        // --- Options Menu Logic ---
        function toggleOptionsMenu(forceState) {
            AudioManager.playSound('ui_click'); // <<< SFX
            if (!optionsMenu) return;
            const isVisible = optionsMenu.classList.contains('visible');
            if (typeof forceState === 'boolean') {
                if (forceState) optionsMenu.classList.add('visible');
                else optionsMenu.classList.remove('visible');
            } else {
                optionsMenu.classList.toggle('visible');
            }
            console.log("Options menu toggled:", optionsMenu.classList.contains('visible'));
        }

        function applyTileTheme(themeName) {
            AudioManager.playSound('ui_click'); // <<< SFX
            console.log(`Applying theme: ${themeName}`);
            currentTileTheme = themeName;

            tileArtButtons.forEach(btn => btn.classList.remove('selected'));
            let tileImageUrl = '';
            switch (themeName) {
                case 'grass': tileImageUrl = "url('sprites/tile_grass.png')"; break;
                case 'snow': tileImageUrl = "url('sprites/tile_snow.png')"; break;
                case 'wasteland': tileImageUrl = "url('sprites/tile_wasteland.png')"; break;
                case 'castle': tileImageUrl = "url('sprites/tile_castle.png')"; break;
                case 'classic':
                default:
                    document.documentElement.style.removeProperty('--tile-light-bg-image');
                    document.documentElement.style.removeProperty('--tile-dark-bg-image');
                    if (boardElement) boardElement.classList.remove('themed-tiles');
                    const classicBtn = document.querySelector('#tile-art-options button[data-theme="classic"]');
                    if (classicBtn) classicBtn.classList.add('selected');
                    savePreferences();
                    return;
            }
            document.documentElement.style.setProperty('--tile-light-bg-image', tileImageUrl);
            document.documentElement.style.setProperty('--tile-dark-bg-image', tileImageUrl);
            if (boardElement) boardElement.classList.add('themed-tiles');
            const selectedBtn = document.querySelector(`#tile-art-options button[data-theme="${themeName}"]`);
            if (selectedBtn) selectedBtn.classList.add('selected');
            savePreferences();
        }

        function updateThemeSelectionUI() {
             tileArtButtons.forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.theme === currentTileTheme);
            });
        }

         function updateVolumeUI(volumeLevel = AudioManager.getVolume()) {
             if (volumeSlider) volumeSlider.value = volumeLevel;
             if (volumeLabel) volumeLabel.textContent = `${Math.round(volumeLevel * 100)}%`;
         }

        // --- Preference Management ---
        function savePreferences() {
            try {
                localStorage.setItem(THEME_KEY, currentTileTheme);
                localStorage.setItem(VOLUME_KEY, AudioManager.getVolume().toString());
                console.log('Preferences saved:', { theme: currentTileTheme, volume: AudioManager.getVolume() });
            } catch (e) {
                console.warn("Could not save preferences to localStorage:", e);
            }
        }

        function loadPreferences() {
            try {
                const savedTheme = localStorage.getItem(THEME_KEY);
                const savedVolumeStr = localStorage.getItem(VOLUME_KEY);

                if (savedTheme) {
                    applyTileTheme(savedTheme); // Plays sound
                } else {
                    applyTileTheme('classic'); // Plays sound
                }
                updateThemeSelectionUI();

                let initialVolume = 0.7;
                if (savedVolumeStr !== null) {
                    initialVolume = parseFloat(savedVolumeStr);
                    if (isNaN(initialVolume)) initialVolume = 0.7;
                }
                const actualVolume = AudioManager.setVolume(initialVolume);
                updateVolumeUI(actualVolume);

                console.log('Preferences loaded:', { theme: currentTileTheme, volume: actualVolume });

            } catch (e) {
                console.warn("Could not load preferences from localStorage:", e);
                applyTileTheme('classic'); // Plays sound
                const actualVolume = AudioManager.setVolume(0.7);
                updateVolumeUI(actualVolume);
            }
        }


        // --- Fullscreen Functionality ---
        function toggleFullScreen() {
            AudioManager.playSound('ui_click'); // <<< SFX
            const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
            const elementToFullscreen = gameContainer;
            if (!isFullscreen) {
                console.log("Entering Fullscreen...");
                try {
                    let promise;
                    if (elementToFullscreen.requestFullscreen) promise = elementToFullscreen.requestFullscreen();
                    else if (elementToFullscreen.mozRequestFullScreen) promise = elementToFullscreen.mozRequestFullScreen();
                    else if (elementToFullscreen.webkitRequestFullscreen) promise = elementToFullscreen.webkitRequestFullscreen();
                    else if (elementToFullscreen.msRequestFullscreen) promise = elementToFullscreen.msRequestFullscreen();
                    if (promise) { promise.catch(err => { console.error(`Fullscreen error: ${err.message} (${err.name})`); alert(`Could not enter fullscreen: ${err.message}`); updateMenuButtonStates(); }); }
                    else { console.warn("Fullscreen API not supported."); alert("Fullscreen mode is not supported."); }
                } catch (err) { console.error("Error entering fullscreen:", err); alert("An error occurred trying to enter fullscreen."); updateMenuButtonStates(); }
            } else {
                console.log("Exiting Fullscreen...");
                try { if (document.exitFullscreen) document.exitFullscreen(); else if (document.mozCancelFullScreen) document.mozCancelFullScreen(); else if (document.webkitExitFullscreen) document.webkitExitFullscreen(); else if (document.msExitFullscreen) document.msExitFullscreen(); }
                catch (err) { console.error("Error exiting fullscreen:", err); }
            }
        }
        function handleFullscreenChange() { updateMenuButtonStates(); }
        function updateMenuButtonStates() { const isFullscreenNow = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement); const fsElement = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement; if (isFullscreenNow && fsElement === gameContainer) { if (menuFsEnterIcon) menuFsEnterIcon.style.display = 'none'; if (menuFsExitIcon) menuFsExitIcon.style.display = 'inline-block'; if (menuFsText) menuFsText.textContent = 'Exit Fullscreen'; } else { if (menuFsEnterIcon) menuFsEnterIcon.style.display = 'inline-block'; if (menuFsExitIcon) menuFsExitIcon.style.display = 'none'; if (menuFsText) menuFsText.textContent = 'Fullscreen'; } }
        document.addEventListener('fullscreenchange', handleFullscreenChange); document.addEventListener('webkitfullscreenchange', handleFullscreenChange); document.addEventListener('mozfullscreenchange', handleFullscreenChange); document.addEventListener('MSFullscreenChange', handleFullscreenChange);

        // --- Initial UI Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            try {
                console.log("DOM Loaded. Setting up.");

                // --- Initialize AudioManager FIRST ---
                AudioManager.init(); // Use default volume initially

                // --- Rigorous Element Check ---
                const essentialElements = { /* ... same checks ... */ };
                // ... (rest of element checks) ...

                // --- Load Preferences (Theme & Volume) ---
                loadPreferences(); // Now calls AudioManager.setVolume

                setupModeSelectionListeners();

                if(statusElement) statusElement.textContent = "Select mode to start";

                // New game button listener
                 newGameButton.addEventListener('click', () => {
                    AudioManager.playSound('ui_click'); // <<< SFX
                    console.log("New Game (from modal) clicked.");
                    quitGame();
                    setTimeout(() => {
                         const cpuModeBtn = document.getElementById('mode-cpu');
                         if(cpuModeBtn) cpuModeBtn.click();
                         else console.error("Cannot select default mode after Play Again.");
                     }, 50);
                 });

                // Menu option listeners
                volumeSlider.addEventListener('input', (e) => {
                    const newVolume = AudioManager.setVolume(e.target.value);
                    updateVolumeUI(newVolume);
                    savePreferences();
                });

                tileArtButtons.forEach(button => {
                    button.addEventListener('click', (e) => applyTileTheme(e.target.dataset.theme));
                });

                 // Set default mode selection
                 setTimeout(() => {
                     const cpuModeBtn = document.getElementById('mode-cpu');
                     if (cpuModeBtn && !selectedModeType) {
                         console.log("Attempting to click default mode button (CPU)...");
                         cpuModeBtn.click();
                     } else {
                         console.log("Default mode (CPU) already selected or button not found.");
                     }
                 }, 100);

            } catch (error) {
                console.error("Initialization setup error:", error);
                alert("An error occurred while initializing the game. Please check the console.");
            }
        });

    </script>

</body>
</html>
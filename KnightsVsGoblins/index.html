<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Knights Vs Goblins (Optimized + Fixed)</title>
    <style>
        :root {
            --grid-cols: 8;
            --grid-rows: 10;
            --board-aspect-ratio: var(--grid-cols) / var(--grid-rows);
            font-size: clamp(8px, 1.8vmin, 16px);
            --death-fade-time: 1s;
            --attack-anim-time: 0.08s;
            --move-anim-time: 0.25s;
            --arrow-fly-time: 0.3s;
            --fireball-fly-time: 0.4s;
            --fireball-explode-time: 0.8s;
            --flame-wave-stagger-delay: 50ms;
            --frost-nova-hover-bg: rgba(100, 150, 255, 0.3);
            --frost-nova-hover-border: rgba(150, 200, 255, 0.7);
            --frozen-filter-base: brightness(0.9) sepia(1) hue-rotate(180deg) saturate(5);
            --frozen-filter-shadow: drop-shadow(0 0 2px rgba(150, 220, 255, 0.9));
            --frozen-filter: var(--frozen-filter-base) var(--frozen-filter-shadow);
            --spell-locked-filter: grayscale(80%) brightness(0.6) saturate(3) hue-rotate(350deg) contrast(0.9);
            --spell-used-filter: grayscale(90%) brightness(60%);
            --hover-outline-color-player: yellow;
            --hover-outline-color-enemy: red;
            --heal-color: #50ff50;
            --cell-size: 30px;
            --gold-color: #FFD700;
            --stack-offset-x: 3px;
            --stack-offset-y: -3px;
            --tooltip-bg: rgba(10, 10, 10, 0.88);
            --tooltip-text: #eee;
            --tooltip-border: #555;
            --tooltip-shadow: 2px 2px 6px rgba(0, 0, 0, 0.6);
            --attack-target-bg: rgba(255, 80, 80, 0.4);
            --attack-target-border: rgba(255, 80, 80, 0.7);
        }

        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #3a4a3a;
            font-family: 'Courier New', Courier, monospace;
            color: #eee;
            padding: 5px;
            box-sizing: border-box;
            position: relative;
        }

        #game-container {
            display: flex;
            max-width: 100%;
            max-height: 100%;
            width: 100%;
            height: 100%;
            border: clamp(2px, 0.5vmin, 5px) solid #1e281e;
            background-color: #1e281e;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            flex-direction: row;
            align-items: stretch;
            justify-content: center;
            padding: clamp(3px, 1vmin, 10px);
            box-sizing: border-box;
            gap: clamp(5px, 1vmin, 10px);
            position: relative;
        }

        #game-container:fullscreen {
            padding: 0;
            border: none;
            gap: 5px;
            width: 100vw;
            height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
        }

        #game-container:fullscreen > #ui-panel {
            border-left-color: #333;
        }

        #game-board {
            display: grid;
            border: clamp(1px, 0.3vmin, 2px) solid #1e281e;
            position: relative;
            flex-grow: 0;
            flex-shrink: 1;
            grid-template-columns: repeat(var(--grid-cols), 1fr);
            grid-template-rows: repeat(var(--grid-rows), 1fr);
            aspect-ratio: var(--board-aspect-ratio);
            max-width: 100%;
            max-height: 100%;
            box-sizing: border-box;
            min-width: 160px;
            min-height: calc(160px / var(--board-aspect-ratio));
            overflow: hidden;
        }

        #board-feedback-area {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            min-height: 2rem;
            font-size: clamp(1.4rem, 2.5vmin, 1.8rem);
            font-weight: bold;
            color: #fff;
            text-align: center;
            z-index: 40;
            pointer-events: none;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
            width: 80%;
            max-width: 500px;
            transition: opacity 0.5s ease-out;
            opacity: 1;
        }

        #board-feedback-area.feedback-levelup {
            color: #ffd700;
            text-shadow: 1px 1px #443300, 1px 1px 3px rgba(0,0,0,0.7);
        }

        #board-feedback-area.feedback-error {
            color: #ff8888;
            text-shadow: 1px 1px #550000, 1px 1px 3px rgba(0,0,0,0.7);
        }

        #board-feedback-area.feedback-gold {
            color: var(--gold-color);
            text-shadow: 1px 1px #6b5700, 1px 1px 3px rgba(0,0,0,0.7);
        }

        #board-feedback-area.feedback-cheat {
            color: lime;
            text-shadow: 1px 1px #004400, 1px 1px 3px rgba(0,0,0,0.7);
        }

        #game-board.fireball-targeting {
            cursor: crosshair !important;
        }

        #game-board.fireball-targeting .grid-cell:hover:not(.has-obstacle) {
            background-color: rgba(255, 100, 100, 0.4) !important;
            box-shadow: inset 0 0 0 2px rgba(255, 0, 0, 0.7);
        }

        #game-board.flame-wave-targeting .grid-cell:hover:not(.has-obstacle) {
            background-color: rgba(255, 150, 50, 0.3) !important;
            box-shadow: none;
        }

        #game-board.frost-nova-targeting {
            cursor: cell !important;
        }

        #game-board.frost-nova-targeting .grid-cell:hover:not(.has-obstacle) {
            background-color: transparent !important;
            box-shadow: none;
        }

        #game-board.frost-nova-targeting .grid-cell.frost-aoe-preview:not(.has-obstacle) {
            background-color: var(--frost-nova-hover-bg) !important;
            box-shadow: inset 0 0 0 1px var(--frost-nova-hover-border);
            z-index: 2;
        }

        #game-board.heal-targeting {
            cursor: help !important;
        }

        #game-board.heal-targeting .unit.player:not(.dead):not(.acted):not(.frozen):hover {
            filter: drop-shadow(0 0 3px var(--heal-color));
            box-shadow: 0 0 0 2px var(--heal-color);
        }

        .grid-cell {
            border: 1px solid #7a8a7a;
            background-color: #6a7a6a;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
            box-sizing: border-box;
            image-rendering: pixelated;
            min-width: 1px;
            min-height: 1px;
            overflow: hidden;
            grid-column: auto;
            grid-row: auto;
        }

        .grid-cell.valid-move:not(.has-obstacle) {
            background-color: #aaeaaa;
            opacity: 0.8;
            cursor: pointer;
        }

        .grid-cell.valid-attack-target:not(.has-obstacle) {
            background-color: var(--attack-target-bg);
            box-shadow: inset 0 0 0 1px var(--attack-target-border);
            cursor: crosshair;
            z-index: 1;
        }


        .grid-cell.has-obstacle {
            cursor: not-allowed !important;
            background-color: #5a6a5a;
        }

        .obstacle {
            position: absolute;
            left: calc((var(--obs-x) - 1) * var(--cell-size));
            top: calc((var(--obs-y) - 1) * var(--cell-size));
            width: var(--cell-size);
            height: var(--cell-size);
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 2;
            pointer-events: none;
            image-rendering: pixelated;
            box-sizing: border-box;
            transition: width 0.1s, height 0.1s, left 0.1s, top 0.1s;
        }

        .obstacle.rock {
            background-image: url('./sprites/rock.png');
            width: calc(var(--cell-size) * 0.8);
            height: calc(var(--cell-size) * 0.8);
            left: calc((var(--obs-x) - 1) * var(--cell-size) + var(--cell-size) * 0.1);
            top: calc((var(--obs-y) - 1) * var(--cell-size) + var(--cell-size) * 0.1);
        }

        .obstacle.wall_rock {
            background-image: url('./sprites/wall_rock.png');
        }


        .item {
            position: absolute;
            left: calc((var(--item-x) - 1) * var(--cell-size) + var(--cell-size) * 0.5);
            top: calc((var(--item-y) - 1) * var(--cell-size) + var(--cell-size) * 0.5);
            transform: translate(calc(-50% + var(--stackIndex, 0) * var(--stack-offset-x)), calc(-50% + var(--stackIndex, 0) * var(--stack-offset-y)));
            width: calc(var(--cell-size) * 0.6);
            height: calc(var(--cell-size) * 0.6);
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 6;
            pointer-events: none;
            image-rendering: pixelated;
            box-sizing: border-box;
            transition: width 0.1s, height 0.1s, opacity 0.3s ease-out, left 0.1s, top 0.1s, transform 0.1s ease-out;
            opacity: 1;
            --stackIndex: 0;
        }

        .item.gold-coin {
            background-image: url('./sprites/gold.png');
        }

        .unit {
            position: absolute;
            left: calc((var(--unit-x) - 1) * var(--cell-size));
            top: calc((var(--unit-y) - 1) * var(--cell-size));
            width: var(--cell-size);
            height: var(--cell-size);
            border-radius: 3px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            z-index: 10;
            transition: filter 0.2s, box-shadow 0.2s, width 0.1s, height 0.1s, opacity var(--death-fade-time) ease-in-out, background-image 0.1s ease-in, transform var(--move-anim-time) ease-out, left var(--move-anim-time) ease-out, top var(--move-anim-time) ease-out;
            transform: none;
            box-sizing: border-box;
            background-color: transparent;
            image-rendering: pixelated;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            pointer-events: none;
            width: calc(var(--cell-size) * 0.8);
            height: calc(var(--cell-size) * 0.8);
            left: calc((var(--unit-x) - 1) * var(--cell-size) + var(--cell-size) * 0.1);
            top: calc((var(--unit-y) - 1) * var(--cell-size) + var(--cell-size) * 0.1);
            opacity: 1;
            filter: none;
        }


        #game-board .unit {
            pointer-events: auto;
        }

        .unit.is-moving {
            z-index: 15;
            transition: filter 0.2s, box-shadow 0.2s, width 0.1s, height 0.1s, opacity var(--death-fade-time) ease-in-out, background-image 0.1s ease-in, left var(--move-anim-time) ease-out, top var(--move-anim-time) ease-out;
        }

        .unit.selected {
            box-shadow: 0 0 0 clamp(1px, 0.5vmin, 3px) yellow;
            z-index: 13;
        }

        .unit.selected:not(:hover) {
            filter: drop-shadow(0 0 3px yellow);
        }

        .unit.acted:not(:hover):not(.is-moving):not(.frozen) {
            filter: grayscale(50%) brightness(80%);
        }

        .unit.frozen:not(.is-moving) {
            filter: var(--frozen-filter);
        }

        .unit.selected.frozen:not(.is-moving) {
            filter: var(--frozen-filter) drop-shadow(0 0 3px yellow);
            box-shadow: 0 0 0 clamp(1px, 0.5vmin, 3px) yellow;
        }

        .unit.unit-hit-flash {
            animation: simple-hit-flash 0.2s ease-out;
        }

        @keyframes simple-hit-flash {
            50% {
                filter: brightness(1.8);
            }
        }

        #game-board .unit:not(.dead):not(.fading-out):not(.selected):not(.is-moving):hover {
            z-index: 12;
            cursor: pointer;
        }

        #game-board .unit.player:not(.dead):not(.fading-out):not(.selected):not(.is-moving):not(.frozen):hover {
            filter: drop-shadow(1px 0px 0 var(--hover-outline-color-player)) drop-shadow(-1px 0px 0 var(--hover-outline-color-player)) drop-shadow(0px 1px 0 var(--hover-outline-color-player)) drop-shadow(0px -1px 0 var(--hover-outline-color-player));
        }

        #game-board .unit.enemy:not(.dead):not(.fading-out):not(.selected):not(.is-moving):not(.frozen):hover {
            filter: drop-shadow(1px 0px 0 var(--hover-outline-color-enemy)) drop-shadow(-1px 0px 0 var(--hover-outline-color-enemy)) drop-shadow(0px 1px 0 var(--hover-outline-color-enemy)) drop-shadow(0px -1px 0 var(--hover-outline-color-enemy));
        }

        .unit.dead {
            z-index: 5;
            pointer-events: none !important;
            filter: none !important;
            box-shadow: none !important;
            opacity: 1;
            transition: opacity var(--death-fade-time) ease-in-out, left 0.1s, top 0.1s;
            transform: none !important;
        }


        .unit.fading-out {
            opacity: 0 !important;
        }

        .projectile {
            position: absolute;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 22;
            pointer-events: none;
            image-rendering: pixelated;
            transform-origin: center center;
        }

        .projectile.arrow {
            width: 26px;
            height: 7px;
            background-image: url('./sprites/arrow.png');
            transition: left var(--arrow-fly-time) linear, top var(--arrow-fly-time) linear;
        }

        .projectile.fireball-projectile {
            background-image: url('./sprites/sFireball1.png');
            width: 72px;
            height: 72px;
            transition: left var(--fireball-fly-time) linear, top var(--fireball-fly-time) linear;
            z-index: 23;
        }

        .fireball-explosion {
            position: absolute;
            width: 120px;
            height: 120px;
            background-image: url('./sprites/fireball_explode.png');
            background-repeat: no-repeat;
            background-position: 0 0;
            z-index: 25;
            pointer-events: none;
            image-rendering: pixelated;
            transform: scale(0.75);
            transform-origin: center center;
            animation: fireball-explode-anim var(--fireball-explode-time) steps(8) forwards;
        }

        @keyframes fireball-explode-anim {
            from {
                background-position: 0 0;
            }
            to {
                background-position: -960px 0;
            }
        }

        #ui-panel {
            width: clamp(180px, 28vmin, 240px);
            flex-shrink: 0;
            max-height: 100%;
            padding: clamp(0.5rem, 1vmin, 1rem);
            background-color: #4a5a4a;
            border-left: clamp(1px, 0.4vmin, 3px) solid #1e281e;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            font-size: 1.4rem;
            box-sizing: border-box;
            position: relative;
        }

        #top-bar-ui {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.8rem;
            gap: 5px;
            flex-wrap: wrap;
        }

        #level-gold-container {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
            flex-grow: 1;
        }

        #level-display,
        #gold-display-ui-panel { /* Renamed to avoid conflict with menu one */
            text-align: center;
            margin-bottom: 0;
            font-weight: bold;
            background-color: #5a6a5a;
            padding: 0.3rem 0.5rem;
            border: 1px solid #1e281e;
            border-radius: 3px;
            font-size: 1.4rem;
            white-space: nowrap;
        }

        #level-display {
            color: #ffd700;
        }

        #gold-display-ui-panel { /* Hide original gold display in UI panel */
             display: none;
        }
        /* Style for gold display inside menu */
         #menu-overlay #gold-display {
             color: var(--gold-color);
             text-shadow: 1px 1px 1px #6b5700;
             margin: 1rem 0;
             font-size: 1.5rem;
             font-weight: bold;
             text-align: center;
             background-color: rgba(30, 40, 30, 0.6);
             padding: 0.5rem 1rem;
             border: 1px solid #7a8a7a;
             border-radius: 3px;
         }


        #control-buttons-container {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .ui-button {
            padding: 3px 5px;
            background-color: rgba(30, 40, 30, 0.6);
            border: 1px solid #7a8a7a;
            color: #eee;
            font-size: 1.6rem;
            line-height: 1;
            border-radius: 3px;
            cursor: pointer;
            z-index: 55;
            transition: background-color 0.2s;
            min-width: 25px;
            min-height: 25px;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .ui-button:hover:not(:disabled) {
            background-color: rgba(60, 80, 60, 0.8);
        }

        .ui-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #unit-info {
            background-color: #5a6a5a;
            padding: 0.8rem;
            margin-bottom: 1rem;
            border: 1px solid #1e281e;
            border-radius: 3px;
            min-height: auto;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #unit-portrait {
            width: 48px;
            height: 48px;
            border: 1px solid #333;
            background-color: #444;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            image-rendering: pixelated;
            flex-shrink: 0;
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        #unit-portrait[style*="url"] {
            opacity: 1;
        }

        #unit-details {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            font-size: 1.2rem;
        }

        #unit-info h3 {
            margin: 0 0 0.4rem 0;
            border-bottom: 1px solid #7a8a7a;
            padding-bottom: 0.3rem;
            color: #eee;
            font-size: 1.3rem;
        }

        #unit-info p {
            margin: 0.2rem 0;
            color: #ddd;
            line-height: 1.3;
            white-space: nowrap;
        }

        #unit-status {
            color: #aadeff;
            font-style: italic;
            min-height: 1.3em;
        }

        #turn-info {
            background-color: #5a6a5a;
            padding: 0.8rem;
            margin-bottom: 1rem;
            border: 1px solid #1e281e;
            border-radius: 3px;
            min-height: auto;
            font-size: 1.3rem;
        }

        #turn-info h3 {
            margin: 0 0 0.5rem 0;
            border-bottom: 1px solid #7a8a7a;
            padding-bottom: 0.3rem;
            color: #eee;
            font-size: 1.4rem;
        }

        #turn-info p {
            margin: 0.3rem 0;
            color: #ddd;
        }

        #spell-area {
            margin-top: auto;
            margin-bottom: 1.5rem;
            padding: clamp(0.5rem, 1vmin, 1rem);
            background-color: #5a6a5a;
            border: 1px solid #1e281e;
            border-radius: 3px;
            min-height: auto;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: clamp(8px, 1.5vmin, 15px);
            place-items: center;
            align-content: center;
        }

        .spell-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            width: 100%;
        }

        .spell-icon {
            position: relative;
            display: inline-block;
            width: clamp(30px, 4.5vmin, 40px);
            height: clamp(30px, 4.5vmin, 40px);
            border: clamp(1px, 0.3vmin, 2px) solid #333;
            border-radius: 4px;
            background-color: #444;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            margin-bottom: 3px;
            transition: border-color 0.2s, box-shadow 0.2s, filter 0.2s;
            image-rendering: pixelated;
            vertical-align: middle;
            filter: none;
            cursor: default;
            box-shadow: none;
            overflow: hidden;
        }

        .spell-icon .hotkey-display {
            position: absolute;
            top: 0;
            left: 0;
            font-size: clamp(0.8rem, 1.3vmin, 1rem);
            font-weight: bold;
            color: var(--gold-color);
            background-color: rgba(0, 0, 0, 0.6);
            padding: 1px 3px;
            line-height: 1;
            border-bottom-right-radius: 3px;
            text-shadow: 1px 1px #332200;
        }

        #fireball-spell {
            background-image: url('./sprites/sFireball1.png');
        }

        #flame-wave-spell {
            background-image: url('./sprites/flame_wave.png');
        }

        #frost-nova-spell {
            background-image: url('./sprites/sFrostbolt1.png');
        }

        #heal-spell {
            background-image: url('./sprites/heal.png');
        }

        .spell-label {
            font-size: clamp(0.9rem, 1.5vmin, 1.1rem);
            font-weight: bold;
            color: #eee;
            text-shadow: 1px 1px #111;
            line-height: 1.2;
        }

        .spell-icon.locked {
            filter: var(--spell-locked-filter);
            cursor: not-allowed;
            border-color: #600;
        }

        .spell-icon.locked+.spell-label {
            color: #a85858;
        }

        .spell-icon.used {
            filter: var(--spell-used-filter);
            cursor: not-allowed;
            border-color: #555;
        }

        .spell-icon.used+.spell-label {
            color: #aaa;
        }

        .spell-icon.available {
            filter: none;
            cursor: pointer;
            border-color: #888;
        }

        .spell-icon.available:hover {
            border-color: #eee;
        }

        .spell-icon.available+.spell-label {
            color: #eee;
        }

        .spell-icon.selected {
            filter: none !important;
            cursor: pointer;
            border-color: yellow !important;
            box-shadow: 0 0 8px yellow !important;
        }

        .spell-icon.selected+.spell-label {
            color: #eee;
        }

        .spell-icon.cheat-available {
            border-color: lime !important;
            box-shadow: 0 0 5px lime !important;
        }

        .spell-icon.cheat-available+.spell-label {
            color: lime;
        }

        #old-feedback-area {
            margin-bottom: 1rem;
            min-height: 2rem;
        }

        #end-turn-button {
            padding: 1rem 1.5rem;
            background-color: #a0522d;
            border: 2px solid #1e281e;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            cursor: pointer;
            font-size: 1.4rem;
            border-radius: 3px;
            text-align: center;
            transition: background-color 0.2s;
            width: 100%;
            box-sizing: border-box;
            margin-top: auto;
        }

        #end-turn-button:hover:not(.disabled) {
            background-color: #8B4513;
        }

        #end-turn-button.disabled {
            background-color: #888;
            cursor: not-allowed;
            color: #bbb;
        }

        #end-turn-button.next-level-mode {
            background-color: #4CAF50;
        }

        #end-turn-button.next-level-mode:hover:not(.disabled) {
            background-color: #45a049;
        }

        #end-turn-button .hotkey-e {
            color: var(--gold-color);
            font-weight: bold;
        }

        .damage-popup,
        .freeze-popup,
        .heal-popup {
            position: absolute;
            font-weight: bold;
            animation: moveUpFadeOut 1s forwards;
            z-index: 50;
            pointer-events: none;
        }

        .damage-popup {
            color: red;
            font-size: clamp(1.2rem, 2vmin, 1.8rem);
            text-shadow: 1px 1px white;
        }

        .freeze-popup {
            color: #aadeff;
            font-size: clamp(1.2rem, 2vmin, 1.6rem);
            text-shadow: 1px 1px #112233;
            animation-duration: 0.8s;
        }

        .heal-popup {
            color: var(--heal-color);
            font-size: clamp(1.2rem, 2vmin, 1.8rem);
            text-shadow: 1px 1px #003300;
        }

        @keyframes moveUpFadeOut {
            0% {
                opacity: 1;
                transform: translateY(0) translateX(-50%);
            }
            100% {
                opacity: 0;
                transform: translateY(-30px) translateX(-50%);
            }
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            z-index: 100;
            padding: 20px;
            box-sizing: border-box;
        }
        .overlay.visible {
            display: flex;
        }


        .overlay h2 {
            color: #ffd700;
            margin-bottom: 2rem;
            font-size: clamp(2rem, 6vmin, 2.5rem);
        }

        .overlay p {
            font-size: clamp(1.2rem, 4vmin, 1.5rem);
            line-height: 1.6;
            margin-bottom: 2rem;
        }

        .overlay button,
        #menu-overlay .overlay-button-like { /* Style buttons inside overlays */
            padding: clamp(0.8rem, 3vmin, 1rem) clamp(1.5rem, 6vmin, 2rem);
            font-size: clamp(1.2rem, 4vmin, 1.6rem);
            cursor: pointer;
            background-color: #a0522d;
            border: 2px solid #1e281e;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            border-radius: 3px;
            margin-top: 1rem;
        }

        .overlay button:hover:not(:disabled),
        #menu-overlay .overlay-button-like:hover:not(:disabled) {
            background-color: #8B4513;
        }

         /* Specific Menu Overlay Styles */
        #menu-overlay {
            background-color: rgba(0, 0, 0, 0.92); /* Darker for menu */
        }
        #menu-overlay h2 {
            margin-bottom: 1.5rem;
        }
        #menu-overlay-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            background-color: rgba(40, 50, 40, 0.7);
            padding: clamp(1.5rem, 4vmin, 2.5rem);
            border: 2px solid #7a8a7a;
            border-radius: 8px;
            width: 80%;
            max-width: 350px;
        }
         #menu-overlay #menu-buttons-container {
             display: flex;
             flex-direction: column; /* Stack buttons vertically */
             gap: 0.8rem;
             width: 100%;
             align-items: center;
         }
         #menu-overlay .menu-ui-button { /* Use specific class or style directly */
             padding: 8px 15px; /* Slightly larger padding for menu buttons */
             font-size: 1.6rem; /* Consistent font size */
             background-color: rgba(30, 40, 30, 0.8);
             border: 1px solid #7a8a7a;
             color: #eee;
             border-radius: 3px;
             cursor: pointer;
             min-width: 150px;
             text-align: center;
             transition: background-color 0.2s;
             display: flex; /* Align icon and text */
             align-items: center;
             justify-content: center;
             gap: 8px;
         }
         #menu-overlay .menu-ui-button:hover:not(:disabled) {
             background-color: rgba(60, 80, 60, 0.9);
         }
         #menu-overlay .menu-ui-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
         }
         #menu-overlay #close-menu-button { /* Style close button like others */
            margin-top: 1.5rem;
         }

        #leaderboard-overlay ul {
            list-style: none;
            padding: 0;
            max-height: 60vh;
            overflow-y: auto;
            width: 80%;
            max-width: 400px;
            margin-bottom: 1rem;
        }
         #leaderboard-overlay li {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            margin-bottom: 5px;
            border-radius: 3px;
            display: flex;
            justify-content: space-between;
            font-size: clamp(1rem, 3vmin, 1.3rem);
        }
        #leaderboard-overlay li span:first-child {
            font-weight: bold;
            color: #eee;
        }
         #leaderboard-overlay li span:last-child {
            color: var(--gold-color);
         }

        #unit-tooltip {
            position: fixed;
            background-color: var(--tooltip-bg);
            color: var(--tooltip-text);
            border: 1px solid var(--tooltip-border);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 1.2rem;
            line-height: 1.4;
            z-index: 110;
            pointer-events: none;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.15s ease-in-out;
            box-shadow: var(--tooltip-shadow);
            transform: translate(12px, 18px);
        }

        #unit-tooltip.visible {
            opacity: 1;
        }

        #unit-tooltip b {
            color: #f0e68c;
            display: block;
            margin-bottom: 3px;
        }

        #unit-tooltip span[style*="color:#aadeff"] {
            font-style: italic;
        }

        @media (max-width: 700px),
        (max-aspect-ratio: 1/1) {
            #game-container {
                flex-direction: column;
                justify-content: flex-start;
                align-items: stretch;
            }
            #game-board {
                width: 100%;
                height: auto;
                margin: 0;
                min-height: calc(160px / var(--board-aspect-ratio));
            }
             #board-feedback-area {
                top: 5px;
                font-size: clamp(1.2rem, 2.2vmin, 1.6rem);
            }
            #ui-panel {
                width: 100%;
                height: auto;
                flex-grow: 1;
                flex-shrink: 1;
                border-left: none;
                border-top: clamp(1px, 0.4vmin, 3px) solid #1e281e;
                min-height: 100px;
                max-height: 40vh;
                font-size: 1.3rem;
            }
            #top-bar-ui {
                flex-wrap: nowrap;
            }
            #level-gold-container {
                flex-direction: row;
                flex-grow: 0;
                gap: 0.8rem;
            }
            #level-display {
                margin-bottom: 0;
            }
            .ui-button {
                font-size: 1.4rem;
                padding: 2px 4px;
                min-width: 22px;
                min-height: 22px;
            }
            #turn-and-unit-info-container {
                display: flex;
                gap: 8px;
                margin-bottom: 1rem;
                align-items: flex-start;
            }
            #turn-info {
                flex: 1 1 auto;
                margin-bottom: 0;
            }
            #unit-info {
                flex: 0 1 auto;
                margin-bottom: 0;
                font-size: 1.1rem;
                gap: 5px;
                padding: 0.5rem;
            }
            #unit-portrait {
                width: 36px;
                height: 36px;
            }
            #unit-details {
                font-size: 1.1rem;
            }
            #unit-info h3 {
                font-size: 1.2rem;
            }
            #unit-info p {
                font-size: 1.1rem;
            }
            #game-container:fullscreen > #ui-panel {
                border-top-color: #333;
            }
            #spell-area {
                grid-template-columns: repeat(4, 1fr);
            }
            .spell-icon {
                width: clamp(28px, 4.5vmin, 40px);
                height: clamp(28px, 4.5vmin, 40px);
            }
            .spell-label {
                font-size: 1.0rem;
            }
            .spell-icon .hotkey-display {
                font-size: 0.9rem;
                padding: 0 2px;
            }
            #unit-tooltip {
                font-size: 1.0rem;
            }
            .projectile.fireball-projectile {
                width: 60px;
                height: 60px;
            }
             :root {
                --flame-wave-stagger-delay: 75ms;
            }
             #menu-overlay #menu-overlay-content {
                 width: 90%;
                 max-width: 90%;
             }
             #menu-overlay .menu-ui-button {
                 min-width: 80%;
             }
        }
    </style>
</head>

<body>
    <div id="game-container">
        <div id="game-board"></div>
        <div id="board-feedback-area"></div>
        <div id="ui-panel">
            <div id="top-bar-ui">
                <div id="level-gold-container">
                    <div id="level-display">Level: 1</div>
                    <div id="gold-display-ui-panel">Gold: 0</div>
                </div>
                <div id="control-buttons-container">
                     <button id="menu-button" class="ui-button" title="Menu">‚ò∞</button>
                     <!-- Other buttons moved to menu -->
                </div>
            </div>

            <div id="turn-and-unit-info-container">
                <div id="turn-info">
                    <h3 id="current-turn">Turn: Player</h3>
                    <p id="actions-left">Actions Left: 0</p>
                </div>

                <div id="unit-info">
                    <img id="unit-portrait" src="" alt="">
                    <div id="unit-details">
                        <h3 id="unit-name">Unit Info</h3>
                        <p id="unit-hp">HP: -/-</p>
                        <p id="unit-atk">ATK: -</p>
                        <p id="unit-mov">MOV: -</p>
                        <p id="unit-rng">RNG: -</p>
                        <p id="unit-status"></p>
                    </div>
                </div>
            </div>

            <div id="spell-area">
                <div id="fireball-container" class="spell-container">
                    <div id="fireball-spell" class="spell-icon locked" title="Unlock at Level 4"><span class="hotkey-display">1</span></div><span class="spell-label">Fireball</span></div>
                <div id="flame-wave-container" class="spell-container">
                    <div id="flame-wave-spell" class="spell-icon locked" title="Unlock at Level 8"><span class="hotkey-display">2</span></div><span class="spell-label">Flame Wave</span></div>
                <div id="frost-nova-container" class="spell-container">
                    <div id="frost-nova-spell" class="spell-icon locked" title="Unlock at Level 12"><span class="hotkey-display">3</span></div><span class="spell-label">Frost Nova</span></div>
                <div id="heal-container" class="spell-container">
                    <div id="heal-spell" class="spell-icon locked" title="Unlock at Level 16"><span class="hotkey-display">4</span></div><span class="spell-label">Heal</span></div>
            </div>
            <div id="old-feedback-area"></div>
            <button id="end-turn-button" title="End Player Turn (E)"></button>
        </div>

        <div id="start-screen" class="overlay visible">
            <h2>Knights Vs Goblins</h2>
            <p>Defeat all Goblins to advance levels. Use 1,2,3,4 for spells, E to end turn, M to mute, F for fullscreen. Hover units for info. Open Menu [‚ò∞] for options.</p>
            <button id="start-button">Begin Conquest!</button>
        </div>
        <div id="game-over-screen" class="overlay">
            <h2 id="game-over-title">Defeat!</h2>
            <p id="game-over-message"></p>
            <button id="restart-button">Restart Level</button>
        </div>
        <div id="leaderboard-overlay" class="overlay">
            <h2>Leaderboard</h2>
            <p>(Placeholder - requires server storage)</p>
            <ul id="leaderboard-list">
                <li><span>Player 1</span> <span>150 Gold</span></li>
                <li><span>HeroKnight</span> <span>125 Gold</span></li>
                <li><span>GoblinSlayer</span> <span>100 Gold</span></li>
                <li><span>Archmage</span> <span>90 Gold</span></li>
                <li><span>Sir Reginald</span> <span>75 Gold</span></li>
            </ul>
            <button id="close-leaderboard-button" class="overlay-button-like">Close</button>
        </div>
        <div id="menu-overlay" class="overlay">
            <div id="menu-overlay-content">
                <h2>Menu</h2>
                <div id="gold-display">Gold: 0</div>
                <div id="menu-buttons-container">
                    <button id="leaderboard-button" class="menu-ui-button" title="Leaderboard">üèÜ Leaderboard</button>
                    <button id="mute-button" class="menu-ui-button" title="Toggle Sound (M)">üîä Mute Sound</button>
                    <button id="fullscreen-button" class="menu-ui-button" title="Toggle Fullscreen (F)" disabled>&#x26F6; Fullscreen</button>
                </div>
                <button id="close-menu-button" class="overlay-button-like">Close Menu</button>
            </div>
        </div>

        <div id="unit-tooltip"></div>
    </div>

    <script>
        let gameContainer, gameBoard, uiPanel, levelDisplayElement, goldDisplayElement, spellAreaElement,
            fireballElement, flameWaveElement, frostNovaElement, healElement, turnInfo, unitInfo, unitPortraitElement,
            currentTurnDisplay, actionsLeftDisplay, unitNameDisplay, unitHpDisplay, unitAtkDisplay, unitMovDisplay,
            unitRngDisplay, unitStatusDisplay, boardFeedbackArea, endTurnButton, startScreen, gameOverScreen,
            startButton, restartButton, gameOverTitle, gameOverMessage, fullscreenButton, muteButton, tooltipElement,
            leaderboardButton, leaderboardOverlay, leaderboardList, closeLeaderboardButton,
            menuButton, menuOverlay, closeMenuButton;

        const musicTracks = ['audio/music_Treasure.mp3', 'audio/music_AoiUsagi-Die.mp3', 'audio/music_WormsTheme.mp3', 'audio/bgm.mp3'];
        const sfx = {};
        let bgMusic = new Audio();
        bgMusic.loop = true;
        bgMusic.volume = 0.3;
        let isMuted = false;
        let audioInitialized = false;

        const SFX_FILES = {
            success: 'audio/Success.wav', error: 'audio/Error.wav', gameOver: 'audio/GameOver.wav',
            hit: 'audio/sfxHit.wav', defeat: 'audio/sfxGoblinDead.wav', move: 'audio/sfxMove.wav',
            select: 'audio/sfxSelect.wav', fireballShoot: 'audio/fireball_shoot.wav', fireballHit: 'audio/sfxFireballHit.wav',
            frostNovaCast: 'audio/sfxFrostboltCast.wav', frostNovaHit: 'audio/sfxFrostboltHit.wav',
            playerDie: 'audio/player_die.wav', startBeep: 'audio/start_beep.wav', heal: 'audio/heal.wav',
            arrowShoot: 'audio/arrow_shoot.wav', pickup: 'audio/pickup.wav', goldDrop: 'audio/gold_drop.wav',
            cheat: 'audio/Success.wav', menuOpen: 'audio/sfxSelect.wav', menuClose: 'audio/sfxSelect.wav'
        };

        function loadSfx() {
            Object.keys(SFX_FILES).forEach(key => {
                sfx[key] = new Audio(SFX_FILES[key]);
                sfx[key].preload = 'auto';
            });
            sfx.success.volume = 0.6; sfx.error.volume = 0.6; sfx.gameOver.volume = 0.8;
            sfx.hit.volume = 0.7; sfx.defeat.volume = 0.7; sfx.move.volume = 0.4;
            sfx.select.volume = 0.5; sfx.fireballShoot.volume = 0.7; sfx.fireballHit.volume = 0.8;
            sfx.frostNovaCast.volume = 0.6; sfx.frostNovaHit.volume = 0.7;
            sfx.playerDie.volume = 0.7; sfx.startBeep.volume = 0.6; sfx.heal.volume = 0.7;
            sfx.arrowShoot.volume = 0.5; sfx.pickup.volume = 0.7; sfx.goldDrop.volume = 0.6;
            sfx.cheat.volume = 0.7; sfx.menuOpen.volume = 0.5; sfx.menuClose.volume = 0.5;
        }

        function playSfx(soundKey) {
            const sound = sfx[soundKey];
            if (isMuted || !audioInitialized || !sound) return;
            try {
                sound.currentTime = 0;
                sound.play().catch(e => {});
            } catch (e) {}
        }

        function startMusic() {
            if (isMuted || !audioInitialized) return;
            if (!bgMusic.src) {
                selectAndLoadMusic();
                if (!bgMusic.src) return;
            }
            const playPromise = bgMusic.play();
            if (playPromise) {
                playPromise.catch(error => { if (error.name === 'NotAllowedError') {} });
            }
        }

        function stopMusic() {
            if (bgMusic && !bgMusic.paused) {
                bgMusic.pause();
                bgMusic.currentTime = 0;
            }
        }

        function selectAndLoadMusic() {
            if (musicTracks.length === 0) return;
            const i = Math.floor(Math.random() * musicTracks.length);
            const t = musicTracks[i];
            if (t) {
                bgMusic.src = t;
                bgMusic.load();
            }
        }

        function initializeAudio() {
            if (audioInitialized) return true;
            const AC = window.AudioContext || window.webkitAudioContext;
            if (!AC) {
                audioInitialized = true;
                loadSfx();
                return audioInitialized;
            }
            const context = new AC();
            const unlockAudio = () => {
                context.resume().then(() => {
                    audioInitialized = true;
                    loadSfx();
                    startMusicIfNotPlaying();
                    document.removeEventListener('click', unlockAudio, true);
                    document.removeEventListener('keydown', unlockAudio, true);
                    document.removeEventListener('touchstart', unlockAudio, true);
                }).catch(e => {});
            };
            if (context.state === 'suspended') {
                document.addEventListener('click', unlockAudio, { once: true, capture: true });
                document.addEventListener('keydown', unlockAudio, { once: true, capture: true });
                document.addEventListener('touchstart', unlockAudio, { once: true, capture: true });
            } else {
                audioInitialized = true;
                loadSfx();
            }
            return audioInitialized;
        }


        function startMusicIfNotPlaying() {
            if (startScreen && !startScreen.classList.contains('visible') && !isGameOver() && !isMuted && bgMusic.paused) {
                startMusic();
            }
        }

        const GRID_COLS = 8;
        const GRID_ROWS = 10;
        let currentCellSize = 30;
        const FIREBALL_UNLOCK_LEVEL = 4;
        const FIREBALL_DAMAGE = 2;
        const FLAME_WAVE_UNLOCK_LEVEL = 8;
        const FLAME_WAVE_DAMAGE = 1;
        const FROST_NOVA_UNLOCK_LEVEL = 12;
        const FROST_NOVA_DURATION = 3;
        const HEAL_UNLOCK_LEVEL = 16;
        const HEAL_AMOUNT = 3;
        const ARCHER_KNIGHT_INTRO_LEVEL = 2;
        const GOBLIN_ARCHER_INTRO_LEVEL = 3;
        const CLUBBER_INTRO_LEVEL = 7;
        const ARROW_FLY_DURATION_MS = 300;
        const FIREBALL_PROJECTILE_DURATION_MS = 400;
        const FIREBALL_EXPLOSION_DURATION_MS = 800;
        let FLAME_WAVE_STAGGER_DELAY_MS = 50;
        const ENEMY_SPAWN_ROWS = 3;
        const PLAYER_SPAWN_ROWS = 2;
        const MIN_OBSTACLES = 2;
        const MAX_OBSTACLES_PER_LEVEL = 0.75;
        const WALL_ROCK_CHANCE = 0.4;
        const GOLD_DROP_CHANCE = 0.6;
        const BASE_GOLD_DROP_AMOUNT = 1;
        const ADVANCED_GOBLIN_TYPES = ['goblin_archer', 'goblin_clubber'];
        const ADVANCED_GOBLIN_EXTRA_GOLD_CHANCE = 0.25;
        const ADVANCED_GOBLIN_EXTRA_GOLD_AMOUNT = 1;
        const GOLD_PENALTY_ON_DEATH = 5;
        const UNIT_DATA = {
            knight: { name: "Knight", hp: 6, atk: 1, mov: 3, range: 1, team: 'player', spriteUrl: './sprites/Knight.png', deadSpriteUrl: './sprites/Knight_dead.png', portraitUrl: './sprites/knight_portrait.png' },
            knight_archer: { name: "Archer", hp: 3, atk: 1, mov: 2, range: 4, team: 'player', spriteUrl: './sprites/archer.png', deadSpriteUrl: './sprites/archer_dead.png', portraitUrl: './sprites/archer_portrait.png' },
            goblin: { name: "Goblin", hp: 2, atk: 1, mov: 4, range: 1, team: 'enemy', spriteUrl: './sprites/Goblin.png', deadSpriteUrl: './sprites/Goblin_dead.png', portraitUrl: './sprites/goblin_portrait.png' },
            goblin_archer: { name: "Goblin Archer", hp: 1, atk: 1, mov: 3, range: 4, team: 'enemy', spriteUrl: './sprites/goblin_archer.png', deadSpriteUrl: './sprites/Goblin_dead.png', portraitUrl: './sprites/goblin_archer_portrait.png' },
            goblin_clubber: { name: "Goblin Clubber", hp: 3, atk: 2, mov: 3, range: 1, knockback: true, team: 'enemy', spriteUrl: './sprites/goblin_club.png', deadSpriteUrl: './sprites/Goblin_dead.png', portraitUrl: './sprites/goblin_club_portrait.png' }
        };
        const OBSTACLE_TYPES = {
            rock: { blocksMove: true, blocksLOS: false, spriteClass: 'rock' },
            wall_rock: { blocksMove: true, blocksLOS: true, spriteClass: 'wall_rock' }
        };
        let units = [];
        let selectedUnit = null;
        let currentTurn = 'player';
        let validMoves = [];
        let validAttacks = [];
        let highlightedAttackCells = [];
        let unitCounter = 0;
        let isProcessing = false;
        let currentLevel = 1;
        let playerGold = 0;
        let levelToRestartOnLoss = 1;
        let currentSpell = null;
        let spellUses = { fireball: false, flameWave: false, frostNova: false, heal: false };
        let unlimitedSpellsCheat = false;
        let resizeTimeout = null;
        let winCheckTimeout = null;
        let MOVE_ANIMATION_DURATION_MS = 250;
        let gridState = [];
        let droppedGold = [];
        let levelClearedAwaitingInput = false;
        let currentMouseX = 0;
        let currentMouseY = 0;
        let lastHoveredUnitId = null;
        let tooltipUpdateInterval = null;

        function isUnitAliveAndValid(unit) {
            return unit && unit.hp > 0 && unit.element && !unit.element.classList.contains('dead');
        }

        function isCellInBounds(x, y) {
            return x >= 0 && x < GRID_COLS && y >= 0 && y < GRID_ROWS;
        }

        function getObstacleAt(x, y) {
            if (!isCellInBounds(x, y) || !gridState[y] || gridState[y].length <= x) return null;
            const obstacleType = gridState[y][x];
            return obstacleType ? OBSTACLE_TYPES[obstacleType] : null;
        }

        function getGoldAt(x, y) {
            return droppedGold.some(gold => gold.x === x && gold.y === y);
        }

        function resetSpellStateForNewLevel() {
            currentSpell = null;
            spellUses = {
                fireball: currentLevel >= FIREBALL_UNLOCK_LEVEL,
                flameWave: currentLevel >= FLAME_WAVE_UNLOCK_LEVEL,
                frostNova: currentLevel >= FROST_NOVA_UNLOCK_LEVEL,
                heal: currentLevel >= HEAL_UNLOCK_LEVEL
            };
            if (unlimitedSpellsCheat) {
                spellUses = { fireball: true, flameWave: true, frostNova: true, heal: true };
            }
            if (gameBoard) {
                gameBoard.className = '';
                gameBoard.style.removeProperty('--hover-col');
            }
            updateSpellUI();
            clearFrostNovaPreview();
        }

        function clearDroppedGold() {
            droppedGold.forEach(gold => {
                if (gold.element) gold.element.remove();
            });
            droppedGold = [];
        }

        function resetLevelState() {
            units = [];
            unitCounter = 0;
            selectedUnit = null;
            lastHoveredUnitId = null;
            validMoves = [];
            validAttacks = [];
            highlightedAttackCells = [];
            currentTurn = 'player';
            gridState = [];
            clearDroppedGold();
            levelClearedAwaitingInput = false;
            if (winCheckTimeout) clearTimeout(winCheckTimeout);
            winCheckTimeout = null;
            if (resizeTimeout) clearTimeout(resizeTimeout);
            resizeTimeout = null;
            isProcessing = false;
            document.querySelectorAll('#game-board .unit, #game-board .damage-popup, #game-board .freeze-popup, #game-board .heal-popup, #game-board .projectile, #game-board .obstacle, #game-board .item, #game-board .fireball-explosion').forEach(el => el.remove());
            document.querySelectorAll('#game-board .grid-cell').forEach(cell => {
                 cell.classList.remove('has-obstacle');
                 cell.innerHTML = '';
            });
            clearHighlights();
            if (endTurnButton) {
                endTurnButton.innerHTML = `<span class="hotkey-e">[E]</span>nd Turn`;
                endTurnButton.title = "End Player Turn (E)";
                endTurnButton.classList.remove('next-level-mode');
            }
        }

        function calculateCellSize() {
            if (!gameBoard) return;
            const boardWidth = gameBoard.clientWidth;
            const boardHeight = gameBoard.clientHeight;
            if (boardWidth > 1 && boardHeight > 1) {
                const cellWidth = Math.floor(boardWidth / GRID_COLS);
                const cellHeight = Math.floor(boardHeight / GRID_ROWS);
                currentCellSize = Math.max(1, Math.min(cellWidth, cellHeight));
            } else {
                currentCellSize = Math.max(currentCellSize, 20);
            }
            currentCellSize = Math.max(currentCellSize, 10);
            document.documentElement.style.setProperty('--cell-size', `${currentCellSize}px`);
        }

        function applyLayout() {
            if (currentCellSize < 10) calculateCellSize();
            if (currentCellSize < 10) return;

            const unitsToUpdate = units.filter(u => u.element && !u.element.classList.contains('dead'));
            unitsToUpdate.forEach(u => updateUnitPosition(u, true));

            document.querySelectorAll('#game-board .unit.dead').forEach(deadEl => {
                const unitId = parseInt(deadEl.dataset.id);
                const unit = units.find(u => u.id === unitId);
                if (unit) updateUnitVisualPositionOnly(deadEl, unit.x, unit.y);
            });

            document.querySelectorAll('#game-board .obstacle').forEach(obsEl => {
                updateObstaclePosition(obsEl);
            });

            droppedGold.forEach(gold => {
                if (gold.element) updateItemPosition(gold.element, gold.x, gold.y, gold.stackIndex);
            });

            if (selectedUnit) highlightMovesAndAttacks(selectedUnit);
        }

        function updateUnitVisualPositionOnly(element, x, y) {
             if (!element || !isCellInBounds(x,y)) return;
             const targetX = x; const targetY = y;
             element.style.setProperty('--unit-x', targetX + 1);
             element.style.setProperty('--unit-y', targetY + 1);

             const baseLeft = (targetX * currentCellSize);
             const baseTop = (targetY * currentCellSize);
             const width = parseFloat(getComputedStyle(element).width);
             const height = parseFloat(getComputedStyle(element).height);
             const offsetX = (currentCellSize - width) / 2;
             const offsetY = (currentCellSize - height) / 2;

             element.style.left = `${baseLeft + offsetX}px`;
             element.style.top = `${baseTop + offsetY}px`;
        }

        function updateObstaclePosition(element) {
             if (!element) return;
             const x = parseInt(element.style.getPropertyValue('--obs-x')) - 1;
             const y = parseInt(element.style.getPropertyValue('--obs-y')) - 1;
             if (!isCellInBounds(x, y)) return;

             const isRock = element.classList.contains('rock');
             if (isRock) {
                element.style.width = `calc(var(--cell-size) * 0.8)`;
                element.style.height = `calc(var(--cell-size) * 0.8)`;
                element.style.left = `calc(${x} * var(--cell-size) + var(--cell-size) * 0.1)`;
                element.style.top = `calc(${y} * var(--cell-size) + var(--cell-size) * 0.1)`;
             } else {
                element.style.width = `var(--cell-size)`;
                element.style.height = `var(--cell-size)`;
                element.style.left = `calc(${x} * var(--cell-size))`;
                element.style.top = `calc(${y} * var(--cell-size))`;
             }
        }


        const handleResize = () => {
            if (resizeTimeout) clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (isGameOver() || (startScreen && startScreen.classList.contains('visible'))) return;
                requestAnimationFrame(() => {
                    try {
                        calculateCellSize();
                        applyLayout();
                    } catch (e) {}
                });
            }, 100);
        };

        function isFullscreen() {
            return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
        }

        function toggleFullscreen() {
            if (!initializeAudio()) return;
            const fsEnabled = document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled;
            if (!fsEnabled) return;
            if (!isFullscreen()) {
                const el = gameContainer;
                if (el.requestFullscreen) el.requestFullscreen().catch(err => {});
                else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen().catch(err => {});
                else if (el.mozRequestFullScreen) el.mozRequestFullScreen().catch(err => {});
                else if (el.msRequestFullscreen) el.msRequestFullscreen().catch(err => {});
            } else {
                if (document.exitFullscreen) document.exitFullscreen().catch(err => {});
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen().catch(err => {});
                else if (document.mozCancelFullScreen) document.mozCancelFullScreen().catch(err => {});
                else if (document.msExitFullscreen) document.msExitFullscreen().catch(err => {});
            }
        }

        function updateFullscreenButton() {
            const fsEnabled = document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled;
            if (fullscreenButton) {
                fullscreenButton.disabled = !fsEnabled;
                fullscreenButton.innerHTML = isFullscreen() ? '&#x2715; Exit Fullscreen' : '&#x26F6; Fullscreen';
                fullscreenButton.title = isFullscreen() ? 'Exit Fullscreen (F)' : 'Enter Fullscreen (F)';
            }
        }

        function initGame(startLevel = 1) {
            isProcessing = true;
            if (!audioInitialized) initializeAudio();
            playSfx('startBeep');
            currentLevel = startLevel;
            if (startLevel === 1) {
                playerGold = 0;
            }
            resetLevelState();
            resetSpellStateForNewLevel();
            isProcessing = true;
            stopMusic();
            if (sfx.gameOver) { sfx.gameOver.pause(); sfx.gameOver.currentTime = 0; }
            selectAndLoadMusic();
            try {
                setupBoard();
                initializeGridState();
                updateLevelDisplay();
                updateGoldDisplay();
                updateUnitInfo(null);
                if (boardFeedbackArea) {
                    boardFeedbackArea.textContent = '';
                    boardFeedbackArea.className = '';
                    boardFeedbackArea.style.opacity = '1';
                }
                if (endTurnButton) {
                    endTurnButton.classList.remove('disabled');
                    endTurnButton.disabled = false;
                }
                if (gameOverScreen) gameOverScreen.classList.remove('visible');
                if (startScreen) startScreen.classList.remove('visible');
                if (menuOverlay) menuOverlay.classList.remove('visible');
                if (leaderboardOverlay) leaderboardOverlay.classList.remove('visible');

                window.addEventListener('resize', handleResize, { passive: true });
                document.addEventListener('fullscreenchange', updateFullscreenButton);
                document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
                document.addEventListener('mozfullscreenchange', updateFullscreenButton);
                document.addEventListener('MSFullscreenChange', updateFullscreenButton);
                updateFullscreenButton();
                document.addEventListener('mousemove', trackMousePosition);
                startTooltipUpdater();

                requestAnimationFrame(() => {
                    try {
                        calculateCellSize();
                        spawnObstacles();
                        spawnInitialUnits();
                        units.forEach(u => {
                            if (u.team === 'player') u.acted = false;
                            u.isFrozen = false;
                            u.frozenTurnsLeft = 0;
                        });
                        renderAllUnits();
                        applyLayout();
                        updateTurnDisplay();
                        startMusicIfNotPlaying();
                    } catch (rafError) {
                    } finally {
                        isProcessing = false;
                        updateTurnDisplay();
                    }
                });
            } catch (initError) {
                isProcessing = false;
                updateTurnDisplay();
            }
        }

        function setupBoard() {
            if (!gameBoard) return;
            gameBoard.innerHTML = '';
            gameBoard.className = '';
            const fragment = document.createDocumentFragment();
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    cell.dataset.x = c;
                    cell.dataset.y = r;
                    cell.addEventListener('click', handleCellClick);
                    cell.addEventListener('mouseenter', handleCellMouseEnter);
                    cell.addEventListener('mouseleave', handleCellMouseLeave);
                    cell.style.gridColumn = c + 1;
                    cell.style.gridRow = r + 1;
                    fragment.appendChild(cell);
                }
            }
            gameBoard.appendChild(fragment);
            gameBoard.addEventListener('mouseleave', handleMouseLeaveOnBoard);
        }

        function initializeGridState() {
            gridState = Array.from({ length: GRID_ROWS }, () => Array(GRID_COLS).fill(null));
        }

        function spawnObstacles() {
            const numObstacles = MIN_OBSTACLES + Math.floor(currentLevel * MAX_OBSTACLES_PER_LEVEL);
            const validSpawnMinY = ENEMY_SPAWN_ROWS;
            const validSpawnMaxY = GRID_ROWS - PLAYER_SPAWN_ROWS - 1;
            let spawnedCount = 0;
            let attempts = 0;
            const maxAttempts = numObstacles * 20;
            if (validSpawnMinY > validSpawnMaxY || !gameBoard) {
                return;
            }
            const fragment = document.createDocumentFragment();
            while (spawnedCount < numObstacles && attempts < maxAttempts) {
                attempts++;
                const x = Math.floor(Math.random() * GRID_COLS);
                const y = Math.floor(Math.random() * (validSpawnMaxY - validSpawnMinY + 1)) + validSpawnMinY;

                if (isCellInBounds(x, y) && gridState[y] && gridState[y][x] === null) {
                    const isWall = Math.random() < WALL_ROCK_CHANCE;
                    const obstacleType = isWall ? 'wall_rock' : 'rock';
                    gridState[y][x] = obstacleType;
                    const obstacleData = OBSTACLE_TYPES[obstacleType];
                    if (obstacleData) {
                        const obsEl = document.createElement('div');
                        obsEl.classList.add('obstacle', obstacleData.spriteClass);
                        obsEl.style.setProperty('--obs-x', x + 1);
                        obsEl.style.setProperty('--obs-y', y + 1);
                        fragment.appendChild(obsEl);
                        const cellEl = getCellElement(x, y);
                        if (cellEl) cellEl.classList.add('has-obstacle');
                        spawnedCount++;
                    }
                }
            }
            gameBoard.appendChild(fragment);
        }

        function spawnInitialUnits() {
            const occupied = new Set();
            const playerPositions = [
                { x: 1, y: GRID_ROWS - 1 }, { x: 3, y: GRID_ROWS - 1 }, { x: 5, y: GRID_ROWS - 1 }, { x: 7, y: GRID_ROWS - 1 },
                { x: 0, y: GRID_ROWS - 2 }, { x: 2, y: GRID_ROWS - 2 }, { x: 4, y: GRID_ROWS - 2 }, { x: 6, y: GRID_ROWS - 2 }
            ];
            let numPlayerUnits = 3 + Math.floor(currentLevel / 6);
            numPlayerUnits = Math.min(numPlayerUnits, playerPositions.length);

            let numArchers = (currentLevel >= ARCHER_KNIGHT_INTRO_LEVEL) ? 1 : 0;
            numArchers += Math.floor(currentLevel / 10);
            numArchers = Math.min(numArchers, numPlayerUnits);
            let numKnights = numPlayerUnits - numArchers;

            let playerUnitsSpawned = 0;
            let archersSpawned = 0;
            let knightsSpawned = 0;
            const shuffledPositions = [...playerPositions].sort(() => 0.5 - Math.random());

            for (let i = 0; i < shuffledPositions.length && archersSpawned < numArchers && playerUnitsSpawned < numPlayerUnits; i++) {
                const p = shuffledPositions[i];
                if (isCellInBounds(p.x, p.y) && gridState[p.y]?.[p.x] === null && !occupied.has(`${p.x},${p.y}`)) {
                    createUnit('knight_archer', p.x, p.y);
                    occupied.add(`${p.x},${p.y}`);
                    archersSpawned++; playerUnitsSpawned++;
                }
            }

            for (let i = 0; i < shuffledPositions.length && knightsSpawned < numKnights && playerUnitsSpawned < numPlayerUnits; i++) {
                const p = shuffledPositions[i];
                 if (isCellInBounds(p.x, p.y) && gridState[p.y]?.[p.x] === null && !occupied.has(`${p.x},${p.y}`)) {
                    createUnit('knight', p.x, p.y);
                    occupied.add(`${p.x},${p.y}`);
                    knightsSpawned++; playerUnitsSpawned++;
                }
            }

            const numEnemies = 3 + currentLevel;
            const unitsToSpawn = [];
            const types = ['goblin'];
            if (currentLevel >= GOBLIN_ARCHER_INTRO_LEVEL) types.push('goblin_archer');
            if (currentLevel >= CLUBBER_INTRO_LEVEL) types.push('goblin_clubber');
            for (let i = 0; i < numEnemies; i++) {
                 unitsToSpawn.push(types[Math.floor(Math.random() * types.length)]);
            }
            if (currentLevel === GOBLIN_ARCHER_INTRO_LEVEL && !unitsToSpawn.includes('goblin_archer')) unitsToSpawn[0] = 'goblin_archer';
            if (currentLevel === CLUBBER_INTRO_LEVEL && !unitsToSpawn.includes('goblin_clubber')) unitsToSpawn[0] = 'goblin_clubber';


            for (const typeToSpawn of unitsToSpawn) {
                let spawned = false; let attempts = 0; const maxAttempts = GRID_COLS * ENEMY_SPAWN_ROWS * 3;
                while (!spawned && attempts < maxAttempts) {
                    attempts++;
                    const x = Math.floor(Math.random() * GRID_COLS); const y = Math.floor(Math.random() * ENEMY_SPAWN_ROWS); const key = `${x},${y}`;
                    if (isCellInBounds(x, y) && gridState[y]?.[x] === null && !occupied.has(key)) {
                        createUnit(typeToSpawn, x, y); occupied.add(key); spawned = true;
                    }
                }
            }
        }

        function createUnit(type, x, y) {
            const data = UNIT_DATA[type]; if (!data) return;
            const unit = {
                id: unitCounter++, type, x, y, hp: data.hp, maxHp: data.hp, atk: data.atk, mov: data.mov, range: data.range,
                knockback: data.knockback || false, team: data.team, acted: false, element: null,
                deadSpriteUrl: data.deadSpriteUrl, isFrozen: false, frozenTurnsLeft: 0
            };
            units.push(unit);
        }

        function renderAllUnits() {
            if (!gameBoard) return;
            document.querySelectorAll('#game-board .unit').forEach(el => el.remove());
            const fragment = document.createDocumentFragment();
            units.forEach(unit => {
                const el = renderUnit(unit, false);
                if (el) fragment.appendChild(el);
            });
            gameBoard.appendChild(fragment);
        }

        function renderUnit(unit, shouldAppend = true) {
            if (!gameBoard && shouldAppend) return null;
            if (unit.element && unit.element.parentNode) unit.element.remove();

            const el = document.createElement('div');
            el.classList.add('unit', unit.team);
            el.dataset.id = unit.id;
            const data = UNIT_DATA[unit.type];
            if (data?.spriteUrl) el.style.backgroundImage = `url('${data.spriteUrl}')`;
            el.classList.toggle('selected', selectedUnit?.id === unit.id);
            el.classList.toggle('acted', unit.acted);
            el.classList.toggle('frozen', unit.isFrozen);
            el.addEventListener('click', (ev) => handleUnitClick(ev, unit), { passive: false });
            unit.element = el;
            if (shouldAppend && gameBoard) gameBoard.appendChild(el);
            updateUnitPosition(unit, true);
            return el;
        }


        function updateUnitPosition(unit, forceUpdateSize = false) {
            if (!unit || !unit.element || unit.element.classList.contains('dead')) return;
            const targetCol = unit.x + 1; const targetRow = unit.y + 1;
            unit.element.style.setProperty('--unit-x', targetCol);
            unit.element.style.setProperty('--unit-y', targetRow);

            const baseLeft = (unit.x * currentCellSize);
            const baseTop = (unit.y * currentCellSize);
            const width = parseFloat(getComputedStyle(unit.element).width);
            const height = parseFloat(getComputedStyle(unit.element).height);
            const offsetX = (currentCellSize - width) / 2;
            const offsetY = (currentCellSize - height) / 2;

            unit.element.style.left = `${baseLeft + offsetX}px`;
            unit.element.style.top = `${baseTop + offsetY}px`;


            unit.element.classList.toggle('acted', unit.acted);
            unit.element.classList.toggle('selected', selectedUnit?.id === unit.id);
            unit.element.classList.toggle('frozen', unit.isFrozen);

            if (!unit.element.classList.contains('is-moving')) {
                 unit.element.style.transform = 'none';
            }

            unit.element.style.opacity = '1';
        }


        function updateItemPosition(element, x, y, stackIndex = 0) {
            if (!element) return;
            element.style.setProperty('--item-x', x + 1);
            element.style.setProperty('--item-y', y + 1);
            element.style.setProperty('--stackIndex', stackIndex);

            const baseLeft = (x * currentCellSize);
            const baseTop = (y * currentCellSize);
            const width = parseFloat(getComputedStyle(element).width);
            const height = parseFloat(getComputedStyle(element).height);
            const offsetX = (currentCellSize - width) / 2;
            const offsetY = (currentCellSize - height) / 2;

            element.style.left = `${baseLeft + offsetX + stackIndex * parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--stack-offset-x') || 0)}px`;
            element.style.top = `${baseTop + offsetY + stackIndex * parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--stack-offset-y') || 0)}px`;
            element.style.transform = 'none';
        }

        function clearHighlights() {
            document.querySelectorAll('.grid-cell.valid-move').forEach(c => c.classList.remove('valid-move'));
            document.querySelectorAll('.grid-cell.valid-attack-target').forEach(c => c.classList.remove('valid-attack-target'));
            validMoves = [];
            validAttacks = [];
            highlightedAttackCells = [];
        }

        function highlightMovesAndAttacks(unit) {
            clearHighlights();
            if (!unit || (!levelClearedAwaitingInput && unit.acted) || unit.isFrozen || !isUnitAliveAndValid(unit)) return;

            validMoves = getValidMoves(unit);
            validAttacks = getValidAttacks(unit);

            validMoves.forEach(p => {
                const c = getCellElement(p.x, p.y);
                if (c && !c.classList.contains('has-obstacle')) c.classList.add('valid-move');
            });

            validAttacks.forEach(targetId => {
                const targetUnit = units.find(u => u.id === targetId);
                if (targetUnit && isUnitAliveAndValid(targetUnit)) {
                    const c = getCellElement(targetUnit.x, targetUnit.y);
                    if (c) {
                        c.classList.add('valid-attack-target');
                        highlightedAttackCells.push(c);
                    }
                }
            });
        }


        function showPopup(x, y, text, className) {
            if (!gameBoard) return;
            const popup = document.createElement('div');
            popup.classList.add(className);
            popup.textContent = text;
            const boardRect = gameBoard.getBoundingClientRect();
            const popupX = (x + 0.5) * currentCellSize;
            const popupY = (y + 0.5) * currentCellSize - 15;
            popup.style.left = `${popupX}px`;
            popup.style.top = `${popupY}px`;
            popup.style.transform = 'translateX(-50%)';
            gameBoard.appendChild(popup);
            const duration = (className === 'freeze-popup') ? 800 : 1000;
            setTimeout(() => popup.remove(), duration);
        }

        function showDamagePopup(x, y, damage) { showPopup(x, y, `-${damage}`, 'damage-popup'); }
        function showFreezePopup(x, y) { showPopup(x, y, `Frozen!`, 'freeze-popup'); }
        function showHealPopup(x, y, amount) { showPopup(x, y, `+${amount}`, 'heal-popup'); }
        function updateLevelDisplay() { if (levelDisplayElement) levelDisplayElement.textContent = `Level: ${currentLevel}`; }
        function updateGoldDisplay() { if (goldDisplayElement) goldDisplayElement.textContent = `Gold: ${playerGold}`; }

        function updateSpellUI() {
            if (!fireballElement || !flameWaveElement || !frostNovaElement || !healElement) return;
            const spellData = [
                { el: fireballElement, name: 'fireball', unlock: FIREBALL_UNLOCK_LEVEL, label: "Fireball" },
                { el: flameWaveElement, name: 'flameWave', unlock: FLAME_WAVE_UNLOCK_LEVEL, label: "Flame Wave" },
                { el: frostNovaElement, name: 'frostNova', unlock: FROST_NOVA_UNLOCK_LEVEL, label: "Frost Nova" },
                { el: healElement, name: 'heal', unlock: HEAL_UNLOCK_LEVEL, label: "Heal" }
            ];
            spellData.forEach(spell => {
                if (!spell.el) return;
                const normallyUnlocked = currentLevel >= spell.unlock;
                const cheatActive = unlimitedSpellsCheat;
                const isEffectivelyUnlocked = normallyUnlocked || cheatActive;
                const isAvailableThisLevel = spellUses[spell.name] || cheatActive;
                spell.el.className = 'spell-icon';
                if (!isEffectivelyUnlocked) {
                    spell.el.classList.add('locked');
                    spell.el.title = `Unlock at Level ${spell.unlock}`;
                } else if (!isAvailableThisLevel) {
                    spell.el.classList.add('used');
                    spell.el.title = `${spell.label} (Used this level)`;
                } else {
                    spell.el.classList.add('available');
                    if (cheatActive) {
                        spell.el.classList.add('cheat-available');
                        spell.el.title = normallyUnlocked ? `${spell.label} (CHEAT ACTIVE)` : `${spell.label} (CHEAT UNLOCKED)`;
                    } else {
                        spell.el.title = spell.label;
                    }
                    if (currentSpell === spell.name) {
                        spell.el.classList.add('selected');
                    }
                }
                const labelEl = spell.el.nextElementSibling;
                if (labelEl) {
                   if (!isEffectivelyUnlocked) labelEl.style.color = '#a85858';
                   else if (!isAvailableThisLevel) labelEl.style.color = '#aaa';
                   else if (cheatActive) labelEl.style.color = 'lime';
                   else labelEl.style.color = '#eee';
                }
            });
            if (gameBoard) {
                gameBoard.classList.toggle('fireball-targeting', currentSpell === 'fireball');
                gameBoard.classList.toggle('flame-wave-targeting', currentSpell === 'flameWave');
                gameBoard.classList.toggle('frost-nova-targeting', currentSpell === 'frostNova');
                gameBoard.classList.toggle('heal-targeting', currentSpell === 'heal');
            }
        }

        function updateTurnDisplay() {
            if (!currentTurnDisplay || !actionsLeftDisplay || !endTurnButton) return;
            const isPlayer = currentTurn === 'player';
            currentTurnDisplay.textContent = `Turn: ${isPlayer ? 'Player' : 'Enemy'}`;
            let btnDisabled = false; let btnClassDisabled = false;
            if (isPlayer) {
                const rem = units.filter(u => u.team === 'player' && !u.acted && !u.isFrozen && isUnitAliveAndValid(u)).length;
                actionsLeftDisplay.textContent = levelClearedAwaitingInput ? `Collect Gold!` : `Actions Left: ${rem}`;
                btnDisabled = isProcessing; btnClassDisabled = isProcessing;
            } else {
                actionsLeftDisplay.textContent = `AI Thinking...`;
                btnDisabled = true; btnClassDisabled = true;
            }
            endTurnButton.disabled = btnDisabled;
            endTurnButton.classList.toggle('disabled', btnClassDisabled);
            if (levelClearedAwaitingInput) {
                endTurnButton.innerHTML = `N<span class="hotkey-e">[E]</span>xt Level`;
                endTurnButton.title = "Proceed to Next Level (E)";
                endTurnButton.classList.add('next-level-mode');
                endTurnButton.disabled = false; endTurnButton.classList.remove('disabled');
            } else {
                endTurnButton.innerHTML = `<span class="hotkey-e">[E]</span>nd Turn`;
                endTurnButton.title = "End Player Turn (E)";
                endTurnButton.classList.remove('next-level-mode');
                endTurnButton.disabled = btnDisabled;
                endTurnButton.classList.toggle('disabled', btnClassDisabled);
            }
        }

        function updateUnitInfo(unit) {
             if (!unitInfo || !unitNameDisplay || !unitHpDisplay || !unitAtkDisplay || !unitMovDisplay || !unitRngDisplay || !unitStatusDisplay || !unitPortraitElement) return;
             const shouldShow = unit && isUnitAliveAndValid(unit);
             unitInfo.style.display = shouldShow ? 'flex' : 'none';

             if (shouldShow) {
                 const data = UNIT_DATA[unit.type];
                 unitNameDisplay.textContent = data ? data.name : unit.type;
                 unitHpDisplay.textContent = `HP: ${unit.hp}/${unit.maxHp}`;
                 unitAtkDisplay.textContent = `ATK: ${unit.atk}`;
                 unitMovDisplay.textContent = `MOV: ${unit.mov}`;
                 if (unit.range > 1) {
                     unitRngDisplay.textContent = `RNG: ${unit.range}`;
                     unitRngDisplay.style.display = 'block';
                 } else {
                     unitRngDisplay.style.display = 'none';
                 }
                 if (unit.isFrozen) {
                     unitStatusDisplay.textContent = `‚ùÑÔ∏è Status: Frozen (${unit.frozenTurnsLeft} turns)`;
                     unitStatusDisplay.style.display = 'block';
                 } else {
                     unitStatusDisplay.textContent = '';
                     unitStatusDisplay.style.display = 'none';
                 }
                 const portraitUrl = data?.portraitUrl;
                 if (portraitUrl) {
                     unitPortraitElement.style.backgroundImage = `url('${portraitUrl}')`;
                     unitPortraitElement.style.display = 'block';
                     unitPortraitElement.style.opacity = '1';
                 } else {
                     unitPortraitElement.style.backgroundImage = '';
                     unitPortraitElement.alt = '';
                     unitPortraitElement.style.display = 'none';
                     unitPortraitElement.style.opacity = '0';
                 }
             } else {
                 unitNameDisplay.textContent = 'Unit Info';
                 unitHpDisplay.textContent = 'HP: -/-';
                 unitAtkDisplay.textContent = 'ATK: -';
                 unitMovDisplay.textContent = 'MOV: -';
                 unitRngDisplay.textContent = 'RNG: -';
                 unitStatusDisplay.textContent = '';
                 unitRngDisplay.style.display = 'none';
                 unitStatusDisplay.style.display = 'none';
                 unitPortraitElement.style.backgroundImage = '';
                 unitPortraitElement.style.opacity = '0';
             }
        }


        function showFeedback(message, type = '', duration = 2500) {
            if (!boardFeedbackArea) return;
            boardFeedbackArea.textContent = message;
            boardFeedbackArea.className = type;
            boardFeedbackArea.style.opacity = '1';

            const standardFadeDelay = 1500;
            const fadeDuration = duration - standardFadeDelay;

            if (type === 'feedback-gold') { duration = 1500; }
            else if (type === 'feedback-cheat') { duration = 1500; }
            else if (type === 'feedback-levelup') { duration = 2000; }

            setTimeout(() => {
                if (boardFeedbackArea.textContent === message) {
                     boardFeedbackArea.style.opacity = '0';
                     setTimeout(() => {
                         if (boardFeedbackArea.style.opacity === '0') boardFeedbackArea.textContent = '';
                     }, 500);
                 }
            }, duration - 500);
        }

        function setActiveSpell(spellName) {
            if (!audioInitialized) initializeAudio();
            if (levelClearedAwaitingInput) return;
            const wasSelected = currentSpell === spellName;
            currentSpell = null;
            clearFrostNovaPreview();
            if (gameBoard) gameBoard.style.removeProperty('--hover-col');
            if (wasSelected) {
                showFeedback('');
                playSfx('select');
            } else if (spellName) {
                const spellDataMap = {
                    fireball: { unlock: FIREBALL_UNLOCK_LEVEL, available: spellUses.fireball, feedback: 'Select ENEMY target for Fireball.' },
                    flameWave: { unlock: FLAME_WAVE_UNLOCK_LEVEL, available: spellUses.flameWave, feedback: 'Click target ROW for Flame Wave.' },
                    frostNova: { unlock: FROST_NOVA_UNLOCK_LEVEL, available: spellUses.frostNova, feedback: 'Select CENTER cell for Frost Nova.' },
                    heal: { unlock: HEAL_UNLOCK_LEVEL, available: spellUses.heal, feedback: 'Select FRIENDLY unit to Heal.' }
                };
                const data = spellDataMap[spellName];
                if (data) {
                    const normallyUnlocked = currentLevel >= data.unlock;
                    const cheatActive = unlimitedSpellsCheat;
                    const isEffectivelyUnlocked = normallyUnlocked || cheatActive;
                    const isAvailableThisLevel = data.available || cheatActive;
                    if (isProcessing || currentTurn !== 'player' || !isEffectivelyUnlocked || !isAvailableThisLevel) {
                        if (!isEffectivelyUnlocked) showFeedback(`Unlock at Level ${data.unlock}!`, "feedback-error");
                        else if (!isAvailableThisLevel) showFeedback(`${spellName.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())} already used this level.`, 'feedback-error');
                        else showFeedback("Cannot select spell now.", "feedback-error");
                        playSfx('error');
                    } else {
                        currentSpell = spellName;
                        showFeedback(data.feedback);
                        playSfx('select');
                    }
                }
            }
            updateSpellUI();
        }

        async function handleCellClick(event) {
             if (event.target.classList.contains('unit') || isProcessing) return;
             if (!initializeAudio()) return;
             const cell = event.currentTarget;
             const x = parseInt(cell.dataset.x);
             const y = parseInt(cell.dataset.y);

             if (!isCellInBounds(x, y) || getObstacleAt(x, y)) {
                 playSfx('error');
                 showFeedback("Cannot target obstacle.", "feedback-error");
                 if (currentSpell) setActiveSpell(null);
                 if (selectedUnit) deselectUnit(false);
                 return;
             }

             const unitOnCell = getUnitAt(x, y);

             if (!levelClearedAwaitingInput && currentSpell) {
                 switch (currentSpell) {
                     case 'fireball':
                         playSfx('error');
                         showFeedback("Target an ENEMY unit.", "feedback-error");
                         setActiveSpell(null);
                         if (selectedUnit) deselectUnit(false);
                         return;
                    case 'frostNova': castFrostNova(x, y); return;
                    case 'flameWave': castFlameWave(y); return;
                    case 'heal':
                         playSfx('error');
                         showFeedback("Select a FRIENDLY unit.", "feedback-error");
                         setActiveSpell(null);
                         if (selectedUnit) deselectUnit(false);
                         return;
                 }
             } else if (levelClearedAwaitingInput && currentSpell) {
                 setActiveSpell(null);
                 showFeedback("Level cleared, cannot cast spells.", "feedback-error");
                 playSfx('error');
                 return;
             }

             if (currentTurn === 'player' && selectedUnit) {
                 const isMoveValid = validMoves.some(p => p.x === x && p.y === y);
                 if (isMoveValid && !unitOnCell && isCellInBounds(x, y) && !getObstacleAt(x,y)) {
                     const unitToMove = selectedUnit;
                     if (unitToMove.element) unitToMove.element.classList.remove('selected');
                     clearHighlights();
                     selectedUnit = null;
                     isProcessing = true; updateTurnDisplay();
                     await moveUnit(unitToMove, x, y);
                     checkForGoldPickup(unitToMove, x, y);
                     if (!levelClearedAwaitingInput) {
                         finishAction(unitToMove);
                     } else {
                          updateUnitPosition(unitToMove);
                     }
                     updateUnitInfo(null);
                     isProcessing = false; updateTurnDisplay();
                     if (levelClearedAwaitingInput && droppedGold.length === 0) {
                         showFeedback("All gold collected! Press [E] for Next Level.", "feedback-levelup");
                     }
                 } else {
                     deselectUnit();
                 }
             } else {
                 deselectUnit(false);
             }
        }

        function handleUnitClick(event, clickedUnit) {
             event.stopPropagation();
             if (isProcessing || !clickedUnit || !isUnitAliveAndValid(clickedUnit)) {
                 deselectUnit(false); updateUnitInfo(null);
                 return;
             }
             if (!initializeAudio()) return;

             if (!levelClearedAwaitingInput && currentSpell) {
                 switch (currentSpell) {
                     case 'fireball':
                         if (clickedUnit.team === 'enemy') castFireball(clickedUnit);
                         else { playSfx('error'); showFeedback("Target an ENEMY unit.", "feedback-error"); setActiveSpell(null); updateUnitInfo(clickedUnit); }
                         return;
                     case 'frostNova': castFrostNova(clickedUnit.x, clickedUnit.y); return;
                     case 'flameWave': castFlameWave(clickedUnit.y); return;
                     case 'heal':
                         if (clickedUnit.team === 'player') castHeal(clickedUnit);
                         else { playSfx('error'); showFeedback("Target a FRIENDLY unit.", "feedback-error"); setActiveSpell(null); updateUnitInfo(clickedUnit); }
                         return;
                 }
             } else if (levelClearedAwaitingInput && currentSpell) {
                 setActiveSpell(null); showFeedback("Level cleared, cannot cast spells.", "feedback-error"); playSfx('error');
                 return;
             }

             updateUnitInfo(clickedUnit);

             if (currentTurn === 'player') {
                 if (selectedUnit) {
                     if (!levelClearedAwaitingInput && clickedUnit.team === 'enemy' && validAttacks.includes(clickedUnit.id)) {
                         const attacker = selectedUnit;
                         deselectUnit(false);
                         isProcessing = true; updateTurnDisplay();
                         attackUnit(attacker, clickedUnit);
                     } else if (clickedUnit.team === 'player' && clickedUnit.id !== selectedUnit.id) {
                         if ((!clickedUnit.acted || levelClearedAwaitingInput) && !clickedUnit.isFrozen) {
                             selectUnit(clickedUnit);
                         } else if (clickedUnit.isFrozen) {
                             showFeedback("Cannot select: Unit is Frozen!", "feedback-error"); playSfx('error'); deselectUnit(false);
                         } else if (clickedUnit.acted && !levelClearedAwaitingInput) {
                             showFeedback("Cannot select: Unit already acted.", "feedback-error"); playSfx('error'); deselectUnit(false);
                         } else {
                              deselectUnit();
                         }
                     } else if (clickedUnit.id === selectedUnit.id) {
                         deselectUnit();
                     } else {
                         playSfx('error');
                         if (levelClearedAwaitingInput && clickedUnit.team === 'enemy') showFeedback("Level cleared, cannot attack.", "feedback-error");
                         else if (clickedUnit.team === 'enemy') {
                             const targetExists = units.find(u => u.id === clickedUnit.id && isUnitAliveAndValid(u));
                             if (targetExists) {
                                 if (getDistance(selectedUnit, targetExists) > selectedUnit.range) showFeedback("Enemy out of range.", "feedback-error");
                                 else if (selectedUnit.range > 1 && !hasLineOfSight(selectedUnit.x, selectedUnit.y, targetExists.x, targetExists.y)) showFeedback("Line of sight blocked.", "feedback-error");
                                 else showFeedback("Invalid target.", "feedback-error");
                             } else showFeedback("Invalid target.", "feedback-error");
                         } else showFeedback("Invalid action.", "feedback-error");
                         deselectUnit(false);
                     }
                 } else {
                     if (clickedUnit.team === 'player' && (!clickedUnit.acted || levelClearedAwaitingInput) && !clickedUnit.isFrozen) {
                         selectUnit(clickedUnit);
                     } else if (clickedUnit.team === 'player' && clickedUnit.acted && !levelClearedAwaitingInput) {
                         showFeedback("Unit already acted.", "feedback-error"); playSfx('error');
                     } else if (clickedUnit.team === 'player' && clickedUnit.isFrozen) {
                         showFeedback("Unit is Frozen!", "feedback-error"); playSfx('error');
                     }
                 }
             }
        }

        function handleMouseLeaveOnBoard(event) {
            if (isProcessing || currentSpell || !gameBoard) return;
            if (currentSpell !== 'flameWave') gameBoard.style.removeProperty('--hover-col');
            if (currentSpell === 'frostNova') clearFrostNovaPreview();
        }
        function handleCellMouseEnter(event) {
            if (isProcessing || !gameBoard) return;
            const cell = event.currentTarget;
            if (cell.classList.contains('has-obstacle')) { clearFrostNovaPreview(); return; }
            if (currentSpell === 'flameWave') gameBoard.style.setProperty('--hover-col', parseInt(cell.dataset.x));
            else if (currentSpell === 'frostNova') { clearFrostNovaPreview(); highlightFrostNovaArea(parseInt(cell.dataset.x), parseInt(cell.dataset.y)); }
        }
        function handleCellMouseLeave(event) { if (currentSpell === 'frostNova' && !isProcessing) clearFrostNovaPreview(); }
        function highlightFrostNovaArea(centerX, centerY) {
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const targetX = centerX + dx; const targetY = centerY + dy;
                    if (isCellInBounds(targetX, targetY) && !getObstacleAt(targetX, targetY)) {
                        const cell = getCellElement(targetX, targetY);
                        if (cell) cell.classList.add('frost-aoe-preview');
                    }
                }
            }
        }
        function clearFrostNovaPreview() { document.querySelectorAll('.grid-cell.frost-aoe-preview').forEach(cell => cell.classList.remove('frost-aoe-preview')); }

        function trackMousePosition(event) {
            currentMouseX = event.clientX;
            currentMouseY = event.clientY;
        }

         function updateTooltip() {
            if (!tooltipElement || isProcessing || !gameBoard || isGameOver() || (startScreen && startScreen.classList.contains('visible'))) {
                hideTooltip();
                return;
            }
            const boardRect = gameBoard.getBoundingClientRect();
            const isMouseOverBoard = currentMouseX >= boardRect.left && currentMouseX <= boardRect.right &&
                                   currentMouseY >= boardRect.top && currentMouseY <= boardRect.bottom;

            let unitToShow = null;
            if (isMouseOverBoard) {
                const elementUnderMouse = document.elementFromPoint(currentMouseX, currentMouseY);
                if (elementUnderMouse) {
                    const unitElement = elementUnderMouse.closest('.unit');
                    if (unitElement && !unitElement.classList.contains('dead')) {
                        const unitId = parseInt(unitElement.dataset.id);
                        unitToShow = units.find(u => u.id === unitId && isUnitAliveAndValid(u));
                    }
                }
            }

            if (unitToShow) {
                if (lastHoveredUnitId !== unitToShow.id) {
                     showTooltip(unitToShow);
                     lastHoveredUnitId = unitToShow.id;
                     if (!selectedUnit) updateUnitInfo(unitToShow);
                } else {
                     positionTooltip();
                }
            } else {
                 if (lastHoveredUnitId !== null) {
                    hideTooltip();
                    lastHoveredUnitId = null;
                    if (!selectedUnit) updateUnitInfo(null);
                 }
            }
        }

        function startTooltipUpdater() {
            if (tooltipUpdateInterval) clearInterval(tooltipUpdateInterval);
            tooltipUpdateInterval = setInterval(updateTooltip, 100);
        }

        function stopTooltipUpdater() {
             if (tooltipUpdateInterval) clearInterval(tooltipUpdateInterval);
             tooltipUpdateInterval = null;
             hideTooltip();
        }

        function showTooltip(unit) {
            if (!tooltipElement || !unit || !isUnitAliveAndValid(unit)) return;
            const unitData = UNIT_DATA[unit.type];
            let tooltipContent = `<b>${unitData ? unitData.name : unit.type}</b>HP: ${unit.hp}/${unit.maxHp}`;
            if (unit.isFrozen) {
                tooltipContent += `<br><span style="color:#aadeff;">‚ùÑÔ∏è Frozen (${unit.frozenTurnsLeft}t)</span>`;
            }
            tooltipElement.innerHTML = tooltipContent;
            tooltipElement.classList.add('visible');
            positionTooltip();
        }

        function hideTooltip() {
            if (tooltipElement) tooltipElement.classList.remove('visible');
            lastHoveredUnitId = null;
        }

        function positionTooltip() {
            if (!tooltipElement || !tooltipElement.classList.contains('visible')) return;
            const tooltipRect = tooltipElement.getBoundingClientRect();
            const containerRect = document.body.getBoundingClientRect();
            const transformStyle = getComputedStyle(tooltipElement).transform;
            let offsetX = 12, offsetY = 18;
            if (transformStyle && transformStyle !== 'none') {
                try { const matrix = new DOMMatrixReadOnly(transformStyle); offsetX = matrix.m41; offsetY = matrix.m42; } catch (e) {}
            }
            let top = currentMouseY + offsetY; let left = currentMouseX + offsetX;
            if (top + tooltipRect.height > containerRect.height - 5) top = currentMouseY - tooltipRect.height - 10;
            if (left + tooltipRect.width > containerRect.width - 5) left = currentMouseX - tooltipRect.width - 10;
            top = Math.max(5, top); left = Math.max(5, left);
            tooltipElement.style.left = `${left}px`;
            tooltipElement.style.top = `${top}px`;
        }

        function selectUnit(unit) {
            if (!unit || (!levelClearedAwaitingInput && unit.acted) || unit.isFrozen || unit.team !== 'player' || currentTurn !== 'player' || isProcessing || !isUnitAliveAndValid(unit)) {
                if (unit?.isFrozen) { showFeedback("Cannot select: Unit is Frozen!", "feedback-error"); playSfx('error'); }
                else if (unit?.acted && !levelClearedAwaitingInput) { showFeedback("Unit already acted.", "feedback-error"); playSfx('error'); }
                return;
            }
            if (currentSpell) setActiveSpell(null);
            if (selectedUnit === unit) return;

            deselectUnit(false);
            selectedUnit = unit;
            if (unit.element) unit.element.classList.add('selected');
            highlightMovesAndAttacks(unit);
            updateUnitInfo(unit);
            playSfx('select');
        }

        function deselectUnit(playSound = true) {
            if (selectedUnit) {
                 if (selectedUnit.element) selectedUnit.element.classList.remove('selected');
                 if (playSound) playSfx('select');
                 updateUnitInfo(null);
                 selectedUnit = null;
                 clearHighlights();
            }
        }


        function finishAction(unit) {
            if (!unit || (unit.acted && !levelClearedAwaitingInput) || !isUnitAliveAndValid(unit) || levelClearedAwaitingInput) return;
            unit.acted = true;
            if (unit.element) {
                unit.element.classList.add('acted');
                unit.element.classList.remove('selected');
            }
            if (selectedUnit?.id === unit.id) {
                selectedUnit = null;
                clearHighlights();
                updateUnitInfo(null);
            }
            updateUnitPosition(unit);
            checkWinLossConditions();
        }

        function moveUnit(unit, targetX, targetY) {
             return new Promise((resolve) => {
                 if (!unit || (!levelClearedAwaitingInput && unit.acted) || unit.isFrozen || !isUnitAliveAndValid(unit) || !unit.element || !isCellInBounds(targetX, targetY) || getObstacleAt(targetX, targetY) || getUnitAt(targetX,targetY)) {
                     resolve(); return;
                 }
                 const startX = unit.x; const startY = unit.y;
                 if (targetX === startX && targetY === startY) { resolve(); return; }

                 unit.element.classList.add('is-moving');
                 playSfx('move');

                 const finalBaseLeft = targetX * currentCellSize;
                 const finalBaseTop = targetY * currentCellSize;
                 const width = parseFloat(getComputedStyle(unit.element).width);
                 const height = parseFloat(getComputedStyle(unit.element).height);
                 const finalOffsetX = (currentCellSize - width) / 2;
                 const finalOffsetY = (currentCellSize - height) / 2;
                 const finalLeft = `${finalBaseLeft + finalOffsetX}px`;
                 const finalTop = `${finalBaseTop + finalOffsetY}px`;

                 unit.element.style.left = finalLeft;
                 unit.element.style.top = finalTop;
                 unit.element.style.transform = 'none';

                 let moveFinalized = false;
                 const finalizeMove = () => {
                     if (moveFinalized || !unit.element) return;
                     moveFinalized = true;
                     unit.element.removeEventListener('transitionend', transitionEndHandler);
                     unit.element.classList.remove('is-moving');

                     unit.x = targetX; unit.y = targetY;
                     unit.element.style.setProperty('--unit-x', targetX + 1);
                     unit.element.style.setProperty('--unit-y', targetY + 1);
                     resolve();
                 };

                 const transitionEndHandler = (event) => {
                     if (event.target === unit.element && (event.propertyName === 'left' || event.propertyName === 'top')) {
                         finalizeMove();
                     }
                 };

                 unit.element.addEventListener('transitionend', transitionEndHandler);
                 setTimeout(() => {
                     if (unit.element && !moveFinalized) finalizeMove();
                     else if (!unit.element) resolve();
                 }, MOVE_ANIMATION_DURATION_MS + 50);
             });
        }

        function checkForGoldPickup(unit, x, y) {
            if (!unit || unit.team !== 'player' || !isUnitAliveAndValid(unit)) return;
            const goldStack = droppedGold.filter(gold => gold.x === x && gold.y === y);
            if (goldStack.length > 0) {
                const totalAmountPickedUp = goldStack.length;
                playerGold += totalAmountPickedUp;
                playSfx('pickup');
                showFeedback(`+${totalAmountPickedUp} Gold!`, 'feedback-gold'); // Show feedback
                updateGoldDisplay();
                goldStack.forEach(goldItem => { if (goldItem.element) goldItem.element.remove(); });
                droppedGold = droppedGold.filter(gold => gold.x !== x || gold.y !== y);
                if (levelClearedAwaitingInput && droppedGold.length === 0) {
                    showFeedback("All gold collected! Press [E] for Next Level.", "feedback-levelup");
                }
            }
        }

        function shootArrow(attacker, defender) {
            if (!gameBoard || !attacker || !defender || !attacker.element || !defender.element) return;
            const projectile = document.createElement('div');
            projectile.classList.add('projectile', 'arrow');
            const boardRect = gameBoard.getBoundingClientRect();
            const startRect = attacker.element.getBoundingClientRect();
            const endRect = defender.element.getBoundingClientRect();
            const startX = startRect.left - boardRect.left + startRect.width / 2;
            const startY = startRect.top - boardRect.top + startRect.height / 2;
            const endX = endRect.left - boardRect.left + endRect.width / 2;
            const endY = endRect.top - boardRect.top + endRect.height / 2;
            const angleRad = Math.atan2(endY - startY, endX - startX);
            const angleDeg = angleRad * (180 / Math.PI);
            projectile.style.left = `${startX}px`; projectile.style.top = `${startY}px`;
            projectile.style.transform = `translate(-50%, -50%) rotate(${angleDeg}deg)`;
             projectile.style.transformOrigin = 'center center';
            gameBoard.appendChild(projectile);
            playSfx('arrowShoot');
            void projectile.offsetWidth;
            projectile.style.left = `${endX}px`; projectile.style.top = `${endY}px`;
            setTimeout(() => projectile.remove(), ARROW_FLY_DURATION_MS);
        }

        function attackUnit(attacker, defender) {
             if (levelClearedAwaitingInput) {
                 playSfx('error'); showFeedback("Level cleared, cannot attack.", "feedback-error");
                 if (currentTurn === 'player') { isProcessing = false; updateTurnDisplay(); }
                 return;
             }
             if (!attacker || !defender || attacker.acted || attacker.isFrozen || !isUnitAliveAndValid(attacker) || !isUnitAliveAndValid(defender)) {
                 if (currentTurn === 'enemy' && attacker && !attacker.acted && !attacker.isFrozen && isUnitAliveAndValid(attacker)) finishAction(attacker);
                 else if (currentTurn === 'player') { isProcessing = false; updateTurnDisplay(); }
                 return;
             }
             const attackerElement = attacker.element; const defenderElement = defender.element;
             if (!attackerElement?.parentNode || !defenderElement?.parentNode) {
                 if (currentTurn === 'enemy' && attacker && !attacker.acted && !attacker.isFrozen && isUnitAliveAndValid(attacker)) finishAction(attacker);
                 else if (currentTurn === 'player') { isProcessing = false; updateTurnDisplay(); }
                 return;
             }

             const originalZIndex = window.getComputedStyle(attackerElement).zIndex || '10';
             const attackZIndex = '25';
             const distance = getDistance(attacker, defender);
             const isRangedAttack = distance > 1;

             if (isRangedAttack) shootArrow(attacker, defender);

             const animDurationString = getComputedStyle(document.documentElement).getPropertyValue('--attack-anim-time').trim().toLowerCase();
             let animDurationMs = 80;
             if (animDurationString.endsWith('ms')) animDurationMs = parseFloat(animDurationString);
             else if (animDurationString.endsWith('s')) animDurationMs = parseFloat(animDurationString) * 1000;

             const strikePause = 50; const returnPause = 60;
             const damage = attacker.atk;
             const isFatal = damage >= defender.hp;
             let defenderDiedVisually = false;

             if (!isRangedAttack && attackerElement) {
                 const deltaX = defender.x - attacker.x; const deltaY = defender.y - attacker.y;
                 const tapDistanceFactor = 0.2 * currentCellSize;
                 const translateX = deltaX * tapDistanceFactor; const translateY = deltaY * tapDistanceFactor;
                 const transformValue = `translate(${translateX}px, ${translateY}px)`;

                 attackerElement.style.zIndex = attackZIndex;
                 attackerElement.style.transition = `transform ${animDurationMs}ms ease-out`;
                 attackerElement.style.transform = transformValue;
                 playSfx('move');

                 setTimeout(() => {
                     if (attackerElement?.parentNode) {
                          attackerElement.style.transform = 'none';
                          setTimeout(() => { if(attackerElement) attackerElement.style.zIndex = originalZIndex; }, returnPause);
                     }
                 }, animDurationMs + strikePause);
             }

             const impactDelay = isRangedAttack ? Math.max(ARROW_FLY_DURATION_MS, animDurationMs + strikePause) : animDurationMs + strikePause;

             setTimeout(() => {
                 const stillAttacker = units.find(u => u.id === attacker.id);
                 const stillDefender = units.find(u => u.id === defender.id);
                 const originalDefenderData = { x: defender.x, y: defender.y, team: defender.team, id: defender.id, type: defender.type };

                 if (stillDefender && isUnitAliveAndValid(stillDefender)) {
                     playSfx('hit');
                     stillDefender.hp -= damage; if (stillDefender.hp < 0) stillDefender.hp = 0;
                     showDamagePopup(stillDefender.x, stillDefender.y, damage);
                     if (defenderElement?.parentNode) {
                         defenderElement.classList.add('unit-hit-flash');
                         setTimeout(() => { if (defenderElement) defenderElement.classList.remove('unit-hit-flash'); }, 200);
                     }
                      updateUnitInfo(selectedUnit === stillDefender ? stillDefender : (lastHoveredUnitId === stillDefender.id ? stillDefender : null));
                      if (tooltipElement.classList.contains('visible') && lastHoveredUnitId === stillDefender.id) showTooltip(stillDefender);

                     let wasKnockedBack = false;
                     if (attacker.knockback && stillDefender.hp > 0) {
                         const kbDirX = Math.sign(stillDefender.x - attacker.x); const kbDirY = Math.sign(stillDefender.y - attacker.y);
                         const kbX = stillDefender.x + kbDirX; const kbY = stillDefender.y + kbDirY;
                         if (isCellInBounds(kbX, kbY) && !getUnitAt(kbX, kbY) && !getObstacleAt(kbX, kbY)) {
                             moveUnit(stillDefender, kbX, kbY).then(() => {
                                if (stillDefender.team === 'player') checkForGoldPickup(stillDefender, stillDefender.x, stillDefender.y);
                             });
                              wasKnockedBack = true;
                         }
                     }

                     if (stillDefender.hp <= 0) {
                          defenderDiedVisually = true;
                          playSfx(defender.team === 'player' ? 'playerDie' : 'defeat');
                          removeUnit(stillDefender, originalDefenderData.x, originalDefenderData.y);
                     }

                 } else if (stillDefender && stillDefender.hp <= 0) {
                      defenderDiedVisually = true;
                      removeUnit(stillDefender, originalDefenderData.x, originalDefenderData.y);
                 }

                 if (stillAttacker && isUnitAliveAndValid(stillAttacker) && !stillAttacker.acted) {
                     finishAction(stillAttacker);
                 }

                 if (currentTurn === 'player') { isProcessing = false; updateTurnDisplay(); }

             }, impactDelay);
        }


        function castFireball(targetUnit) {
            if (levelClearedAwaitingInput || !isUnitAliveAndValid(targetUnit)) return;
            const normallyUnlocked = currentLevel >= FIREBALL_UNLOCK_LEVEL;
            const isEffectivelyUnlocked = normallyUnlocked || unlimitedSpellsCheat;
            const isAvailable = spellUses.fireball || unlimitedSpellsCheat;
            if (!isAvailable || !isEffectivelyUnlocked || targetUnit.team !== 'enemy' || isProcessing || !gameBoard) return;

            isProcessing = true; updateTurnDisplay(); setActiveSpell(null);
            if (!unlimitedSpellsCheat) spellUses.fireball = false;
            updateSpellUI();
            const targetUnitId = targetUnit.id; const originalCoords = { x: targetUnit.x, y: targetUnit.y };
            const projectileEl = document.createElement('div'); projectileEl.classList.add('projectile', 'fireball-projectile');
            const projectileWidth = 72; const projectileHeight = 72;
            const spellIconRect = fireballElement.getBoundingClientRect(); const boardRect = gameBoard.getBoundingClientRect();
            const startX = spellIconRect.left - boardRect.left + spellIconRect.width / 2;
            const startY = spellIconRect.top - boardRect.top + spellIconRect.height / 2;
            const endX = (originalCoords.x + 0.5) * currentCellSize;
            const endY = (originalCoords.y + 0.5) * currentCellSize;

            const angleRad = Math.atan2(endY - startY, endX - startX); const angleDeg = angleRad * (180 / Math.PI);
            projectileEl.style.transform = `translate(-50%, -50%) rotate(${angleDeg}deg)`;
             projectileEl.style.transformOrigin = 'center center';
            projectileEl.style.left = `${startX}px`; projectileEl.style.top = `${startY}px`;
            gameBoard.appendChild(projectileEl); playSfx('fireballShoot');
            void projectileEl.offsetWidth;
            projectileEl.style.left = `${endX}px`; projectileEl.style.top = `${endY}px`;

            setTimeout(() => {
                projectileEl.remove(); playSfx('fireballHit');
                const stillTarget = units.find(u => u.id === targetUnitId);
                if (isUnitAliveAndValid(stillTarget) && stillTarget.x === originalCoords.x && stillTarget.y === originalCoords.y) {
                    stillTarget.hp -= FIREBALL_DAMAGE; if (stillTarget.hp < 0) stillTarget.hp = 0;
                    showDamagePopup(stillTarget.x, stillTarget.y, FIREBALL_DAMAGE);
                    if (stillTarget.element) { stillTarget.element.classList.add('unit-hit-flash'); setTimeout(() => { if (stillTarget.element) stillTarget.element.classList.remove('unit-hit-flash'); }, 200); }
                     updateUnitInfo(selectedUnit === stillTarget ? stillTarget : (lastHoveredUnitId === stillTarget.id ? stillTarget : null));
                     if (tooltipElement.classList.contains('visible') && lastHoveredUnitId === stillTarget.id) showTooltip(stillTarget);
                    if (stillTarget.hp <= 0) removeUnit(stillTarget, originalCoords.x, originalCoords.y);
                }
                const explosionEl = document.createElement('div'); explosionEl.classList.add('fireball-explosion');
                const explosionBaseWidth = 120; const explosionBaseHeight = 120;
                explosionEl.style.left = `${endX - explosionBaseWidth / 2}px`;
                explosionEl.style.top = `${endY - explosionBaseHeight / 2}px`;
                gameBoard.appendChild(explosionEl); setTimeout(() => explosionEl.remove(), FIREBALL_EXPLOSION_DURATION_MS);
                isProcessing = false; checkWinLossConditions(); updateTurnDisplay();
            }, FIREBALL_PROJECTILE_DURATION_MS);
        }

        function castFlameWave(targetRow) {
             if (levelClearedAwaitingInput || !gameBoard) return;
             const normallyUnlocked = currentLevel >= FLAME_WAVE_UNLOCK_LEVEL;
             const isEffectivelyUnlocked = normallyUnlocked || unlimitedSpellsCheat;
             const isAvailable = spellUses.flameWave || unlimitedSpellsCheat;
             if (!isAvailable || !isEffectivelyUnlocked || isProcessing || targetRow < 0 || targetRow >= GRID_ROWS) return;

             isProcessing = true; updateTurnDisplay(); setActiveSpell(null);
             if (!unlimitedSpellsCheat) spellUses.flameWave = false;
             updateSpellUI();
             let processedUnitsInRow = new Set();
             try { const delayStr = getComputedStyle(document.documentElement).getPropertyValue('--flame-wave-stagger-delay').trim(); if (delayStr.endsWith('ms')) FLAME_WAVE_STAGGER_DELAY_MS = parseFloat(delayStr); else if (delayStr.endsWith('s')) FLAME_WAVE_STAGGER_DELAY_MS = parseFloat(delayStr) * 1000; } catch (e) {}
             let cellsProcessed = 0; const totalCells = GRID_COLS; const boardRect = gameBoard.getBoundingClientRect();
             let soundPlayed = false;

             for (let x = 0; x < GRID_COLS; x++) {
                 const currentDelay = x * FLAME_WAVE_STAGGER_DELAY_MS;
                 setTimeout(() => {
                     if (!isCellInBounds(x, targetRow) || getObstacleAt(x, targetRow)) {
                          cellsProcessed++; if (cellsProcessed === totalCells) { isProcessing = false; checkWinLossConditions(); updateTurnDisplay(); }
                          return;
                     }
                     const cellCenterX = (x + 0.5) * currentCellSize;
                     const cellCenterY = (targetRow + 0.5) * currentCellSize;

                     const explosionEl = document.createElement('div'); explosionEl.classList.add('fireball-explosion');
                     const explosionBaseWidth = 120; const explosionBaseHeight = 120;
                     explosionEl.style.left = `${cellCenterX - explosionBaseWidth / 2}px`; explosionEl.style.top = `${cellCenterY - explosionBaseHeight / 2}px`;
                     gameBoard.appendChild(explosionEl); setTimeout(() => explosionEl.remove(), FIREBALL_EXPLOSION_DURATION_MS);

                     if (!soundPlayed) { playSfx('fireballHit'); soundPlayed = true; }

                     const unit = getUnitAt(x, targetRow);
                     if (unit && isUnitAliveAndValid(unit) && !processedUnitsInRow.has(unit.id)) {
                         processedUnitsInRow.add(unit.id); unit.hp -= FLAME_WAVE_DAMAGE; if (unit.hp < 0) unit.hp = 0;
                         showDamagePopup(unit.x, unit.y, FLAME_WAVE_DAMAGE);
                         if (unit.element) { unit.element.classList.add('unit-hit-flash'); setTimeout(() => { if (unit.element) unit.element.classList.remove('unit-hit-flash'); }, 200); }
                          updateUnitInfo(selectedUnit === unit ? unit : (lastHoveredUnitId === unit.id ? unit : null));
                          if (tooltipElement.classList.contains('visible') && lastHoveredUnitId === unit.id) showTooltip(unit);
                         if (unit.hp <= 0) removeUnit(unit, x, targetRow);
                     }
                     cellsProcessed++; if (cellsProcessed === totalCells) { isProcessing = false; checkWinLossConditions(); updateTurnDisplay(); }
                 }, currentDelay);
             }
        }

        function castFrostNova(centerX, centerY) {
            if (levelClearedAwaitingInput) { showFeedback("Level cleared, cannot cast spells.", "feedback-error"); playSfx('error'); setActiveSpell(null); return; }
            const normallyUnlocked = currentLevel >= FROST_NOVA_UNLOCK_LEVEL;
            const isEffectivelyUnlocked = normallyUnlocked || unlimitedSpellsCheat;
            const isAvailable = spellUses.frostNova || unlimitedSpellsCheat;
            if (!isAvailable || !isEffectivelyUnlocked || isProcessing || !isCellInBounds(centerX, centerY) || getObstacleAt(centerX, centerY)) {
                if (!isEffectivelyUnlocked) showFeedback(`Unlock at Level ${FROST_NOVA_UNLOCK_LEVEL}!`, "feedback-error");
                else if (!isAvailable) showFeedback("Frost Nova already used.", "feedback-error");
                else if (getObstacleAt(centerX, centerY)) showFeedback("Cannot cast on obstacle.", "feedback-error");
                else showFeedback("Invalid Frost Nova target/state.", "feedback-error");
                playSfx('error'); setActiveSpell(null); return;
            }
            isProcessing = true; updateTurnDisplay(); setActiveSpell(null);
            if (!unlimitedSpellsCheat) spellUses.frostNova = false;
            updateSpellUI(); playSfx('frostNovaCast');
            setTimeout(() => {
                let unitsFrozenCount = 0; let newlyFrozen = false;
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const targetX = centerX + dx; const targetY = centerY + dy;
                         if (isCellInBounds(targetX, targetY) && !getObstacleAt(targetX, targetY)) {
                            const unit = getUnitAt(targetX, targetY);
                             if (unit?.team === 'enemy' && isUnitAliveAndValid(unit)) {
                                if (!unit.isFrozen) newlyFrozen = true;
                                unit.isFrozen = true; unit.frozenTurnsLeft = FROST_NOVA_DURATION;
                                showFreezePopup(unit.x, unit.y); updateUnitPosition(unit);
                                 updateUnitInfo(selectedUnit === unit ? unit : (lastHoveredUnitId === unit.id ? unit : null));
                                 if (tooltipElement.classList.contains('visible') && lastHoveredUnitId === unit.id) showTooltip(unit);
                                unitsFrozenCount++;
                            }
                        }
                    }
                }
                 if (unitsFrozenCount > 0 && newlyFrozen) playSfx('frostNovaHit');
                 else if (unitsFrozenCount === 0) { playSfx('error'); showFeedback("No enemies hit.", "feedback-error"); }
                 else { playSfx('frostNovaHit'); }

                isProcessing = false; checkWinLossConditions(); updateTurnDisplay();
            }, 200);
        }

        function castHeal(targetUnit) {
            if (levelClearedAwaitingInput) { showFeedback("Level cleared, cannot cast spells.", "feedback-error"); playSfx('error'); setActiveSpell(null); return; }
            const normallyUnlocked = currentLevel >= HEAL_UNLOCK_LEVEL;
            const isEffectivelyUnlocked = normallyUnlocked || unlimitedSpellsCheat;
            const isAvailable = spellUses.heal || unlimitedSpellsCheat;
            if (!isAvailable || !isEffectivelyUnlocked || !targetUnit || !isUnitAliveAndValid(targetUnit) || targetUnit.team !== 'player' || isProcessing) {
                if (!isEffectivelyUnlocked) showFeedback(`Unlock at Level ${HEAL_UNLOCK_LEVEL}!`, "feedback-error");
                else if (!isAvailable) showFeedback("Heal already used.", "feedback-error");
                else showFeedback("Invalid Heal target/state.", "feedback-error");
                playSfx('error'); setActiveSpell(null); return;
            }
            if (targetUnit.hp >= targetUnit.maxHp) { showFeedback("Unit at full HP.", "feedback-error"); playSfx('error'); setActiveSpell(null); return; }
            isProcessing = true; updateTurnDisplay(); setActiveSpell(null);
            if (!unlimitedSpellsCheat) spellUses.heal = false;
            updateSpellUI(); playSfx('heal');
            const healApplied = Math.min(HEAL_AMOUNT, targetUnit.maxHp - targetUnit.hp);
            targetUnit.hp += healApplied; showHealPopup(targetUnit.x, targetUnit.y, healApplied);
            if (targetUnit.element) { targetUnit.element.classList.add('unit-hit-flash'); setTimeout(() => { if (targetUnit.element) targetUnit.element.classList.remove('unit-hit-flash'); }, 200); }
             updateUnitInfo(selectedUnit === targetUnit ? targetUnit : (lastHoveredUnitId === targetUnit.id ? targetUnit : null));
             if (tooltipElement.classList.contains('visible') && lastHoveredUnitId === targetUnit.id) showTooltip(targetUnit);
            isProcessing = false; updateTurnDisplay(); checkWinLossConditions();
        }

        function removeUnit(unit, originalX = null, originalY = null) {
             if (!unit) return;
             const unitIndex = units.findIndex(u => u.id === unit.id);
             const unitElement = unit.element;
             const deathX = originalX !== null ? originalX : unit.x;
             const deathY = originalY !== null ? originalY : unit.y;
             const unitTeam = unit.team; const unitType = unit.type;

             if (unitTeam === 'enemy' && Math.random() < GOLD_DROP_CHANCE && gameBoard) {
                 let goldAmountToDrop = BASE_GOLD_DROP_AMOUNT;
                 if (ADVANCED_GOBLIN_TYPES.includes(unitType) && Math.random() < ADVANCED_GOBLIN_EXTRA_GOLD_CHANCE) goldAmountToDrop += ADVANCED_GOBLIN_EXTRA_GOLD_AMOUNT;
                 if (isCellInBounds(deathX, deathY) && !getObstacleAt(deathX, deathY)) {
                     playSfx('goldDrop');
                     const currentStackSize = droppedGold.filter(g => g.x === deathX && g.y === deathY).length;
                     const fragment = document.createDocumentFragment();
                     for (let i = 0; i < goldAmountToDrop; i++) {
                         const stackIndex = currentStackSize + i;
                         const goldEl = document.createElement('div');
                         goldEl.classList.add('item', 'gold-coin');
                         goldEl.dataset.x = deathX; goldEl.dataset.y = deathY;
                         updateItemPosition(goldEl, deathX, deathY, stackIndex);
                         fragment.appendChild(goldEl);
                         droppedGold.push({ x: deathX, y: deathY, element: goldEl, stackIndex: stackIndex });
                     }
                     gameBoard.appendChild(fragment);
                 }
             }

             unit.hp = 0;

             if (unitElement?.parentNode) {
                  if (!unitElement.classList.contains('dead')) {
                      const deathSpriteUrl = UNIT_DATA[unitType]?.deadSpriteUrl;
                      if (deathSpriteUrl) unitElement.style.backgroundImage = `url('${deathSpriteUrl}')`;
                      unitElement.classList.add('dead');
                      unitElement.classList.remove('selected', 'acted', 'unit-hit-flash', 'player', 'enemy', 'valid-attack', 'valid-move', 'frozen', 'is-moving');
                      unitElement.style.filter = 'none'; unitElement.style.boxShadow = 'none';
                      unitElement.style.transform = 'none'; unitElement.style.pointerEvents = 'none';
                      unitElement.style.opacity = '1';
                      updateUnitVisualPositionOnly(unitElement, deathX, deathY);
                  }

                 const deathDisplayTime = 1500;
                 const fadeDurationString = getComputedStyle(document.documentElement).getPropertyValue('--death-fade-time').trim().toLowerCase();
                 let fadeDuration = 1000;
                 if (fadeDurationString.endsWith('ms')) fadeDuration = parseFloat(fadeDurationString);
                 else if (fadeDurationString.endsWith('s')) fadeDuration = parseFloat(fadeDurationString) * 1000;
                 fadeDuration = Math.max(fadeDuration, 100);

                 setTimeout(() => {
                     if (unitElement?.parentNode && unitElement.classList.contains('dead') && !unitElement.classList.contains('fading-out')) {
                         unitElement.classList.add('fading-out');
                         setTimeout(() => {
                              if (unitElement) unitElement.remove();
                               const finalUnitIndex = units.findIndex(u => u.id === unit.id);
                               if (finalUnitIndex !== -1) units.splice(finalUnitIndex, 1);
                         }, fadeDuration);
                     } else {
                          const finalUnitIndex = units.findIndex(u => u.id === unit.id);
                          if (finalUnitIndex !== -1) units.splice(finalUnitIndex, 1);
                     }
                 }, deathDisplayTime);
             } else {
                  const finalUnitIndex = units.findIndex(u => u.id === unit.id);
                  if (finalUnitIndex !== -1) units.splice(finalUnitIndex, 1);
             }

             if (selectedUnit?.id === unit.id) deselectUnit(false);
             if (lastHoveredUnitId === unit.id) hideTooltip();
             updateUnitInfo(selectedUnit);

        }

        function getUnitAt(x, y) { return units.find(unit => unit.x === x && unit.y === y && isUnitAliveAndValid(unit)); }
        function getCellElement(x, y) { if (!isCellInBounds(x, y) || !gameBoard) return null; return gameBoard.querySelector(`.grid-cell[data-x='${x}'][data-y='${y}']`); }
        function getDistance(unitA, unitB) { if (!unitA || !unitB) return Infinity; return Math.abs(unitA.x - unitB.x) + Math.abs(unitA.y - unitB.y); }

        function getValidMoves(unit) {
            if (!unit || (!levelClearedAwaitingInput && unit.acted) || unit.isFrozen || !isUnitAliveAndValid(unit)) return [];
            const moves = []; const queue = [{ x: unit.x, y: unit.y, distance: 0 }]; const visited = new Set([`${unit.x},${unit.y}`]);
            while (queue.length > 0) {
                const current = queue.shift();
                const neighbors = [{ x: current.x, y: current.y - 1 }, { x: current.x, y: current.y + 1 }, { x: current.x - 1, y: current.y }, { x: current.x + 1, y: current.y }];
                for (const neighbor of neighbors) {
                    const key = `${neighbor.x},${neighbor.y}`;
                    if (!isCellInBounds(neighbor.x, neighbor.y) || visited.has(key)) continue;
                    const newDistance = current.distance + 1; if (newDistance > unit.mov) continue;
                    const unitAtNeighbor = getUnitAt(neighbor.x, neighbor.y);
                    const obstacleData = getObstacleAt(neighbor.x, neighbor.y);
                    if (unitAtNeighbor || (obstacleData?.blocksMove)) continue;
                    moves.push({ x: neighbor.x, y: neighbor.y }); visited.add(key);
                    queue.push({ x: neighbor.x, y: neighbor.y, distance: newDistance });
                }
            }
            return moves;
        }

        function hasLineOfSight(startX, startY, endX, endY) {
             let x = startX; let y = startY;
             const dx = Math.abs(endX - startX); const dy = -Math.abs(endY - startY);
             const sx = startX < endX ? 1 : -1; const sy = startY < endY ? 1 : -1;
             let err = dx + dy;
             while (true) {
                 let nextX = x; let nextY = y;
                 let e2 = 2 * err;
                 let moved = false;
                 if (e2 >= dy) { if (x === endX) break; nextX += sx; err += dy; moved = true; }
                 if (e2 <= dx) { if (y === endY) break; nextY += sy; err += dx; moved = true; }

                 if (!moved) break;

                 if (nextX === endX && nextY === endY) break;

                 const unitInCell = getUnitAt(nextX, nextY);
                 const obstacleData = getObstacleAt(nextX, nextY);
                 if (unitInCell || (obstacleData?.blocksLOS)) {
                     return false;
                 }

                 x = nextX; y = nextY;

                 if (Math.abs(x - startX) > GRID_COLS || Math.abs(y - startY) > GRID_ROWS) break;
             }
             return true;
        }


        function getValidAttacks(unit) {
            const attacks = [];
            if (!unit || (!levelClearedAwaitingInput && unit.acted) || unit.isFrozen || !isUnitAliveAndValid(unit) || levelClearedAwaitingInput) return attacks;
            const unitRange = unit.range || 1;
            units.forEach(target => {
                if (target.team !== unit.team && isUnitAliveAndValid(target)) {
                    const distance = getDistance(unit, target);
                    if (distance <= unitRange) {
                        if (unitRange === 1 || hasLineOfSight(unit.x, unit.y, target.x, target.y)) attacks.push(target.id);
                    }
                }
            });
            return attacks;
        }

        function processFreezeTicks(team) {
            let thawedCount = 0;
            units.filter(u => u.team === team && u.isFrozen && isUnitAliveAndValid(u)).forEach(unit => {
                unit.frozenTurnsLeft--;
                if (unit.frozenTurnsLeft <= 0) {
                    unit.isFrozen = false; thawedCount++;
                    if (unit.element) updateUnitPosition(unit);
                }
                 if (selectedUnit?.id === unit.id) updateUnitInfo(unit);
                 else if (!selectedUnit && lastHoveredUnitId === unit.id) updateUnitInfo(unit);
                 if (tooltipElement.classList.contains('visible') && lastHoveredUnitId === unit.id) showTooltip(unit);
            });
            return thawedCount;
        }

        function endTurn() {
            if (levelClearedAwaitingInput) {
                playSfx('success'); startNextLevel(); return;
            }
            if (currentTurn !== 'player' || isProcessing || isGameOver()) return;
            if (!initializeAudio()) return;
            playSfx('select'); isProcessing = true; updateTurnDisplay();
            deselectUnit(false); setActiveSpell(null); updateUnitInfo(null);
            lastHoveredUnitId = null; showFeedback(''); hideTooltip();
            currentTurn = 'enemy'; processFreezeTicks('enemy');
            units.filter(u => u.team === 'enemy' && isUnitAliveAndValid(u)).forEach(u => {
                u.acted = false; if (u.element) updateUnitPosition(u);
            });
            updateTurnDisplay(); setTimeout(runAITurn, 400);
        }

        function runAITurn() {
             const unitsToAct = units.filter(u => u.team === 'enemy' && isUnitAliveAndValid(u) && !u.acted && !u.isFrozen);
             let currentAIUnitIndex = 0; const totalActions = unitsToAct.length;
             const actionInterval = 150;
             const minActionDuration = Math.max(MOVE_ANIMATION_DURATION_MS, ARROW_FLY_DURATION_MS) + 150;

             async function processNextAIUnit() {
                 if (isGameOver()) { endAITurnSequence(true); return; }
                 if (currentAIUnitIndex >= totalActions) { endAITurnSequence(false); return; }

                 const unitToProcess = unitsToAct[currentAIUnitIndex];
                 currentAIUnitIndex++;

                 const stillValidUnit = units.find(u => u.id === unitToProcess.id && isUnitAliveAndValid(u) && !u.acted && !u.isFrozen);

                 if (stillValidUnit) {
                     const actionStartTime = Date.now();
                     try {
                         if (currentTurnDisplay) updateTurnDisplay();
                         await performAIAction(stillValidUnit);
                     } catch (e) {
                          if (stillValidUnit && isUnitAliveAndValid(stillValidUnit) && !stillValidUnit.acted) finishAction(stillValidUnit);
                     } finally {
                         const actionEndTime = Date.now();
                         const duration = actionEndTime - actionStartTime;
                         const delayNeeded = Math.max(actionInterval, minActionDuration - duration);
                         setTimeout(processNextAIUnit, delayNeeded);
                     }
                 } else {
                     setTimeout(processNextAIUnit, 50);
                 }
             }

             function endAITurnSequence(interrupted) {
                 if (!isGameOver()) {
                     currentTurn = 'player';
                     processFreezeTicks('player');
                      // Reset player acted state AND refresh all unit visuals
                      units.forEach(u => {
                          if (u.team === 'player' && isUnitAliveAndValid(u)) {
                              u.acted = false;
                          }
                          // Refresh visuals for *all* units to remove enemy 'acted' filters etc.
                          if (isUnitAliveAndValid(u) && u.element) {
                              updateUnitPosition(u);
                          }
                      });

                     showFeedback("Player Turn!");
                     isProcessing = false;
                     if (currentTurnDisplay) updateTurnDisplay();
                 } else {
                     if (endTurnButton) { endTurnButton.disabled = true; endTurnButton.classList.add('disabled'); }
                     isProcessing = true;
                     if (currentTurnDisplay) updateTurnDisplay();
                 }
             }

             if (totalActions === 0) endAITurnSequence(false);
             else setTimeout(processNextAIUnit, 100);
        }


        async function performAIAction(unit) {
             if (!unit || !isUnitAliveAndValid(unit)) return;
             if (unit.isFrozen) { if (!unit.acted) finishAction(unit); return; }

             const livingPlayers = units.filter(u => u.team === 'player' && isUnitAliveAndValid(u));
             if (livingPlayers.length === 0) { if (!unit.acted) finishAction(unit); return; }

             const unitRange = unit.range || 1;
             const possibleAttacks = getValidAttacks(unit);

             if (possibleAttacks.length > 0) {
                 let targetToAttack = null;
                 let bestTargetScore = -Infinity;

                 possibleAttacks.forEach(id => {
                     const target = units.find(u => u.id === id);
                     if (target && isUnitAliveAndValid(target)) {
                          let score = 1000 - target.hp;
                          const isCurrentTargetRanged = getDistance(unit, target) > 1;

                          if (unitRange > 1) {
                               if (isCurrentTargetRanged) score += 500;
                          } else {
                                if (!isCurrentTargetRanged) score += 500;
                          }

                          if (score > bestTargetScore) {
                              bestTargetScore = score;
                              targetToAttack = target;
                          }
                     }
                 });

                 if (targetToAttack) {
                     attackUnit(unit, targetToAttack);
                     return;
                 }
             }

             let nearestPlayer = null; let minDistance = Infinity;
             livingPlayers.forEach(p => { if (isUnitAliveAndValid(p)) { const d = getDistance(unit, p); if (d < minDistance) { minDistance = d; nearestPlayer = p; } } });

             if (nearestPlayer) {
                 const possibleMoves = getValidMoves(unit);
                 if (possibleMoves.length > 0) {
                     let bestMove = null;
                     let bestMoveScore = -Infinity;

                     possibleMoves.forEach(moveOption => {
                         if (!nearestPlayer || !isUnitAliveAndValid(nearestPlayer)) return;
                         const distAfterMove = Math.abs(moveOption.x - nearestPlayer.x) + Math.abs(moveOption.y - nearestPlayer.y);
                          let moveScore = 1000 - distAfterMove;

                         if (unitRange > 1) {
                              const optimalDist = unit.range;
                              if (distAfterMove <= optimalDist && distAfterMove > 0) {
                                   moveScore += 500 - Math.abs(distAfterMove - optimalDist) * 10;
                              }
                         } else {
                              if (distAfterMove === 1) moveScore += 500;
                         }

                          if (distAfterMove <= unitRange && unitRange > 1) {
                               if (hasLineOfSight(moveOption.x, moveOption.y, nearestPlayer.x, nearestPlayer.y)) {
                                    moveScore += 200;
                               }
                          } else if (distAfterMove <= unitRange && unitRange === 1) {
                               moveScore += 200;
                          }


                         if (moveScore > bestMoveScore) {
                             bestMoveScore = moveScore;
                             bestMove = moveOption;
                         }
                     });

                     const currentPosScore = 1000 - minDistance;
                      if (unitRange > 1 && minDistance <= unit.range && minDistance > 0 && hasLineOfSight(unit.x, unit.y, nearestPlayer.x, nearestPlayer.y)) currentPosScore += 700;
                      else if (unitRange === 1 && minDistance === 1) currentPosScore += 700;

                     if (bestMove && bestMoveScore > currentPosScore) {
                         if (bestMove.x !== unit.x || bestMove.y !== unit.y) {
                             await moveUnit(unit, bestMove.x, bestMove.y);
                             finishAction(unit);
                             return;
                         }
                     }
                 }
             }

             const unitAfterNoAction = units.find(u => u.id === unit.id);
             if (unitAfterNoAction && !unitAfterNoAction.acted && isUnitAliveAndValid(unitAfterNoAction)) {
                 finishAction(unitAfterNoAction);
             }
        }


        function checkWinLossConditions() {
            if (winCheckTimeout) clearTimeout(winCheckTimeout);
            winCheckTimeout = setTimeout(() => {
                if (isGameOver() || levelClearedAwaitingInput) { winCheckTimeout = null; return; }
                const playersLeft = units.some(u => u.team === 'player' && isUnitAliveAndValid(u));
                const enemiesLeft = units.some(u => u.team === 'enemy' && isUnitAliveAndValid(u));
                if (!enemiesLeft && playersLeft) {
                    playSfx('success'); deselectUnit(false); setActiveSpell(null); hideTooltip(); lastHoveredUnitId = null;
                    if (droppedGold.length > 0) {
                        levelClearedAwaitingInput = true; isProcessing = false;
                        showFeedback(`Level Cleared! Collect Gold!`, 'feedback-levelup');
                        updateTurnDisplay();
                    } else {
                        isProcessing = true;
                        showFeedback(`Level ${currentLevel} Cleared!`, 'feedback-levelup');
                        updateTurnDisplay();
                        setTimeout(startNextLevel, 1800);
                    }
                } else if (!playersLeft) {
                     gameOver(false);
                }
                winCheckTimeout = null;
            }, 100);
        }

        function startNextLevel() {
            if (isGameOver()) return;
            currentLevel++;
            isProcessing = true;
            stopMusic();
            selectAndLoadMusic();
            resetLevelState();
            resetSpellStateForNewLevel();
            initializeGridState();
            updateLevelDisplay(); updateGoldDisplay(); updateUnitInfo(null); lastHoveredUnitId = null;
            if (endTurnButton) { endTurnButton.disabled = true; endTurnButton.classList.add('disabled'); }
            showFeedback(`Level ${currentLevel} Start!`, 'feedback-levelup');

            requestAnimationFrame(() => {
                try {
                    calculateCellSize(); spawnObstacles(); spawnInitialUnits();
                    units.forEach(u => { if (u.team === 'player') { u.acted = false; u.isFrozen = false; u.frozenTurnsLeft = 0; } });
                    renderAllUnits(); applyLayout();
                    updateTurnDisplay(); startMusicIfNotPlaying();
                } catch (e) {}
                finally {
                    isProcessing = false;
                    updateTurnDisplay();
                }
            });
        }

        function isGameOver() { return gameOverScreen && gameOverScreen.classList.contains('visible'); }
        function isMenuOpen() { return menuOverlay && menuOverlay.classList.contains('visible'); }
        function isLeaderboardOpen() { return leaderboardOverlay && leaderboardOverlay.classList.contains('visible'); }

        function gameOver(playerWon) {
            if (isGameOver()) return;
            levelClearedAwaitingInput = false; isProcessing = true; stopMusic(); hideTooltip(); stopTooltipUpdater();
            document.removeEventListener('mousemove', trackMousePosition);

            let messageText = "";
            if (!playerWon) {
                playSfx('gameOver');
                levelToRestartOnLoss = currentLevel;
                const goldBeforePenalty = playerGold;
                playerGold = Math.max(0, playerGold - GOLD_PENALTY_ON_DEATH);
                updateGoldDisplay();
                messageText = `You have fallen on Level ${currentLevel}! Gold: ${goldBeforePenalty} - ${GOLD_PENALTY_ON_DEATH} Penalty = ${playerGold}`;
                if (restartButton) restartButton.textContent = "Restart Level";
            } else {
                playSfx('success');
                levelToRestartOnLoss = 1;
                 messageText = `You are victorious! Final Level: ${currentLevel}, Final Gold: ${playerGold}`;
                if (restartButton) restartButton.textContent = "Play Again?";
            }

            deselectUnit(false); updateUnitInfo(null); lastHoveredUnitId = null; setActiveSpell(null);
            if (endTurnButton) { endTurnButton.disabled = true; endTurnButton.classList.add('disabled'); }
            if (gameOverTitle) gameOverTitle.textContent = playerWon ? "Victory!" : "Defeat!";
            if (gameOverMessage) gameOverMessage.textContent = messageText;
            if (gameOverScreen) gameOverScreen.classList.add('visible');
            if (menuOverlay) menuOverlay.classList.remove('visible');
            if (leaderboardOverlay) leaderboardOverlay.classList.remove('visible');

            window.removeEventListener('resize', handleResize);
            document.removeEventListener('fullscreenchange', updateFullscreenButton);
            document.removeEventListener('webkitfullscreenchange', updateFullscreenButton);
            document.removeEventListener('mozfullscreenchange', updateFullscreenButton);
            document.removeEventListener('MSFullscreenChange', updateFullscreenButton);
            if (winCheckTimeout) clearTimeout(winCheckTimeout); winCheckTimeout = null;
            if (resizeTimeout) clearTimeout(resizeTimeout); resizeTimeout = null;
        }


        function toggleMute() {
            if (!initializeAudio()) return;
            isMuted = !isMuted; bgMusic.muted = isMuted;
            Object.values(sfx).forEach(s => s.muted = isMuted);
            updateMuteButtonVisual();
            if (!isMuted && audioInitialized && startScreen && !startScreen.classList.contains('visible') && !isGameOver()) startMusicIfNotPlaying();
            else if (isMuted) stopMusic();
        }

        function updateMuteButtonVisual() {
            if (muteButton) {
                muteButton.innerHTML = isMuted ? 'üîá Unmute' : 'üîä Mute Sound';
                muteButton.title = isMuted ? 'Unmute (M)' : 'Mute Sound (M)';
            }
        }

         function showMenu() {
             if (!initializeAudio()) return;
             if (isMenuOpen()) return;
             playSfx('menuOpen');
             updateGoldDisplay(); // Ensure gold is current when opening
             if(menuOverlay) menuOverlay.classList.add('visible');
             if(leaderboardOverlay) leaderboardOverlay.classList.remove('visible'); // Close others
             hideTooltip(); // Hide tooltip when menu opens
         }
         function hideMenu() {
             if (!isMenuOpen()) return;
             playSfx('menuClose');
             if(menuOverlay) menuOverlay.classList.remove('visible');
         }

         function showLeaderboard() {
             if (!initializeAudio()) return;
             playSfx('select');
             if(leaderboardOverlay) leaderboardOverlay.classList.add('visible');
             if(menuOverlay) menuOverlay.classList.remove('visible'); // Close menu if opening leaderboard from it
         }
         function hideLeaderboard() {
             playSfx('select');
             if(leaderboardOverlay) leaderboardOverlay.classList.remove('visible');
         }

        document.addEventListener('DOMContentLoaded', () => {
            gameContainer = document.getElementById('game-container');
            gameBoard = document.getElementById('game-board');
            uiPanel = document.getElementById('ui-panel');
            levelDisplayElement = document.getElementById('level-display');
            goldDisplayElement = document.getElementById('gold-display');
            spellAreaElement = document.getElementById('spell-area');
            fireballElement = document.getElementById('fireball-spell');
            flameWaveElement = document.getElementById('flame-wave-spell');
            frostNovaElement = document.getElementById('frost-nova-spell');
            healElement = document.getElementById('heal-spell');
            turnInfo = document.getElementById('turn-info');
            unitInfo = document.getElementById('unit-info');
            unitPortraitElement = document.getElementById('unit-portrait');
            currentTurnDisplay = document.getElementById('current-turn');
            actionsLeftDisplay = document.getElementById('actions-left');
            unitNameDisplay = document.getElementById('unit-name');
            unitHpDisplay = document.getElementById('unit-hp');
            unitAtkDisplay = document.getElementById('unit-atk');
            unitMovDisplay = document.getElementById('unit-mov');
            unitRngDisplay = document.getElementById('unit-rng');
            unitStatusDisplay = document.getElementById('unit-status');
            boardFeedbackArea = document.getElementById('board-feedback-area');
            endTurnButton = document.getElementById('end-turn-button');
            startScreen = document.getElementById('start-screen');
            gameOverScreen = document.getElementById('game-over-screen');
            startButton = document.getElementById('start-button');
            restartButton = document.getElementById('restart-button');
            gameOverTitle = document.getElementById('game-over-title');
            gameOverMessage = document.getElementById('game-over-message');
            fullscreenButton = document.getElementById('fullscreen-button');
            muteButton = document.getElementById('mute-button');
            tooltipElement = document.getElementById('unit-tooltip');
            leaderboardButton = document.getElementById('leaderboard-button');
            leaderboardOverlay = document.getElementById('leaderboard-overlay');
            leaderboardList = document.getElementById('leaderboard-list');
            closeLeaderboardButton = document.getElementById('close-leaderboard-button');
            menuButton = document.getElementById('menu-button');
            menuOverlay = document.getElementById('menu-overlay');
            closeMenuButton = document.getElementById('close-menu-button');

            try {
                const moveDurationStr = getComputedStyle(document.documentElement).getPropertyValue('--move-anim-time').trim();
                if (moveDurationStr.endsWith('ms')) MOVE_ANIMATION_DURATION_MS = parseFloat(moveDurationStr);
                else if (moveDurationStr.endsWith('s')) MOVE_ANIMATION_DURATION_MS = parseFloat(moveDurationStr) * 1000;

                const flameWaveDelayStr = getComputedStyle(document.documentElement).getPropertyValue('--flame-wave-stagger-delay').trim();
                if (flameWaveDelayStr.endsWith('ms')) FLAME_WAVE_STAGGER_DELAY_MS = parseFloat(flameWaveDelayStr);
                else if (flameWaveDelayStr.endsWith('s')) FLAME_WAVE_STAGGER_DELAY_MS = parseFloat(flameWaveDelayStr) * 1000;

            } catch (e) { MOVE_ANIMATION_DURATION_MS = 250; FLAME_WAVE_STAGGER_DELAY_MS = 50; }

            if (menuButton) menuButton.addEventListener('click', showMenu);
            if (closeMenuButton) closeMenuButton.addEventListener('click', hideMenu);
            if (muteButton) muteButton.addEventListener('click', toggleMute);
            if (fireballElement) fireballElement.addEventListener('click', () => setActiveSpell('fireball'));
            if (flameWaveElement) flameWaveElement.addEventListener('click', () => setActiveSpell('flameWave'));
            if (frostNovaElement) frostNovaElement.addEventListener('click', () => setActiveSpell('frostNova'));
            if (healElement) healElement.addEventListener('click', () => setActiveSpell('heal'));
            if (fullscreenButton) fullscreenButton.addEventListener('click', toggleFullscreen);
            if (leaderboardButton) leaderboardButton.addEventListener('click', showLeaderboard);
            if (closeLeaderboardButton) closeLeaderboardButton.addEventListener('click', hideLeaderboard);
            if (startButton) startButton.addEventListener('click', () => {
                 if (!audioInitialized && !initializeAudio()) {}
                if (startScreen && startScreen.classList.contains('visible') && !isProcessing) initGame(1);
            });
            if (restartButton) restartButton.addEventListener('click', () => {
                if (!audioInitialized && !initializeAudio()) {}
                initGame(levelToRestartOnLoss);
            });
            if (endTurnButton) endTurnButton.addEventListener('click', () => {
                if (currentTurn === 'player' && !isProcessing && !isGameOver()) endTurn();
            });

            if (startScreen) startScreen.classList.add('visible');
            if (gameOverScreen) gameOverScreen.classList.remove('visible');
            if (leaderboardOverlay) leaderboardOverlay.classList.remove('visible');
            if (menuOverlay) menuOverlay.classList.remove('visible');
            if (endTurnButton) { endTurnButton.classList.add('disabled'); endTurnButton.disabled = true; }
            updateUnitInfo(null); updateLevelDisplay(); updateGoldDisplay();
            setupBoard(); resetLevelState(); updateTurnDisplay(); isProcessing = false;
            updateMuteButtonVisual();
            requestAnimationFrame(() => { try { calculateCellSize(); updateFullscreenButton(); } catch (e) {} });
            window.addEventListener('keydown', handleKeyDown);
        });

        function handleKeyDown(event) {
             const gameActive = startScreen && !startScreen.classList.contains('visible') && !isGameOver();
             const anOverlayIsOpen = isGameOver() || isMenuOpen() || isLeaderboardOpen();

            if (event.key.toLowerCase() === 'm') { toggleMute(); event.preventDefault(); return; }
            if (event.key.toLowerCase() === 'f') { toggleFullscreen(); event.preventDefault(); return; }

             if (event.key.toLowerCase() === 'escape') {
                  if (isMenuOpen()) { hideMenu(); event.preventDefault(); return; }
                  if (isLeaderboardOpen()) { hideLeaderboard(); event.preventDefault(); return; }

                 if (gameActive && !anOverlayIsOpen && currentTurn === 'player' && !isProcessing) {
                      if (currentSpell) { setActiveSpell(null); event.preventDefault(); }
                      else if (selectedUnit) { deselectUnit(); event.preventDefault(); }
                 }
                 return;
            }

             if (anOverlayIsOpen || !gameActive) return;
             if (isProcessing) return;

             if (event.shiftKey) {
                 if (event.key.toLowerCase() === 'g') {
                    event.preventDefault(); unlimitedSpellsCheat = !unlimitedSpellsCheat;
                    const feedbackMsg = unlimitedSpellsCheat ? "CHEAT: Unlimited/Unlocked Spells ON!" : "CHEAT: Unlimited/Unlocked Spells OFF.";
                    showFeedback(feedbackMsg, "feedback-cheat"); playSfx('cheat');
                    if (unlimitedSpellsCheat) spellUses = { fireball: true, flameWave: true, frostNova: true, heal: true };
                    else resetSpellStateForNewLevel();
                    updateSpellUI(); return;
                 }
                 if (event.key.toLowerCase() === 't' && currentTurn === 'player' && !levelClearedAwaitingInput) {
                     isProcessing = true; updateTurnDisplay(); deselectUnit(false); setActiveSpell(null); hideTooltip(); lastHoveredUnitId = null;
                     showFeedback("CHEAT: Skipping Level...", "feedback-levelup"); playSfx('cheat');
                     setTimeout(startNextLevel, 100); event.preventDefault(); return;
                 }
             }

            if ((event.metaKey || event.ctrlKey || event.altKey)) return;

            if (currentTurn === 'player' && !levelClearedAwaitingInput) {
                switch (event.key.toLowerCase()) {
                    case '1': setActiveSpell('fireball'); event.preventDefault(); break;
                    case '2': setActiveSpell('flameWave'); event.preventDefault(); break;
                    case '3': setActiveSpell('frostNova'); event.preventDefault(); break;
                    case '4': setActiveSpell('heal'); event.preventDefault(); break;
                }
            }
            if (currentTurn === 'player') {
                 if (event.key.toLowerCase() === 'e') { endTurn(); event.preventDefault(); }
            }
        }

    </script>
</body>
</html>
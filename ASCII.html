<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ASCII Adventure - Roguelike</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #111;
            color: #eee;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            position: relative;
            width: 100vmin;
            height: 100vmin;
            max-width: 100%;
            max-height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-screen {
            aspect-ratio: 25 / 19; /* Adjusted aspect ratio slightly for more UI space */
            width: 100%;
            height: 100%;
            background-color: #000;
            border: 2px solid #555;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            image-rendering: pixelated;
        }

        #map-display {
            flex-grow: 1;
            background-color: #1a1a1a;
            padding: 1vmin;
            white-space: pre;
            overflow: hidden;
            line-height: 1.0;
            position: relative;
            color: #ccc;
            font-family: 'Courier New', Courier, monospace;
            will-change: font-size;
        }

        #ui-panel {
            height: auto;
            min-height: 7em; /* Increased height */
            font-size: 1.4vmin; /* Adjusted font size slightly */
            background-color: #222;
            border-top: 2px solid #555;
            padding: 0.5em 1em;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

         #status-line, #status-line-2, #status-line-3 { /* Added third status line */
             display: flex;
             justify-content: space-between;
             flex-wrap: wrap;
             gap: 1em;
             margin-bottom: 0.3em;
             font-weight: bold;
         }
         #status-line span, #status-line-2 span, #status-line-3 span { padding: 0 0.5em; }
         #hp-bar {
            display: inline-block;
            min-width: 5em;
            background-color: #500;
            border: 1px solid #a00;
            vertical-align: middle;
         }
         #hp-bar-fill {
             height: 0.8em;
             background-color: #d00;
             transition: width 0.3s ease;
         }
         #xp-bar {
             display: inline-block;
             min-width: 5em;
             background-color: #005;
             border: 1px solid #00a;
             vertical-align: middle;
         }
         #xp-bar-fill {
             height: 0.8em;
             background-color: #00d;
             transition: width 0.3s ease;
         }

        #message-log {
            height: 3em; /* Adjusted height slightly */
            overflow-y: scroll;
            border: 1px dashed #444;
            padding: 0.3em;
            margin-top: 0.5em;
            font-size: 0.9em;
            line-height: 1.2;
            color: #bbb;
        }
        #message-log p { margin: 0; padding: 0; }


        #mobile-controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: grid;
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
            gap: 8px;
            width: clamp(120px, 30vmin, 200px);
            opacity: 0.75;
            z-index: 10;
        }

        #mobile-controls button {
            font-family: 'Courier New', Courier, monospace;
            font-size: clamp(1.2em, 5vmin, 2em);
            background-color: #444;
            color: #eee;
            border: 1px solid #888;
            border-radius: 8px;
            padding: 0;
            aspect-ratio: 1/1;
            touch-action: manipulation;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #mobile-controls button:active {
            background-color: #666;
        }

        #btn-up { grid-area: up; }
        #btn-down { grid-area: down; }
        #btn-left { grid-area: left; }
        #btn-right { grid-area: right; }


        #fullscreen-button {
             position: absolute;
             top: clamp(5px, 1.5vmin, 15px);
             right: clamp(5px, 1.5vmin, 15px);
             width: clamp(25px, 5vmin, 40px);
             height: clamp(25px, 5vmin, 40px);
             background-color: rgba(50, 50, 50, 0.7);
             border: 1px solid #aaa;
             border-radius: 3px;
             cursor: pointer;
             z-index: 20;
             display: flex;
             justify-content: center;
             align-items: center;
             padding: 0;
        }
         #fullscreen-button svg {
            width: 70%;
            height: 70%;
            fill: #eee;
        }
        #fullscreen-button:hover {
            background-color: rgba(80, 80, 80, 0.9);
        }

        .player { color: yellow; font-weight: bold; }
        .wall { color: #888; }
        .floor { color: #555; }
        .water { color: #36f; }
        .tree { color: #2a4; }
        .monster { color: red; font-weight: bold; animation: blink 1s step-end infinite; }
        .monster-orc { color: orangered; font-weight: bold; animation: blink 0.8s step-end infinite; }
        .monster-boss { color: magenta; font-weight: bold; animation: blink 0.5s step-end infinite; } /* Boss Style */
        .item { color: cyan; font-weight: bold; animation: blink 1.5s step-end infinite; }
        .heal { color: limegreen; font-weight: bold; }
        .door { color: #d9a400; }
        .key { color: #d9a400; font-weight: bold; animation: blink 1.2s step-end infinite alternate; } /* Key style */
        .gold { color: gold; font-weight: bold; animation: blink 1.8s step-end infinite;} /* Gold style */
        .attack-boost { color: #ff69b4; font-weight: bold; animation: blink 1s step-end infinite alternate; } /* Attack boost style */
        .trap { color: #8b0000; }


        @keyframes blink {
            50% { opacity: 0.3; }
        }

        /* --- Overlays --- */
        .overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 50;
            display: none; /* Hidden by default */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            text-align: center;
            font-size: 1.8vmin;
            color: #eee;
        }
        .overlay.active {
            display: flex; /* Show when active */
        }

        .overlay-title {
            font-size: 2.5em;
            margin-bottom: 20px;
            font-weight: bold;
        }
        .overlay-text {
             font-size: 1.2em;
             margin-bottom: 25px;
             max-width: 80%;
        }
         .overlay-stats p {
             margin: 5px 0;
             font-size: 1.1em;
         }
         .overlay-stats { margin-bottom: 30px; }

        .overlay button {
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.1em;
            padding: 10px 20px;
            margin-top: 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            min-width: 150px;
        }
        .overlay button:hover { background-color: #45a049; }
        .overlay button:disabled { background-color: #333; color: #777; cursor: not-allowed;}


        /* Combat Overlay Specifics */
        #combat-overlay #combat-log {
            width: 90%;
            height: 50%;
            border: 1px solid #666;
            margin-bottom: 15px;
            overflow-y: auto;
            padding: 10px;
            background-color: #111;
            font-size: 0.9em;
             white-space: normal;
             line-height: 1.3;
        }
         #combat-overlay #combat-log p { margin-bottom: 0.3em;}
         #combat-overlay #combat-stats { font-size: 0.95em; margin-bottom: 10px; }
         #combat-overlay #combat-actions button {
            font-family: 'Courier New', Courier, monospace;
            font-size: 1em;
            padding: 8px 15px;
            margin: 0 5px;
            background-color: #444;
            color: #eee;
            border: 1px solid #888;
            border-radius: 3px;
            cursor: pointer;
        }
         #combat-overlay #combat-actions button:hover { background-color: #666; }
         #combat-overlay #combat-actions button:disabled { background-color: #333; color: #777; cursor: not-allowed;}
         #combat-overlay #combat-result { margin-top: 10px; font-weight: bold; font-size: 1.1em;}

         /* Victory Overlay Specifics */
         #victory-overlay .overlay-title { color: gold; }


    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-screen">
            <div id="map-display"></div>
            <div id="ui-panel">
                 <div id="status-line">
                     <span id="player-level">Lvl: 1</span>
                     <span id="player-hp">HP: 10/10
                         <span id="hp-bar"><span id="hp-bar-fill" style="width: 100%;"></span></span>
                     </span>
                     <span id="player-attack">Atk: 2</span>
                </div>
                 <div id="status-line-2">
                      <span id="player-xp">XP: 0/10
                         <span id="xp-bar"><span id="xp-bar-fill" style="width: 0%;"></span></span>
                     </span>
                     <span id="player-items">Potions: 0</span>
                     <span id="player-keys">Keys: 0</span> <!-- New UI Element -->
                     <span id="player-gold">Gold: 0</span>  <!-- New UI Element -->
                 </div>
                 <div id="status-line-3">
                     <span id="player-pos">Pos: (0, 0)</span>
                     <span id="monster-count">Monsters: ?</span> <!-- New UI Element -->
                 </div>
                <div id="message-log">
                    <p>Loading...</p>
                </div>
            </div>

            <!-- Combat Overlay -->
            <div id="combat-overlay" class="overlay">
                <h3 id="combat-title" class="overlay-title" style="font-size: 1.8em; color:orangered;">Combat!</h3>
                <div id="combat-log"></div>
                <div id="combat-stats">
                    <p>Player HP: <span id="combat-player-hp"></span> | Monster HP: <span id="combat-monster-hp"></span></p>
                </div>
                <div id="combat-actions">
                    <button id="combat-attack">Attack</button>
                    <button id="combat-potion">Use Potion</button>
                    <button id="combat-flee">Flee</button>
                </div>
                 <div id="combat-result" style="margin-top: 10px; font-weight: bold;"></div>
            </div>

             <!-- Victory Overlay -->
             <div id="victory-overlay" class="overlay">
                 <h2 class="overlay-title">VICTORY!</h2>
                 <p class="overlay-text">You have cleared the dungeon of all monsters!</p>
                 <div class="overlay-stats">
                     <p>Final Level: <span id="victory-level">1</span></p>
                     <p>Gold Collected: <span id="victory-gold">0</span></p>
                     <p>Potions Remaining: <span id="victory-potions">0</span></p>
                 </div>
                 <button id="restart-button">Play Again</button>
             </div>

        </div>

        <!-- On-Screen Controls -->
        <div id="mobile-controls">
            <button id="btn-up">▲</button>
            <button id="btn-left">◄</button>
            <button id="btn-right">►</button>
            <button id="btn-down">▼</button>
        </div>

        <!-- Fullscreen Button -->
        <button id="fullscreen-button" title="Toggle Fullscreen">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zm-3-12V5h3v2h-3z"/>
                <path d="M0 0h24v24H0z" fill="none"/>
             </svg>
        </button>

    </div>

    <script>
        const gameContainer = document.getElementById('game-container');
        const gameScreen = document.getElementById('game-screen');
        const mapDisplay = document.getElementById('map-display');
        const messageLog = document.getElementById('message-log');
        const playerHpDisplay = document.getElementById('player-hp');
        const hpBarFill = document.getElementById('hp-bar-fill');
        const playerLevelDisplay = document.getElementById('player-level');
        const playerXpDisplay = document.getElementById('player-xp');
        const xpBarFill = document.getElementById('xp-bar-fill');
        const playerAttackDisplay = document.getElementById('player-attack');
        const playerPosDisplay = document.getElementById('player-pos');
        const playerItemsDisplay = document.getElementById('player-items');
        const playerKeysDisplay = document.getElementById('player-keys'); // New UI element ref
        const playerGoldDisplay = document.getElementById('player-gold'); // New UI element ref
        const monsterCountDisplay = document.getElementById('monster-count'); // New UI element ref
        const uiPanel = document.getElementById('ui-panel');

        const combatOverlay = document.getElementById('combat-overlay');
        const combatTitle = document.getElementById('combat-title');
        const combatLog = document.getElementById('combat-log');
        const combatPlayerHp = document.getElementById('combat-player-hp');
        const combatMonsterHp = document.getElementById('combat-monster-hp');
        const combatActions = document.getElementById('combat-actions');
        const combatAttackBtn = document.getElementById('combat-attack');
        const combatPotionBtn = document.getElementById('combat-potion');
        const combatFleeBtn = document.getElementById('combat-flee');
        const combatResult = document.getElementById('combat-result');

        const victoryOverlay = document.getElementById('victory-overlay'); // New Overlay ref
        const victoryLevel = document.getElementById('victory-level');
        const victoryGold = document.getElementById('victory-gold');
        const victoryPotions = document.getElementById('victory-potions');
        const restartButton = document.getElementById('restart-button');

        const SAVE_KEY = 'asciiRpgSaveData'; // Changed save key for compatibility break
        const VIEW_WIDTH = 25;
        const VIEW_HEIGHT = 15;

        let player = {
            x: 1, y: 2,
            hp: 15, // Slightly more HP to start
            maxHp: 15,
            attack: 3, // Slightly more attack
            potions: 1, // Start with one potion
            keys: 0,    // New property
            gold: 0,    // New property
            level: 1,
            xp: 0,
            xpToNextLevel: 15 // Slightly higher XP requirement
        };

        let monster = null;
        let gameState = 'map'; // map, combat, endingCombat, gameOver, won
        let isPlayerTurn = true;
        let currentMapData = [];
        let totalMonsters = 0; // Track initial monster count
        let monstersRemaining = 0; // Track remaining monsters

        // *** Revamped Map with New Elements ***
        // D = Door, k = Key, $ = Gold, A = Attack Boost, ^ = Trap, B = Boss (optional)
        const initialMap = [
        // 0         1         2         3
        // 0123456789012345678901234567890
            "##############################", // 0
            "#..$.........#...#....^...♀..#", // 1 Trap added
            "#&.........*...*.#.......O..$#", // 2 Potions spread out
            "#....T...........#...........#", // 3 Door added, Key added
            "#....T.~~..........#######...#", // 4
            "#...$..~~..........#.♀...#...#", // 5
            "#..^...............#..M..#...#", // 6 Trap added
            "#....#######.......#.....#...#", // 7
            "#....# M O.D.......####D##...#", // 8 Door added
            "#....# H A.#........$........#", // 9 Attack Boost (A) added
            "#....#######...M......^......#", // 10 Trap added
            "#............................#", // 11 Key added
            "#.......#########......$.....#", // 12
            "#.......#....♀..#...T.T......#", // 13 Orc removed, added path
            "#.......#...O...#...T.T...####", // 14 Orc moved, leads to 'Boss' Area
            "#.......#.......#.....$...#..#", // 15 Path to Boss Area, Key added
            "#.......###.#####.....####B$.#", // 16 Boss 'B' (optional, treat as Orc for now), Gold
            "#.........*......M...........#", // 17
            "##############################"  // 18
        ];
        // *** End of Map ***

        const mapWidth = initialMap[0].length;
        const mapHeight = initialMap.length;

        function logMessage(message, color = '#eee', important = false) {
            const p = document.createElement('p');
            p.textContent = `> ${message}`;
            p.style.color = color;
            if (important) p.style.fontWeight = 'bold';
            messageLog.appendChild(p);
            messageLog.scrollTop = messageLog.scrollHeight;
            while (messageLog.children.length > 50) {
                messageLog.removeChild(messageLog.firstChild);
            }
        }

        function combatLogMessage(message, color = '#eee') {
             const p = document.createElement('p');
             p.textContent = message;
             p.style.color = color;
             combatLog.appendChild(p);
             combatLog.scrollTop = combatLog.scrollHeight;
        }

        function getTile(x, y, mapSource = currentMapData) {
            if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight || !mapSource[y]) {
                return '#';
            }
            if (typeof mapSource[y] === 'string' && x < mapSource[y].length) {
                return mapSource[y][x];
            }
            return '#';
        }

        function setTile(x, y, tile) {
            if (x >= 0 && x < mapWidth && y >= 0 && y < mapHeight && currentMapData[y]) {
                 let row = currentMapData[y].split('');
                 if (row[x] !== tile) {
                     row[x] = tile;
                     currentMapData[y] = row.join('');
                     return true;
                 }
            }
            return false;
        }

        function countMonsters(mapData) {
            let count = 0;
            for (let y = 0; y < mapHeight; y++) {
                for (let x = 0; x < mapWidth; x++) {
                    const tile = mapData[y][x];
                    if (tile === 'M' || tile === 'O' || tile === 'B') { // Include Boss if implemented
                        count++;
                    }
                }
            }
            return count;
        }


        function saveGame() {
             try {
                 const saveData = {
                     player: JSON.parse(JSON.stringify(player)),
                     map: currentMapData.map(row => row),
                     monstersRemaining: monstersRemaining // Save remaining count
                 };
                 localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
                 console.log("Game saved.");
             } catch (e) {
                 console.error("Failed to save game:", e);
                 logMessage("Error: Could not save game progress.", "red");
             }
         }

         function loadGame() {
             try {
                 const savedData = localStorage.getItem(SAVE_KEY);
                 if (savedData) {
                     const parsedData = JSON.parse(savedData);
                     if (parsedData.player && parsedData.player.keys !== undefined && parsedData.player.gold !== undefined &&
                         parsedData.map && Array.isArray(parsedData.map) && parsedData.map.length === mapHeight &&
                         typeof parsedData.map[0] === 'string' && parsedData.map[0].length === mapWidth &&
                         parsedData.monstersRemaining !== undefined)
                     {
                         player = parsedData.player;
                         currentMapData = parsedData.map;
                         monstersRemaining = parsedData.monstersRemaining; // Load remaining count
                         totalMonsters = countMonsters(initialMap); // Recalculate total based on initial map
                         console.log("Game loaded from save.");
                         logMessage("Save data loaded successfully!", "lightgreen");
                         updateMonsterCountDisplay(); // Update UI after loading
                         return true;
                     } else {
                          console.warn("Invalid or incompatible save data found. Starting new game.");
                          localStorage.removeItem(SAVE_KEY);
                     }
                 } else {
                     console.log("No save data found. Starting new game.");
                 }
             } catch (e) {
                 console.error("Failed to load or parse save game:", e);
                 logMessage("Error loading saved game. Starting fresh.", "orange");
                 localStorage.removeItem(SAVE_KEY);
             }
             initializeNewGame();
             return false;
         }


          function initializeNewGame() {
             console.log("Initializing new game state.");
             currentMapData = initialMap.map(row => row);

             player = { // Reset player fully
                x: 1, y: 2, hp: 15, maxHp: 15, attack: 3, potions: 1,
                keys: 0, gold: 0, level: 1, xp: 0, xpToNextLevel: 15
             };

             let foundStart = false;
             for (let y = 0; y < mapHeight; y++) {
                 const x = initialMap[y].indexOf('&');
                 if (x !== -1) {
                     player.x = x;
                     player.y = y;
                     setTile(x, y, '.');
                     foundStart = true;
                     break;
                 }
             }
             if (!foundStart) console.error("Player start '&' not found!");

             totalMonsters = countMonsters(initialMap); // Count monsters on the new map
             monstersRemaining = totalMonsters;
             updateMonsterCountDisplay();

             gameState = 'map'; // Ensure correct state
             victoryOverlay.classList.remove('active'); // Ensure victory overlay is hidden
             combatOverlay.classList.remove('active'); // Ensure combat overlay is hidden


             logMessage("Welcome to the ASCII Dungeon!", "cyan", true);
         }

        function updateMonsterCountDisplay() {
            monsterCountDisplay.textContent = `Monsters: ${monstersRemaining}/${totalMonsters}`;
        }

        function checkWinCondition() {
            if (monstersRemaining <= 0 && gameState !== 'won') {
                gameState = 'won';
                victoryLevel.textContent = player.level;
                victoryGold.textContent = player.gold;
                victoryPotions.textContent = player.potions;
                victoryOverlay.classList.add('active');
                logMessage("YOU ARE VICTORIOUS!", "gold", true);
            }
        }


        function renderGame() {
            if (gameState === 'won') { // Don't render map if won
                 mapDisplay.innerHTML = ''; // Clear map display
                 return;
             }
             if (!currentMapData || currentMapData.length === 0) return;


            let mapView = '';
            let startX = Math.max(0, Math.min(player.x - Math.floor(VIEW_WIDTH / 2), mapWidth - VIEW_WIDTH));
            let startY = Math.max(0, Math.min(player.y - Math.floor(VIEW_HEIGHT / 2), mapHeight - VIEW_HEIGHT));

            for (let y = 0; y < VIEW_HEIGHT; y++) {
                for (let x = 0; x < VIEW_WIDTH; x++) {
                    let mapX = startX + x;
                    let mapY = startY + y;

                    if (mapX === player.x && mapY === player.y) {
                        mapView += '<span class="player">&</span>';
                    } else {
                         let tile = getTile(mapX, mapY);
                         let tileClass = '';
                         switch(tile) {
                             case '#': tileClass = 'wall'; break;
                             case '.': tileClass = 'floor'; break;
                             case '~': tileClass = 'water'; break;
                             case 'T': tileClass = 'tree'; break;
                             case 'M': tileClass = 'monster'; break;
                             case 'O': tileClass = 'monster-orc'; break;
                             case 'B': tileClass = 'monster-boss'; break; // Boss Style
                             case '*': tileClass = 'item'; break;
                             case 'H': tileClass = 'heal'; break;
                             case 'D': tileClass = 'door'; break;     // Door Style
                             case '♀': tileClass = 'key'; break;      // Key Style
                             case '$': tileClass = 'gold'; break;     // Gold Style
                             case 'A': tileClass = 'attack-boost'; break; // Attack Boost Style
                             case '^': tileClass = 'trap'; break;     // Trap Style
                             default: tileClass = 'floor'; tile = '.';
                         }
                         mapView += `<span class="${tileClass}">${tile}</span>`;
                    }
                }
                mapView += '\n';
            }
            mapDisplay.innerHTML = mapView;

            let hpPercentage = Math.max(0, (player.hp / player.maxHp) * 100);
            let xpPercentage = Math.max(0, (player.xp / player.xpToNextLevel) * 100);

            playerLevelDisplay.textContent = `Lvl: ${player.level}`;
            const hpBarContainer = playerHpDisplay.querySelector('#hp-bar');
            playerHpDisplay.textContent = `HP: ${player.hp}/${player.maxHp} `;
            if (hpBarContainer) {
                 playerHpDisplay.appendChild(hpBarContainer);
                 const hpFill = hpBarContainer.querySelector('#hp-bar-fill');
                 if(hpFill) hpFill.style.width = `${hpPercentage}%`;
            }

            playerAttackDisplay.textContent = `Atk: ${player.attack}`;
            playerItemsDisplay.textContent = `Potions: ${player.potions}`;
            playerKeysDisplay.textContent = `Keys: ${player.keys}`; // Update Keys UI
            playerGoldDisplay.textContent = `Gold: ${player.gold}`; // Update Gold UI

             const xpBarContainer = playerXpDisplay.querySelector('#xp-bar');
             playerXpDisplay.textContent = `XP: ${player.xp}/${player.xpToNextLevel} `;
             if(xpBarContainer){
                 playerXpDisplay.appendChild(xpBarContainer);
                 const xpFill = xpBarContainer.querySelector('#xp-bar-fill');
                 if(xpFill) xpFill.style.width = `${xpPercentage}%`;
             }

            playerPosDisplay.textContent = `Pos: (${player.x}, ${player.y})`;
            updateMonsterCountDisplay(); // Keep monster count updated

            combatOverlay.classList.toggle('active', gameState === 'combat'); // Use classList.toggle
            // Victory overlay is handled separately in checkWinCondition
        }


         function adjustFontSize() {
             const mapRect = mapDisplay.getBoundingClientRect();
             if (mapRect.width === 0 || mapRect.height === 0) return;
             const fontWidth = mapRect.width / VIEW_WIDTH;
             const fontHeight = mapRect.height / VIEW_HEIGHT;
             const targetFontSize = Math.max(1, Math.min(fontWidth * 1.65, fontHeight * 0.95));
             mapDisplay.style.fontSize = `${targetFontSize}px`;
             mapDisplay.style.lineHeight = `1.0`;

             const uiFontSize = Math.max(8, 1.4 * Math.min(window.innerWidth, window.innerHeight) / 100);
             uiPanel.style.fontSize = `${uiFontSize}px`;
         }


        function movePlayer(dx, dy) {
            if (gameState !== 'map') return; // Only allow movement in map state

            let newX = player.x + dx;
            let newY = player.y + dy;

            let targetTile = getTile(newX, newY);
            let blocked = false;
            let blockMessage = "Blocked!";

             // --- Collision and Static Interaction Checks ---
             if (targetTile === '#' || targetTile === '~' || targetTile === 'T') {
                blocked = true;
                if(targetTile === '~') blockMessage = "The water is too deep to cross.";
                if(targetTile === 'T') blockMessage = "A sturdy tree blocks the path.";
            } else if (targetTile === 'D') { // Locked Door
                if (player.keys > 0) {
                    player.keys--;
                    logMessage("Used a key to unlock the door.", "gold");
                    setTile(newX, newY, '.'); // Change door to floor
                    targetTile = '.'; // Allow movement onto the new floor tile
                    saveGame(); // Save key usage and map change
                } else {
                    blocked = true;
                    blockMessage = "The door is locked. You need a key.";
                }
            }

            if(blocked) {
                 logMessage(blockMessage, "#ff8888");
                 return; // Stop processing if blocked
             }

            // --- Dynamic Interactions (Items, Monsters, Traps) ---
            let interactionOccurred = false;
            let shouldMove = true;
            let shouldSave = false;

            if (targetTile === '*') { // Potion
                player.potions++;
                logMessage("Found a health potion!", "#aaffaa");
                 if (setTile(newX, newY, '.')) shouldSave = true;
                 interactionOccurred = true;
            } else if (targetTile === '♀') { // Key
                player.keys++;
                logMessage("Found a key!", "gold");
                 if (setTile(newX, newY, '.')) shouldSave = true;
                 interactionOccurred = true;
             } else if (targetTile === '$') { // Gold
                 let amount = 1 + Math.floor(Math.random() * 5); // Random gold amount 1-5
                 player.gold += amount;
                 logMessage(`Found ${amount} gold! Total: ${player.gold}`, "gold");
                 if (setTile(newX, newY, '.')) shouldSave = true;
                 interactionOccurred = true;
             } else if (targetTile === 'A') { // Attack Boost
                 player.attack++;
                 logMessage("Found a Strength Scroll! Attack +1", "#ff69b4", true);
                 if (setTile(newX, newY, '.')) shouldSave = true;
                 interactionOccurred = true;
            } else if (targetTile === 'H') { // Heal Spot
                 if (player.hp < player.maxHp) {
                     const healed = player.maxHp - player.hp;
                     player.hp = player.maxHp;
                     logMessage(`Rested at the spring. Restored ${healed} HP.`, "#aaffaa");
                 } else {
                     logMessage("Rested, but already at full health.");
                 }
                 if (setTile(newX, newY, '.')) shouldSave = true; // Consume heal spot
                 interactionOccurred = true;
             } else if (targetTile === '^') { // Trap
                 let trapDamage = 1 + Math.floor(Math.random() * 3); // Damage 1-3
                 player.hp = Math.max(0, player.hp - trapDamage);
                 logMessage(`Stepped on a trap! Took ${trapDamage} damage.`, "#ff4444", true);
                 if (setTile(newX, newY, '.')) shouldSave = true; // Remove trap after triggering
                 interactionOccurred = true;
                 if (player.hp <= 0) { // Check for death from trap
                      logMessage("You succumbed to the trap!", "red", true);
                      gameState = 'gameOver';
                      // Optional: Add a specific Game Over screen/logic here
                      setTimeout(() => { // Delay to show message
                          logMessage("GAME OVER. Refresh page to restart from last save.", 'red', true);
                      }, 1500);
                      shouldMove = false; // Don't move if dead
                 }
            } else if (targetTile === 'M' || targetTile === 'O' || targetTile === 'B') { // Monster / Boss
                let monsterName = 'Goblin';
                if (targetTile === 'O') monsterName = 'Orc';
                if (targetTile === 'B') monsterName = 'Dungeon Guardian'; // Boss Name
                logMessage(`A wild ${monsterName} appears!`, "#ffaaaa");
                startCombat(newX, newY, targetTile);
                shouldMove = false; // Combat starts, don't move onto tile yet
                interactionOccurred = true;
            }

            // --- Update Player Position ---
            if (shouldMove && gameState === 'map') { // Double check state before moving
                 player.x = newX;
                 player.y = newY;
            }

            // --- Final Render and Save ---
            renderGame(); // Render updates position and map changes

            if (shouldSave) {
                 saveGame(); // Save state if an item was picked up, trap triggered, etc.
            }
        }

        function gainXP(amount) {
            if (gameState === 'gameOver' || gameState === 'won' || !Number.isInteger(amount) || amount <= 0) return;
            player.xp += amount;
            logMessage(`You gained ${amount} XP.`, 'cyan');
            let leveledUp = false;
            while (player.xp >= player.xpToNextLevel) {
                player.xp -= player.xpToNextLevel;
                levelUp();
                leveledUp = true;
            }
            if (leveledUp) {
                saveGame();
            } else {
                renderGame();
            }
        }


        function levelUp() {
            player.level++;
            player.maxHp += 5;
            player.hp = player.maxHp;
            player.attack += 1;
            player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.6);
            logMessage(`LEVEL UP! Reached level ${player.level}!`, 'yellow', true);
             logMessage(`Max HP +5, Attack +1. HP Restored.`, 'lime');
            renderGame();
        }

         function startCombat(monsterX, monsterY, monsterType) {
             if (gameState !== 'map') return; // Prevent starting combat in wrong state

            gameState = 'combat';
            combatLog.innerHTML = '';
            combatResult.textContent = '';

            switch (monsterType) {
                case 'O':
                     monster = { x: monsterX, y: monsterY, type: monsterType, name: "Orc", hp: 15, maxHp: 15, attack: 3, xp: 12 };
                     break;
                 case 'B': // Boss Stats
                     monster = { x: monsterX, y: monsterY, type: monsterType, name: "Dungeon Guardian", hp: 40, maxHp: 40, attack: 5, xp: 50 };
                     break;
                 case 'M':
                 default:
                     monster = { x: monsterX, y: monsterY, type: monsterType, name: "Goblin", hp: 8, maxHp: 8, attack: 2, xp: 5 };
                     break;
            }

            isPlayerTurn = true;
            combatTitle.textContent = `Combat vs ${monster.name}!`;
            combatLogMessage(`Encountered a ${monster.name}!`, 'yellow');
            updateCombatUI();
            updateCombatButtonStates();
            renderGame();
        }

        function updateCombatUI() {
            if (!monster || gameState !== 'combat') return;
            combatPlayerHp.textContent = `${player.hp}/${player.maxHp}`;
            combatMonsterHp.textContent = `${monster.hp}/${monster.maxHp}`;
        }

        function updateCombatButtonStates() {
            const combatActive = gameState === 'combat' && player.hp > 0 && monster && monster.hp > 0;
            const enabled = combatActive && isPlayerTurn;
            combatAttackBtn.disabled = !enabled;
            combatFleeBtn.disabled = !enabled;
            const potionEnabled = enabled && player.potions > 0 && player.hp < player.maxHp;
            combatPotionBtn.disabled = !potionEnabled;
            combatPotionBtn.textContent = `Use Potion (${player.potions})`;
         }


        function playerTurn(action) {
             if (gameState !== 'combat' || !isPlayerTurn || !monster || monster.hp <= 0 || player.hp <= 0) return;
             isPlayerTurn = false;
             updateCombatButtonStates();
             combatResult.textContent = '';
             let monsterWillAttack = true;

             switch(action) {
                case 'attack':
                    let playerDamage = Math.max(0, player.attack + Math.floor(Math.random() * 3) - 1);
                    monster.hp = Math.max(0, monster.hp - playerDamage);
                    combatLogMessage(`You attack the ${monster.name} for ${playerDamage} damage.`);
                    break;
                case 'potion':
                    if (player.potions > 0 && player.hp < player.maxHp) {
                        let healAmount = Math.floor(player.maxHp * 0.5);
                        let actualHeal = Math.min(healAmount, player.maxHp - player.hp);
                        player.hp += actualHeal;
                        player.potions--;
                        combatLogMessage(`Used potion, restored ${actualHeal} HP.`, '#aaffaa');
                        saveGame();
                    } else {
                         combatLogMessage(player.potions <= 0 ? "You have no potions!" : "Your HP is already full!", '#ffcc00');
                         monsterWillAttack = false;
                         isPlayerTurn = true;
                    }
                    break;
                case 'flee':
                    let fleeChance = 0.5; // Boss might be harder to flee from? Add logic if needed.
                    if (Math.random() < fleeChance) {
                        combatLogMessage("You successfully fled!", '#aaffaa');
                        endCombat(false);
                        return;
                    } else {
                        combatLogMessage("You failed to flee!", '#ffaaaa');
                    }
                    break;
             }

             updateCombatUI();

             if (monster.hp <= 0) {
                combatLogMessage(`You defeated the ${monster.name}!`, 'lime');
                combatResult.textContent = "Victory!";
                combatResult.style.color = 'lime';
                monstersRemaining--; // Decrement remaining count
                updateMonsterCountDisplay();
                gainXP(monster.xp);
                endCombat(true); // Pass true for victory
                return;
            }

             if (monsterWillAttack) {
                 setTimeout(() => monsterAttack(), 700);
             } else {
                 updateCombatButtonStates(); // Re-enable buttons if player turn repeats
             }
        }

         function monsterAttack() {
             if (gameState !== 'combat' || isPlayerTurn || !monster || monster.hp <= 0 || player.hp <= 0) return;
             let monsterDamage = Math.max(0, monster.attack + Math.floor(Math.random() * 3) - 1);
             player.hp = Math.max(0, player.hp - monsterDamage);
             combatLogMessage(`The ${monster.name} attacks you for ${monsterDamage} damage.`, '#ffaaaa');
             updateCombatUI();
             renderGame();

             if (player.hp <= 0) {
                 combatLogMessage("You have been defeated!", 'red');
                 combatResult.textContent = "Game Over!";
                 combatResult.style.color = 'red';
                 endCombat(false, true); // Defeat, game over
             } else {
                  isPlayerTurn = true;
                  updateCombatButtonStates();
             }
         }


        function endCombat(victory, gameOver = false) {
             gameState = 'endingCombat';
             isPlayerTurn = false;
             updateCombatButtonStates();
             let nextGameState = gameOver ? 'gameOver' : 'map';
             let delay = victory ? 1500 : 1000;

             let monsterJustDefeated = null; // Store ref to defeated monster
             if (victory && monster) {
                 monsterJustDefeated = monster;
             }

             setTimeout(() => {
                 gameState = nextGameState;
                 isPlayerTurn = true;
                 monster = null; // Clear current combat monster
                 combatLog.innerHTML = '';
                 combatResult.textContent = '';

                 if (victory && monsterJustDefeated) {
                    // Now safely modify the map and player position
                    if(setTile(monsterJustDefeated.x, monsterJustDefeated.y, '.')) {
                        player.x = monsterJustDefeated.x;
                        player.y = monsterJustDefeated.y;
                    }
                    saveGame(); // Save map change and player pos
                    checkWinCondition(); // Check if this was the last monster
                 }

                 renderGame();

                 if (gameOver) {
                    logMessage("GAME OVER. Refresh page to restart from last save.", 'red', true);
                 } else if (gameState !== 'won'){ // Don't show 'combat finished' if game was won
                    logMessage("Combat finished.", 'gray');
                 }

             }, delay);
        }


        function handleKeyDown(event) {
             if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
                 event.preventDefault();
             }

             if (gameState === 'map') {
                switch (event.key) {
                    case 'ArrowUp': case 'w': case 'W': movePlayer(0, -1); break;
                    case 'ArrowDown': case 's': case 'S': movePlayer(0, 1); break;
                    case 'ArrowLeft': case 'a': case 'A': movePlayer(-1, 0); break;
                    case 'ArrowRight': case 'd': case 'D': movePlayer(1, 0); break;
                }
            } else if (gameState === 'combat') {
                 if (isPlayerTurn) {
                     switch (event.key) {
                         case '1': case 'A': case 'a': combatAttackBtn.click(); break;
                         case '2': case 'P': case 'p': combatPotionBtn.click(); break;
                         case '3': case 'F': case 'f': combatFleeBtn.click(); break;
                     }
                 }
            } else if (gameState === 'won') {
                 if (event.key === 'Enter' || event.key === ' ') {
                     restartButton.click(); // Allow restarting with Enter/Space on win screen
                 }
             }
        }

        const fullscreenButton = document.getElementById('fullscreen-button');
        const fullscreenIcon = fullscreenButton.querySelector('svg path:first-of-type');
        const fullscreenEnterIconPath = "M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zm-3-12V5h3v2h-3z";
        const fullscreenExitIconPath = "M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z";

        function toggleFullScreen() { /* Function unchanged */
            const elementToFullscreen = document.documentElement;
            if (!document.fullscreenElement) {
                 if (elementToFullscreen.requestFullscreen) elementToFullscreen.requestFullscreen().catch(err => console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`));
                 else if (elementToFullscreen.webkitRequestFullscreen) elementToFullscreen.webkitRequestFullscreen();
                 else if (elementToFullscreen.mozRequestFullScreen) elementToFullscreen.mozRequestFullScreen();
                 else if (elementToFullscreen.msRequestFullscreen) elementToFullscreen.msRequestFullscreen();
            } else {
                 if (document.exitFullscreen) document.exitFullscreen();
                 else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                 else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
                 else if (document.msExitFullscreen) document.msExitFullscreen();
            }
        }

        function updateFullscreenIcon() { /* Function unchanged */
             if (document.fullscreenElement) {
                 fullscreenIcon.setAttribute('d', fullscreenExitIconPath);
                 fullscreenButton.title = "Exit Fullscreen";
             } else {
                 fullscreenIcon.setAttribute('d', fullscreenEnterIconPath);
                 fullscreenButton.title = "Enter Fullscreen";
             }
        }

        document.addEventListener('keydown', handleKeyDown);
        fullscreenButton.addEventListener('click', toggleFullScreen);
        document.addEventListener('fullscreenchange', updateFullscreenIcon);
        document.addEventListener('webkitfullscreenchange', updateFullscreenIcon);
        document.addEventListener('mozfullscreenchange', updateFullscreenIcon);
        document.addEventListener('MSFullscreenChange', updateFullscreenIcon);

        document.getElementById('btn-up').addEventListener('click', () => movePlayer(0, -1));
        document.getElementById('btn-down').addEventListener('click', () => movePlayer(0, 1));
        document.getElementById('btn-left').addEventListener('click', () => movePlayer(-1, 0));
        document.getElementById('btn-right').addEventListener('click', () => movePlayer(1, 0));

        combatAttackBtn.addEventListener('click', () => playerTurn('attack'));
        combatPotionBtn.addEventListener('click', () => playerTurn('potion'));
        combatFleeBtn.addEventListener('click', () => playerTurn('flee'));

        restartButton.addEventListener('click', () => {
            initializeNewGame();
            renderGame();
        });


         const resizeObserver = new ResizeObserver(entries => {
             window.requestAnimationFrame(() => {
                 adjustFontSize();
             });
         });

        window.onload = () => {
             messageLog.innerHTML = '';
             loadGame();
             adjustFontSize();
             renderGame();
             resizeObserver.observe(gameScreen);
         };

         window.addEventListener('orientationchange', () => {
             setTimeout(() => {
                 adjustFontSize();
                 renderGame();
             }, 150);
         });

    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Make it responsive -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Orcs vs Humans Chess (Mobile)</title>
    <style>
        /* --- Global Styles & Setup --- */
        :root { /* CSS Variables */
            /* Responsive Sizing */
            --board-size: min(480px, 90vw); /* Board size adapts, max 480px */
            --panel-height-desktop: 160px; /* Approx height for panel content */
            --panel-height-mobile: 180px; /* Slightly more height on mobile */

            --light-square: #f0d9b5; --dark-square: #b58863; --panel-bg: var(--light-square);
            --panel-text: #6a4a3a; --panel-border: #d3bfa8; --button-bg: rgba(181, 136, 99, 0.85);
            --button-bg-hover: var(--dark-square); --button-border: var(--dark-square); --button-text: #ffffff;
            --container-bg: #ffffff; --body-bg: #dcdcdc; --highlight-selected: rgba(30, 100, 200, 0.7);
            --highlight-move: rgba(0, 100, 0, 0.4); --highlight-capture: rgba(200, 0, 0, 0.5);
            --highlight-last-start: rgba(220, 220, 100, 0.35); --highlight-last-end: rgba(180, 220, 100, 0.4);
            --highlight-check: rgba(255, 0, 0, 0.5);
            --highlight-drag-over: rgba(70, 130, 180, 0.3);
            --animation-speed: 0.3s; /* Speed for the animation */
        }

        html, body {
            height: 100%; /* Ensure body can take full height if needed */
            overscroll-behavior: none; /* Prevent pull-to-refresh */
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex; justify-content: center; align-items: center; /* Center vertically and horizontally */
            padding: 10px; /* Some padding around the container */
            box-sizing: border-box; /* Include padding in size calculation */
            background-color: var(--body-bg);
            min-height: 100%; margin: 0;
            /* Prevent text selection during drag */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none; /* Disable callout menu on iOS */
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight */
        }

        #game-container {
            display: flex; flex-direction: column; align-items: center;
            background-color: var(--container-bg); padding: 15px; border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            transition: all 0.3s ease-in-out;
            position: relative; /* Needed for positioning moving piece & modal */
            width: 100%; /* Take available width */
            max-width: calc(var(--board-size) + 30px); /* Max width based on board + padding */
            box-sizing: border-box;
            margin: auto; /* Center container */
        }

         /* Fullscreen Specific Styles */
        #game-container:fullscreen {
             padding: 5px;
             border-radius: 0;
             box-shadow: none;
             width: 100%; height: 100%;
             max-width: none; /* Remove max-width in fullscreen */
             overflow: auto;
             background-color: var(--container-bg);
        }
        #game-container:fullscreen #board {
            width: min(95vh, 95vw); /* Adjust board size for fullscreen */
            height: min(95vh, 95vw);
        }
        /* Adjust bottom panel in fullscreen */
        #game-container:fullscreen #bottom-panel {
            width: min(95vh, 95vw); /* Match panel width to board */
            height: auto; /* Let height adjust */
            max-height: 25vh; /* Limit height in fullscreen */
            min-height: 100px;
            flex-shrink: 0; /* Prevent shrinking */
        }
         /* Ensure game area grows in fullscreen */
        #game-container:fullscreen #game-area {
            display: flex;
            flex-direction: column;
            height: 100%; /* Allow game area to take full height */
            width: 100%;
            justify-content: center; /* Center board and panel vertically if space */
            align-items: center;
        }
        #game-container:fullscreen #board-and-panels {
             flex-grow: 1; /* Allow this container to grow */
             justify-content: center; /* Center its content (board+panel) */
             width: 100%;
             max-width: min(95vh, 95vw); /* Limit width based on board size */
        }


        /* --- Mode Selection Styling (Responsive) --- */
        #mode-selection {
            background-color: var(--panel-bg); color: var(--panel-text); border-radius: 8px;
            margin-bottom: 20px; border: 1px solid var(--panel-border);
            width: 100%; /* Full width of container */
            height: auto; /* Auto height */
            min-height: var(--board-size); /* Minimum height similar to board */
            max-height: 80vh; /* Prevent it from getting too tall */
            box-sizing: border-box; box-shadow: inset 0 0 10px rgba(0,0,0,0.05);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            padding: 15px;
            overflow-y: auto;
        }
        #mode-selection h2 { margin-top: 0; margin-bottom: 15px; color: var(--dark-square); font-weight: 600; font-size: 1.4em; text-align: center;}

        .mode-type-selection {
             width: 100%;
             box-sizing: border-box;
             text-align: center;
        }
        .mode-type-selection button {
            display: block;
            width: 80%;
            max-width: 250px;
            margin: 8px auto;
            padding: 10px 15px; font-size: 1.0em; font-weight: 500; cursor: pointer; border: 1px solid var(--button-border); border-radius: 5px; background-color: rgba(255,255,255,0.4); color: var(--panel-text); transition: background-color 0.2s, box-shadow 0.2s;
        }
        .mode-type-selection button:hover { background-color: rgba(255,255,255,0.7); box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .mode-type-selection button.selected { background-color: var(--button-bg); color: var(--button-text); font-weight: bold; }

        #cpu-options-container {
            display: none; /* Initially hidden */
            flex-direction: column; /* Stack options vertically */
            align-items: center; /* Center items */
            width: 100%; max-width: 400px; margin-top: 15px; padding-top: 15px;
            border-top: 1px solid var(--panel-border);
            gap: 15px; /* Space between difficulty and side choice */
            transition: opacity 0.3s ease-in-out;
         }
        #cpu-options-container.options-disabled {
            opacity: 0.4; pointer-events: none; cursor: not-allowed;
        }
        #cpu-options-container.options-disabled button,
        #cpu-options-container.options-disabled .side-option {
             pointer-events: none; cursor: not-allowed;
        }

        /* Difficulty Buttons (stacked centrally) */
        #difficulty-choice {
            width: 100%;
            display: flex;
            flex-direction: column; /* Stack heading and buttons */
            align-items: center; /* Center horizontally */
            gap: 8px;
         }
        #difficulty-choice h3 {
            font-size: 0.9em; margin-bottom: 5px; font-weight: 500; text-align: center;
        }
        #difficulty-choice button {
            padding: 6px 12px; width: 120px; /* Fixed width for consistency */
            font-size: 0.9em; cursor: pointer; border: 1px solid var(--panel-border);
            border-radius: 4px; background-color: #fff; color: var(--panel-text);
            transition: background-color 0.2s;
        }
        #difficulty-choice button:hover { background-color: #eee; }
        #difficulty-choice button.selected { background-color: var(--dark-square); color: white; font-weight: bold; border-color: var(--dark-square); }

        /* Player Side Choice (Horizontal layout) */
        #player-side-choice {
            width: 100%; text-align: center;
        }
        #player-side-choice h3 { font-size: 0.9em; margin-bottom: 8px; font-weight: 500; }
        .side-option { display: inline-block; margin: 0 10px; padding: 5px; border-radius: 5px; cursor: pointer; transition: background-color 0.2s; text-align: center; vertical-align: top; }
        .side-option input[type="radio"] { display: none; }
        /* Make side choice images slightly larger for touch */
        .side-option img { width: 35px; height: 35px; display: block; margin: 0 auto 3px auto; pointer-events: none; }
        .side-option label { font-weight: 500; pointer-events: none; display: block; font-size: 0.85em; }
        .side-option:hover { background-color: rgba(181, 136, 99, 0.1); }
        .side-option.selected { background-color: rgba(181, 136, 99, 0.25); }

        #start-button-container { margin-top: 20px; padding-top: 15px; border-top: 1px solid var(--panel-border); width: 90%; text-align: center; }
        #start-game-button { padding: 12px 30px; font-size: 1.1em; cursor: pointer; background-color: var(--button-bg); color: var(--button-text); border: 1px solid var(--button-border); border-radius: 5px; transition: background-color 0.2s; font-weight: bold; }
        #start-game-button:hover:not(:disabled) { background-color: var(--button-bg-hover); }
        #start-game-button:disabled { background-color: #ccc; border-color: #bbb; color: #777; cursor: not-allowed; opacity: 0.6; }
        /* --- End Mode Selection --- */


        /* --- Game Area (Responsive) --- */
        #game-area { display: none; width: 100%; }
        /* Changed from flex row to flex column */
        #board-and-panels { display: flex; flex-direction: column; align-items: center; width: 100%; }

        #board {
            width: var(--board-size); height: var(--board-size); /* Use responsive variable */
            display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr);
            border: 2px solid #333; border-bottom: none; /* Remove bottom border, panel below */
            transition: transform 0.5s ease-in-out; box-sizing: border-box;
            background-color: #888; position: relative; /* Needed for animation parent */
            overflow: hidden; /* Hide piece overflow */
            touch-action: none; /* Prevent scrolling/zooming during drag on board */
        }
        #board.board-flipped { transform: rotate(180deg); }

        .square { display: flex; justify-content: center; align-items: center; user-select: none; cursor: pointer; position: relative; transition: background-color 0.15s ease-in-out; background-color: transparent; overflow: hidden; }
        .light { background-color: var(--light-square); } .dark { background-color: var(--dark-square); }
        .board-flipped .square { transform: rotate(180deg); }

        .piece {
            width: 90%; height: 90%; background-size: contain; background-repeat: no-repeat;
            background-position: center; image-rendering: -webkit-optimize-contrast; image-rendering: crisp-edges;
            z-index: 5; cursor: grab; /* Add grab cursor */
            touch-action: none; /* Prevent scroll/zoom when dragging piece */
        }
        .piece.dragging { cursor: grabbing; }
        .piece.piece-ghost { opacity: 0.3; transition: opacity 0.1s ease-out; }
        .piece.hidden-during-move { opacity: 0 !important; transition: none !important; }

        /* Highlights */
        .selected { outline: 3px solid var(--highlight-selected); outline-offset: -3px; background-color: rgba(80, 140, 220, 0.05) !important; }
        .highlight::after { content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 25%; height: 25%; background-color: var(--highlight-move); border-radius: 50%; pointer-events: none; z-index: 1; box-sizing: border-box; }
        .highlight.capture::after { width: 85%; height: 85%; background-color: transparent; border: 5px solid var(--highlight-capture); border-radius: 50%; }
        .check { box-shadow: inset 0 0 10px 5px var(--highlight-check); }
        .last-move-start { background-color: var(--highlight-last-start) !important; } .last-move-end { background-color: var(--highlight-last-end) !important; }
        .drag-over-highlight { background-color: var(--highlight-drag-over) !important; }

        /* Moving Piece Animation */
        .moving-piece {
            background-size: contain; background-repeat: no-repeat; background-position: center;
            image-rendering: -webkit-optimize-contrast; image-rendering: crisp-edges;
            transition: transform var(--animation-speed) ease-in-out;
            touch-action: none; /* Disable touch actions on the animating piece */
        }

        /* --- Sprites referenced from 'sprites' folder --- */
        .wp { background-image: url('sprites/wPawn.png'); }
        .wr { background-image: url('sprites/wRook.png'); }
        .wn { background-image: url('sprites/wKnight.png'); }
        .wb { background-image: url('sprites/wBishop.png'); }
        .wq { background-image: url('sprites/wQueen.png'); }
        .wk { background-image: url('sprites/wKing.png'); }
        .bp { background-image: url('sprites/bPawn.png'); }
        .br { background-image: url('sprites/bRook.png'); }
        .bn { background-image: url('sprites/bKnight.png'); }
        .bb { background-image: url('sprites/bBishop.png'); }
        .bq { background-image: url('sprites/bQueen.png'); }
        .bk { background-image: url('sprites/bKing.png'); }

        /* --- Bottom Panel (Previously Side Panel) --- */
        #bottom-panel {
            width: var(--board-size); /* Match board width */
            background-color: var(--panel-bg);
            padding: 10px;
            /* Add top border to connect visually with board */
            border-top: 2px solid #333;
            border-left: 2px solid #333; /* Keep side borders */
            border-right: 2px solid #333;
            border-bottom: 2px solid #333; /* Add bottom border */
            display: flex;
            flex-direction: column;
            min-height: var(--panel-height-mobile); /* Minimum height */
            height: auto; /* Allow content to determine height */
            box-sizing: border-box;
            color: var(--panel-text);
            margin-top: -2px; /* Overlap slightly to hide board bottom border if needed */
        }

        #status {
            font-size: 1.1em; /* Slightly smaller for mobile */
            font-weight: bold;
            min-height: 1.4em;
            text-align: center;
            margin-bottom: 8px; /* Reduced margin */
            border-bottom: 1px solid var(--panel-border);
            padding-bottom: 8px;
        }

        #captured-heading {
            margin-top: 5px; margin-bottom: 3px; font-size: 0.85em;
            font-weight: normal; text-transform: uppercase; letter-spacing: 0.5px;
            border-bottom: none; padding-bottom: 0; text-align: center;
        }

        #captured-pieces-box {
            background-color: rgba(255, 255, 255, 0.3); border: 1px solid var(--panel-border);
            border-radius: 4px; padding: 6px; margin-bottom: 10px;
            min-height: 48px; /* Adjusted min height */
            max-height: 100px; /* Adjusted max height */
            display: flex; flex-direction: column; justify-content: space-between;
            gap: 4px; overflow-y: auto; flex-grow: 1; /* Allow box to grow */
        }

        .captured-list {
            display: flex; flex-wrap: wrap; gap: 3px; /* Slightly smaller gap */
            min-height: 20px; align-content: flex-start;
        }
        /* Adjust captured piece size */
        .captured-piece {
            width: 20px; height: 20px;
            background-size: contain; background-repeat: no-repeat;
            background-position: center; image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        /* Panel Buttons - Arrange differently for bottom panel */
        #panel-buttons {
            margin-top: auto; /* Push buttons to bottom */
            padding-top: 10px; /* Space above buttons */
            border-top: 1px solid var(--panel-border);
            display: flex;
            flex-wrap: wrap; /* Allow wrapping */
            justify-content: space-around; /* Space out buttons */
            gap: 8px; /* Gap between buttons/rows */
        }

        /* Individual button styling */
        #bottom-panel button {
            padding: 8px 12px; /* Adjust padding */
            font-size: 0.9em; cursor: pointer; border: 1px solid var(--button-border);
            border-radius: 4px; background-color: var(--button-bg); color: var(--button-text);
            transition: background-color 0.2s, opacity 0.2s; text-align: center;
            font-weight: bold;
            flex-basis: calc(50% - 10px); /* Try to fit two buttons per row */
            min-width: 100px; /* Minimum width */
            box-sizing: border-box;
        }

        #bottom-panel button svg {
             width: 14px; height: 14px; vertical-align: middle; fill: currentColor;
        }

        /* Specific button adjustments if needed */
        #quit-button {
             flex-basis: 100%; /* Make quit button take full width */
             margin-top: 5px;
        }

        #bottom-panel button:hover:not(:disabled) { background-color: var(--button-bg-hover); }
        #bottom-panel button:disabled {
            background-color: rgba(181, 136, 99, 0.4); color: #eaddcf;
            cursor: not-allowed; border-color: rgba(181, 136, 99, 0.5); opacity: 0.7;
        }

        /* Fullscreen Icons */
        #fullscreen-button #fs-exit-icon { display: none; }
        #fullscreen-button.active #fs-enter-icon { display: none; }
        #fullscreen-button.active #fs-exit-icon { display: inline-block; }

        /* Computer Thinking State */
        body.computer-thinking #board { cursor: wait; }
        body.computer-thinking .square { pointer-events: none !important; }
        body.computer-thinking .piece { cursor: wait !important; }
        body.computer-thinking #undo-button,
        body.computer-thinking #fullscreen-button { pointer-events: none; opacity: 0.5; cursor: wait; }

        /* --- Game Over Modal Styles (Responsive) --- */
        .modal-overlay {
            position: fixed; /* Fixed position to overlay everything */
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Darker backdrop */
            display: none; /* Hidden by default */
            justify-content: center; align-items: center;
            z-index: 2000; /* Ensure it's above everything else */
            opacity: 0; transition: opacity 0.3s ease-in-out;
            padding: 15px; /* Padding for smaller screens */
            box-sizing: border-box;
        }

        .modal-overlay.visible {
            display: flex; /* Show when visible */
            opacity: 1;
        }

        .modal-content {
            background-color: var(--panel-bg); /* Use panel background color */
            padding: 25px 30px; /* Adjusted padding */
            border-radius: 8px; border: 2px solid var(--dark-square); /* Match board border */
            text-align: center; color: var(--panel-text); /* Use panel text color */
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
            max-width: 350px; /* Slightly reduced max-width */
            width: 95%; /* Responsive width */
            transform: scale(0.9);
            transition: transform 0.3s ease-in-out;
        }

        .modal-overlay.visible .modal-content {
            transform: scale(1.0); /* Scale in animation */
        }

        #modal-title {
            color: var(--dark-square); /* Use dark square color for title */
            margin-top: 0; margin-bottom: 15px;
            font-size: 1.6em; /* Slightly smaller title */
            font-weight: bold;
        }

        #modal-message {
            margin-bottom: 25px; /* Adjusted space before button */
            font-size: 1.1em; /* Adjusted font size */
            line-height: 1.5;
        }

        #new-game-button {
            /* Style like the main start button */
            padding: 12px 30px; font-size: 1.1em; cursor: pointer;
            background-color: var(--button-bg); color: var(--button-text);
            border: 1px solid var(--button-border); border-radius: 5px;
            transition: background-color 0.2s; font-weight: bold;
            display: inline-block; /* Ensure button behaves correctly */
        }
        #new-game-button:hover { background-color: var(--button-bg-hover); }
        /* --- End Game Over Modal Styles --- */

         /* Media Query for smaller screens (fine-tuning) */
        @media (max-width: 400px) {
            :root {
                 --board-size: 92vw; /* Slightly larger board relative to viewport */
            }
            #mode-selection h2 { font-size: 1.3em; }
            .mode-type-selection button { font-size: 0.95em; padding: 8px 12px; }
            #difficulty-choice button { width: 100px; font-size: 0.85em; padding: 5px 10px;}
            .side-option img { width: 30px; height: 30px;}
            #start-game-button { font-size: 1em; padding: 10px 25px;}

            #status { font-size: 1em; }
            #captured-heading { font-size: 0.8em; }
            .captured-piece { width: 18px; height: 18px; }
            #bottom-panel button { font-size: 0.85em; padding: 7px 10px; min-width: 80px;}
            #modal-title { font-size: 1.5em; }
            #modal-message { font-size: 1em; }
            #new-game-button { font-size: 1em; padding: 10px 25px;}
        }

    </style>
</head>
<body>
    <div id="game-container">
        <!-- Mode Selection -->
        <div id="mode-selection">
             <h2>Orcs vs Humans Chess</h2>
             <div class="mode-type-selection">
                 <button id="mode-cpu">1 Player</button>
                 <button id="mode-2p">2 Player</button>
             </div>
             <div id="cpu-options-container">
                 <div id="difficulty-choice">
                     <h3>Select Difficulty:</h3>
                     <button data-difficulty="CPU-easy">Easy</button>
                     <button data-difficulty="CPU-medium">Medium</button>
                     <button data-difficulty="CPU-hard">Hard</button>
                 </div>
                 <div id="player-side-choice">
                     <h3>Choose your side:</h3>
                     <!-- ** Ensure these image paths are correct ** -->
                     <div class="side-option selected" id="side-human">
                         <input type="radio" name="playerSide" value="w" id="radio-human" checked>
                         <img src="sprites/wKing.png" alt="Human King">
                         <label for="radio-human">Human</label>
                     </div>
                     <div class="side-option" id="side-orc">
                         <input type="radio" name="playerSide" value="b" id="radio-orc">
                         <img src="sprites/bKing.png" alt="Orc King">
                         <label for="radio-orc">Orc</label>
                     </div>
                 </div>
             </div>
             <div id="start-button-container">
                 <button id="start-game-button" onclick="startGame()" disabled>Play</button>
             </div>
        </div> <!-- End mode-selection -->


        <div id="game-area">
             <div id="board-and-panels">
                 <div id="board"></div>
                 <!-- Renamed from side-panel to bottom-panel -->
                 <div id="bottom-panel">
                     <div id="status">Game Status</div>
                     <h3 id="captured-heading">Captured</h3>
                     <div id="captured-pieces-box">
                         <div id="white-captured" class="captured-list"></div>
                         <div id="black-captured" class="captured-list"></div>
                     </div>
                     <div id="panel-buttons">
                         <!-- Buttons are now here, structure might need adjustment based on desired layout -->
                         <button id="undo-button" onclick="undoMove()" title="Undo Last Move">
                             Undo
                         </button>
                         <button id="fullscreen-button" onclick="toggleFullScreen()" title="Toggle Fullscreen">
                             <svg id="fs-enter-icon" viewBox="0 0 24 24" style="width: 1em; height: 1em; vertical-align: middle; fill: currentColor;"> <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/> </svg>
                             <svg id="fs-exit-icon" viewBox="0 0 24 24" style="width: 1em; height: 1em; vertical-align: middle; fill: currentColor;"> <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/> </svg>
                             <span style="vertical-align: middle;"> Fullscreen</span> <!-- Added text label -->
                         </button>
                         <button id="quit-button" onclick="quitGame()">Quit</button>
                     </div>
                 </div> <!-- End bottom-panel -->
             </div>
        </div> <!-- End game-area -->

        <!-- Game Over Modal HTML (Remains the same) -->
        <div id="game-over-modal" class="modal-overlay">
            <div class="modal-content">
                <h2 id="modal-title">Game Over!</h2>
                <p id="modal-message">Someone won!</p>
                <button id="new-game-button">Play Again</button>
            </div>
        </div>

    </div> <!-- End game-container -->

    <script>
        // --- DOM Element References ---
        const gameContainer = document.getElementById('game-container');
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        const modeSelectionElement = document.getElementById('mode-selection');
        const gameAreaElement = document.getElementById('game-area');
        // Reference the new bottom panel
        const bottomPanel = document.getElementById('bottom-panel'); // Added
        const whiteCapturedElement = document.getElementById('white-captured');
        const blackCapturedElement = document.getElementById('black-captured');
        // Get buttons from the bottom panel now
        const undoButton = document.getElementById('undo-button'); // Now inside bottom-panel
        const quitButton = document.getElementById('quit-button'); // Now inside bottom-panel
        const fullscreenButton = document.getElementById('fullscreen-button'); // Now inside bottom-panel
        // Mode selection elements remain the same
        const mode2pButton = document.getElementById('mode-2p');
        const modeCpuButton = document.getElementById('mode-cpu');
        const cpuOptionsContainer = document.getElementById('cpu-options-container');
        const difficultyChoiceDiv = document.getElementById('difficulty-choice');
        const difficultyButtons = difficultyChoiceDiv ? difficultyChoiceDiv.querySelectorAll('button') : [];
        const playerSideChoiceDiv = document.getElementById('player-side-choice');
        const sideOptions = document.querySelectorAll('.side-option');
        const startGameButton = document.getElementById('start-game-button');
        // Modal Element References remain the same
        const gameOverModal = document.getElementById('game-over-modal');
        const modalTitleElement = document.getElementById('modal-title');
        const modalMessageElement = document.getElementById('modal-message');
        const newGameButton = document.getElementById('new-game-button');

        // --- Game State Variables ---
        let board = []; let currentPlayer = 'w'; let playerColor = 'w'; let gameMode = null;
        let selectedSquare = null; // For click-move
        let currentlyDragging = { // For drag-move (including touch)
             pieceElement: null,
             startRow: -1,
             startCol: -1,
             pieceCode: null,
             validMoves: [],
             isDragging: false, // Flag specific to drag events
             touchIdentifier: null, // Store touch ID
             offsetX: 0, // For positioning ghost element during touch drag
             offsetY: 0,
             ghostElement: null // Element being dragged visually (clone)
        };
        let validMoves = []; // Combined usage, updated by both click & drag start
        let whiteKingPos = null; let blackKingPos = null;
        let isWhiteInCheck = false; let isBlackInCheck = false;
        let isComputerTurn = false;
        let gameOver = false; let capturedPieces = { w: [], b: [] }; let lastMove = { start: null, end: null };
        let moveHistory = [];
        let isAnimating = false; // Flag to prevent interactions during animation

        // --- Constants ---
        const pieceValues = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 1000 };
        const initialBoard = [
            ['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'],
            ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'],
            ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr']
        ];
        const pieceOrder = { p: 1, n: 2, b: 3, r: 4, q: 5 };
        const ANIMATION_DURATION_MS = 300; // Match CSS --animation-speed (in milliseconds)

        // --- Mode Selection Logic ---
        let selectedDifficulty = null; let selectedModeType = null;

        function updateStartButtonState() {
            let ready = false;
            if (selectedModeType === '2P') {
                ready = true;
            } else if (selectedModeType === 'CPU' && selectedDifficulty) {
                ready = true;
            }
            if(startGameButton) startGameButton.disabled = !ready;
        }

        function setupModeSelectionListeners() {
             if (!mode2pButton || !modeCpuButton || !cpuOptionsContainer || !difficultyChoiceDiv || !playerSideChoiceDiv || !startGameButton || difficultyButtons.length === 0 || sideOptions.length === 0) {
                console.error("CRITICAL ERROR: One or more mode selection elements not found!");
                return;
            }
            mode2pButton.addEventListener('click', () => { selectedModeType = '2P'; gameMode = '2P'; selectedDifficulty = null; cpuOptionsContainer.style.display = 'flex'; cpuOptionsContainer.classList.add('options-disabled'); modeCpuButton.classList.remove('selected'); mode2pButton.classList.add('selected'); difficultyButtons.forEach(btn => btn.classList.remove('selected')); updateStartButtonState(); });
            modeCpuButton.addEventListener('click', () => { selectedModeType = 'CPU'; gameMode = null; cpuOptionsContainer.style.display = 'flex'; cpuOptionsContainer.classList.remove('options-disabled'); mode2pButton.classList.remove('selected'); modeCpuButton.classList.add('selected'); const easyButton = difficultyChoiceDiv.querySelector('[data-difficulty="CPU-easy"]'); if (easyButton && !selectedDifficulty) { easyButton.click(); } else if (!selectedDifficulty) { selectedDifficulty = 'CPU-easy'; gameMode = 'CPU-easy'; difficultyButtons.forEach(btn => btn.classList.remove('selected')); if(easyButton) easyButton.classList.add('selected'); updateStartButtonState(); } const humanSideOption = playerSideChoiceDiv.querySelector('#side-human'); const humanRadio = humanSideOption ? humanSideOption.querySelector('input[type="radio"]') : null; if (humanSideOption && humanRadio && !humanSideOption.classList.contains('selected')) { sideOptions.forEach(opt => opt.classList.remove('selected')); humanSideOption.classList.add('selected'); humanRadio.checked = true; } else if (!humanSideOption || !humanRadio) { console.error("Human side option/radio not found!"); } });
            difficultyButtons.forEach(button => { button.addEventListener('click', () => { selectedDifficulty = button.getAttribute('data-difficulty'); gameMode = selectedDifficulty; difficultyButtons.forEach(btn => btn.classList.remove('selected')); button.classList.add('selected'); updateStartButtonState(); }); });
            sideOptions.forEach(option => { option.addEventListener('click', () => { const radio = option.querySelector('input[type="radio"]'); if (radio && !cpuOptionsContainer.classList.contains('options-disabled')) { radio.checked = true; sideOptions.forEach(opt => opt.classList.remove('selected')); option.classList.add('selected'); } }); });
            document.getElementById('side-human').classList.add('selected'); updateStartButtonState();
        }

        function startGame() {
            console.log("startGame called"); if (!gameMode) { alert("Please select '2 Player' or choose a '1 Player' difficulty."); return; } if (gameMode !== '2P') { const selectedSideRadio = document.querySelector('input[name="playerSide"]:checked'); playerColor = selectedSideRadio ? selectedSideRadio.value : 'w'; } else { playerColor = 'w'; } console.log(`[SETUP] Starting game. Mode: ${gameMode}, Player Side (if CPU): ${playerColor}`); if (modeSelectionElement) modeSelectionElement.style.display = 'none'; if (gameAreaElement) gameAreaElement.style.display = 'block'; else { console.error("gameAreaElement not found!"); return; }
            setupBoard();
        }

        // --- Core Game Functions ---
        function setupBoard() {
            console.log("[SETUP] Initializing game state..."); board = JSON.parse(JSON.stringify(initialBoard)); currentPlayer = 'w'; selectedSquare = null; resetDraggingState(); validMoves = []; whiteKingPos = findKingOnBoard('w', board); blackKingPos = findKingOnBoard('b', board); if (!whiteKingPos || !blackKingPos) { console.error("Kings not found!"); return; } isWhiteInCheck = false; isBlackInCheck = false; isComputerTurn = (gameMode !== '2P' && playerColor === 'b'); gameOver = false; capturedPieces = { w: [], b: [] }; lastMove = { start: null, end: null }; moveHistory = []; isAnimating = false; document.body.classList.remove('computer-thinking'); hideGameOverModal(); /* Ensure modal is hidden on new game */ if (boardElement) boardElement.classList.toggle('board-flipped', playerColor === 'b' && gameMode !== '2P'); saveState(); renderBoard(); renderCapturedPieces(); updateStatus(); updateUndoButton(); console.log(`[SETUP] Game ready. Player: ${playerColor}. Turn: ${currentPlayer}. CompTurn? ${isComputerTurn}`); if (isComputerTurn) { if (statusElement) statusElement.textContent = `CPU thinking...`; document.body.classList.add('computer-thinking'); setTimeout(makeComputerMove, 750); }
        }

        function findKingOnBoard(kingColor, currentBoard) { for(let r=0; r<8; r++){ for(let c=0; c<8; c++){ if(currentBoard[r][c] === kingColor + 'k'){ return {row: r, col: c}; } } } console.error(`!!! King ${kingColor}k not found!`); return null; }
        function saveState() { const state = { board: JSON.parse(JSON.stringify(board)), currentPlayer: currentPlayer, isWhiteInCheck: isWhiteInCheck, isBlackInCheck: isBlackInCheck, capturedPieces: JSON.parse(JSON.stringify(capturedPieces)), whiteKingPos: whiteKingPos ? { ...whiteKingPos } : null, blackKingPos: blackKingPos ? { ...blackKingPos } : null, lastMove: lastMove ? { start: lastMove.start ? { ...lastMove.start } : null, end: lastMove.end ? { ...lastMove.end } : null } : { start: null, end: null } }; moveHistory.push(state); /* console.log("State saved. History:", moveHistory.length); */ }
        function undoMove() { console.log("[UNDO] Attempting undo..."); if (gameOver || document.body.classList.contains('computer-thinking') || isAnimating) { console.log("[UNDO] Blocked."); return; } let movesToUndo = 1; const wasPlayerMoveLast = (gameMode !== '2P' && currentPlayer !== playerColor); if (gameMode !== '2P' && wasPlayerMoveLast && moveHistory.length >= 3) { movesToUndo = 2; } else if (moveHistory.length < 2) { console.log("[UNDO] Blocked (not enough history)."); return; } console.log(`[UNDO] Undoing ${movesToUndo} move(s).`); if (moveHistory.length - movesToUndo <= 0) { console.log("[UNDO] Blocked (cannot undo initial state)."); return; } for (let i = 0; i < movesToUndo; i++) { moveHistory.pop(); } const prevState = moveHistory[moveHistory.length - 1]; if (!prevState) { console.error("[UNDO] Error: No previous state!"); setupBoard(); return; } board = JSON.parse(JSON.stringify(prevState.board)); currentPlayer = prevState.currentPlayer; isWhiteInCheck = prevState.isWhiteInCheck; isBlackInCheck = prevState.isBlackInCheck; capturedPieces = JSON.parse(JSON.stringify(prevState.capturedPieces)); whiteKingPos = prevState.whiteKingPos ? { ...prevState.whiteKingPos } : null; blackKingPos = prevState.blackKingPos ? { ...prevState.blackKingPos } : null; lastMove = prevState.lastMove ? { start: prevState.lastMove.start ? { ...prevState.lastMove.start } : null, end: prevState.lastMove.end ? { ...prevState.end } : null } : { start: null, end: null }; isComputerTurn = (gameMode !== '2P' && currentPlayer !== playerColor); gameOver = false; console.log(`[UNDO] State restored to turn: ${currentPlayer}.`); selectedSquare = null; resetDraggingState(); validMoves = []; document.body.classList.remove('computer-thinking'); renderBoard(); renderCapturedPieces(); updateStatus(); updateUndoButton(); if (isComputerTurn) { console.warn("[UNDO] Computer's turn after undo?"); document.body.classList.add('computer-thinking'); setTimeout(makeComputerMove, 500); } }
        function updateUndoButton() { if (!undoButton) return; let canUndo = moveHistory.length > 1; undoButton.disabled = !canUndo || document.body.classList.contains('computer-thinking') || gameOver || isAnimating; }
        function renderCapturedPieces() { if (!whiteCapturedElement || !blackCapturedElement) return; const sortAndRender = (listElement, piecesArray) => { listElement.innerHTML = ''; const sortedPieces = [...piecesArray].sort((a, b) => (pieceOrder[a[1]] || 0) - (pieceOrder[b[1]] || 0)); sortedPieces.forEach(pieceCode => { const pieceElement = document.createElement('div'); pieceElement.className = `captured-piece ${pieceCode}`; listElement.appendChild(pieceElement); }); }; sortAndRender(whiteCapturedElement, capturedPieces.b); sortAndRender(blackCapturedElement, capturedPieces.w); }
        function renderBoard() { if (!boardElement) return; boardElement.innerHTML = ''; const oldMovingPiece = gameContainer.querySelector('.moving-piece'); if (oldMovingPiece) oldMovingPiece.remove(); boardElement.classList.toggle('board-flipped', playerColor === 'b' && gameMode !== '2P'); if (!board || board.length !== 8) return; for (let r = 0; r < 8; r++) { for (let c = 0; c < 8; c++) { try { const square = document.createElement('div'); square.className = `square ${(r + c) % 2 === 0 ? 'light' : 'dark'}`; square.dataset.row = r; square.dataset.col = c; const pieceCode = board[r][c]; if (pieceCode) { const pieceElement = document.createElement('div'); pieceElement.className = `piece ${pieceCode}`; pieceElement.draggable = true; // Keep draggable for desktop
                     square.appendChild(pieceElement);
                     // Add listeners for both mouse and touch
                     pieceElement.addEventListener('dragstart', handleDragStart);
                     pieceElement.addEventListener('dragend', handleDragEnd);
                     pieceElement.addEventListener('touchstart', handleTouchStart, { passive: false }); // passive:false to allow preventDefault
                 }
                 // Add listeners to the square itself
                 square.addEventListener('click', handleSquareClick);
                 square.addEventListener('dragover', handleDragOver);
                 square.addEventListener('dragleave', handleDragLeave);
                 square.addEventListener('drop', handleDrop);
                 // Touch listeners on the square for dropping
                 square.addEventListener('touchmove', handleTouchMove, { passive: false });
                 square.addEventListener('touchend', handleTouchEnd);
                 square.addEventListener('touchcancel', handleTouchEnd); // Treat cancel like end

                 if ((pieceCode === 'wk' && isWhiteInCheck) || (pieceCode === 'bk' && isBlackInCheck)) { square.classList.add('check'); }
                 if (lastMove.start && lastMove.start.row === r && lastMove.start.col === c) square.classList.add('last-move-start');
                 if (lastMove.end && lastMove.end.row === r && lastMove.end.col === c) square.classList.add('last-move-end');
                 boardElement.appendChild(square); } catch (error) { console.error(`Render err @ ${r},${c}:`, error); } } } if (selectedSquare) { const selEl = getSquareElement(selectedSquare.row, selectedSquare.col); if (selEl) { selEl.classList.add('selected'); highlightValidMoves(); } else { selectedSquare = null; validMoves = []; } } else { removeMoveHighlights(); }

             // Add global touch listeners needed for dragging outside the starting square
             document.removeEventListener('touchmove', handleTouchMove, { passive: false }); // Remove first to avoid duplicates
             document.addEventListener('touchmove', handleTouchMove, { passive: false });
             document.removeEventListener('touchend', handleTouchEnd);
             document.addEventListener('touchend', handleTouchEnd);
             document.removeEventListener('touchcancel', handleTouchEnd);
             document.addEventListener('touchcancel', handleTouchEnd);
        }

        // Modal Management Functions (Remain the same)
        function showGameOverModal(title, message) { if (!gameOverModal || !modalTitleElement || !modalMessageElement) return; modalTitleElement.textContent = title; modalMessageElement.textContent = message; gameOverModal.classList.add('visible'); }
        function hideGameOverModal() { if (!gameOverModal) return; gameOverModal.classList.remove('visible'); }

        // --- Event Handlers (Click, Drag & Drop, Touch) ---

        // --- CLICK ---
        function handleSquareClick(event) {
             // Prevent click logic if a drag operation just finished on this square
             if (currentlyDragging.isDragging || isAnimating) {
                 // console.log("Click blocked during/after drag or animation");
                 return;
             }

             if (gameOver || document.body.classList.contains('computer-thinking')) return;

             const isPlayerTurn = (gameMode === '2P' || currentPlayer === playerColor);
             if (!isPlayerTurn) return;

             const squareElement = event.currentTarget;
             const row = parseInt(squareElement.dataset.row);
             const col = parseInt(squareElement.dataset.col);
             const pieceOnSquare = board[row][col];

             if (selectedSquare) { // A piece was already selected
                 const startRow = selectedSquare.row;
                 const startCol = selectedSquare.col;
                 const targetMove = validMoves.find(move => move.row === row && move.col === col);

                 if (targetMove) { // Clicked on a valid move destination
                     initiateMove(startRow, startCol, row, col);
                     return; // Move initiated, exit
                 }

                 // Clicked somewhere else - deselect or select new piece
                 removePieceSelectionHighlight();
                 removeMoveHighlights();
                 selectedSquare = null;
                 validMoves = [];

                 if (pieceOnSquare && pieceOnSquare.startsWith(currentPlayer)) {
                     // Clicked on another of own pieces, select it
                     selectPiece(row, col, pieceOnSquare);
                 }
                 // If clicked on empty or opponent piece after selection, just deselect (done above)

             } else { // No piece currently selected
                 if (pieceOnSquare && pieceOnSquare.startsWith(currentPlayer)) {
                     // Clicked on own piece, select it
                     selectPiece(row, col, pieceOnSquare);
                 }
             }
         }

        // --- DRAG & DROP (Mouse) ---
        function handleDragStart(event) {
            if (gameOver || document.body.classList.contains('computer-thinking') || isAnimating) { event.preventDefault(); return; }

            const pieceElement = event.target;
            const squareElement = pieceElement.closest('.square');
            if (!squareElement) return;

            const startRow = parseInt(squareElement.dataset.row);
            const startCol = parseInt(squareElement.dataset.col);
            const pieceCode = board[startRow][startCol];
            const isPlayerTurn = (gameMode === '2P' || currentPlayer === playerColor);

            if (!pieceCode || !pieceCode.startsWith(currentPlayer) || !isPlayerTurn) {
                event.preventDefault(); return;
            }

            // If a piece was selected via click, deselect it first
            removePieceSelectionHighlight();
            selectedSquare = null;

            currentlyDragging.isDragging = true; // Mark drag start
            currentlyDragging.pieceElement = pieceElement;
            currentlyDragging.startRow = startRow;
            currentlyDragging.startCol = startCol;
            currentlyDragging.pieceCode = pieceCode;
            currentlyDragging.validMoves = calculateValidMoves(startRow, startCol, pieceCode);
            validMoves = currentlyDragging.validMoves; // Share valid moves

            event.dataTransfer.effectAllowed = 'move';
            // Use a minimal data payload, necessary for Firefox drag ops
            try { event.dataTransfer.setData('text/plain', pieceCode); } catch(e) { console.warn("Could not set drag data:", e)}

            // Create a custom drag image (ghost) - OPTIONAL but good UX
            const dragImage = pieceElement.cloneNode(true);
            const originalRect = pieceElement.getBoundingClientRect();
            dragImage.style.width = `${originalRect.width}px`;
            dragImage.style.height = `${originalRect.height}px`;
            dragImage.style.position = "absolute";
            dragImage.style.top = "-9999px"; // Position off-screen initially
            dragImage.style.left = "-9999px";
            dragImage.style.opacity = '0.8'; // Make it slightly transparent
            dragImage.style.pointerEvents = 'none'; // Prevent interference
            document.body.appendChild(dragImage);
             // Center the ghost under the cursor
            const offsetX = originalRect.width / 2;
            const offsetY = originalRect.height / 2;
            // Set the custom drag image
            try{ event.dataTransfer.setDragImage(dragImage, offsetX, offsetY); } catch(e) {console.warn("Could not set drag image", e)}
            // Cleanup ghost image shortly after drag starts
            setTimeout(() => { if (dragImage.parentNode) dragImage.parentNode.removeChild(dragImage); }, 1);

            // Make original piece semi-transparent *slightly* later
            setTimeout(() => {
                if (currentlyDragging.pieceElement === pieceElement && currentlyDragging.isDragging) {
                   pieceElement.classList.add('piece-ghost');
                }
            }, 0);

            pieceElement.classList.add('dragging'); // Maybe style the original differently
            highlightValidMoves();
        }

        function handleDragOver(event) {
            event.preventDefault(); // Necessary to allow dropping
            if (!currentlyDragging.isDragging) return;

            const squareElement = event.currentTarget;
            // Maybe add highlight effect on valid drop targets
            const row = parseInt(squareElement.dataset.row);
            const col = parseInt(squareElement.dataset.col);
            const isValidTarget = currentlyDragging.validMoves.some(move => move.row === row && move.col === col);

            if (isValidTarget) {
                event.dataTransfer.dropEffect = 'move';
                squareElement.classList.add('drag-over-highlight');
            } else {
                event.dataTransfer.dropEffect = 'none';
                squareElement.classList.remove('drag-over-highlight');
            }
        }

        function handleDragLeave(event) {
            const squareElement = event.currentTarget;
            squareElement.classList.remove('drag-over-highlight');
        }

        function handleDrop(event) {
            event.preventDefault();
            if (!currentlyDragging.isDragging || isAnimating) return;

            const squareElement = event.currentTarget;
            squareElement.classList.remove('drag-over-highlight'); // Clean up highlight

            const endRow = parseInt(squareElement.dataset.row);
            const endCol = parseInt(squareElement.dataset.col);
            const startRow = currentlyDragging.startRow;
            const startCol = currentlyDragging.startCol;

            const isValidDrop = currentlyDragging.validMoves.some(move => move.row === endRow && move.col === endCol);

            if (isValidDrop) {
                console.log(`[DRAG] Dropped ${currentlyDragging.pieceCode} from ${startRow},${startCol} to ${endRow},${endCol}`);
                // Make the move visually and logically
                initiateMove(startRow, startCol, endRow, endCol);
            } else {
                console.log(`[DRAG] Invalid drop at ${endRow},${endCol}`);
                // No move happens, dragEnd will clean up visuals
            }
            // Let dragEnd handle the rest of the cleanup
        }

        function handleDragEnd(event) {
            // This event fires on the source element after drop or cancel
            if (!currentlyDragging.isDragging) return;

            const draggedElement = currentlyDragging.pieceElement; // Use stored reference

            // Clean up visual styles
            if (draggedElement) {
                draggedElement.classList.remove('piece-ghost', 'dragging');
            }
            document.querySelectorAll('.piece-ghost').forEach(el => el.classList.remove('piece-ghost')); // Just in case
            document.querySelectorAll('.drag-over-highlight').forEach(el => el.classList.remove('drag-over-highlight'));
            removeMoveHighlights();

            // Reset dragging state *after* potential drop logic has run
            resetDraggingState();
         }


        // --- TOUCH Events ---
        function handleTouchStart(event) {
            if (gameOver || document.body.classList.contains('computer-thinking') || isAnimating || currentlyDragging.isDragging) {
                 // Don't start a new touch drag if already dragging (mouse or touch)
                 return;
            }
            // Prevent multi-touch conflicts
            if (currentlyDragging.touchIdentifier !== null) return;

            const pieceElement = event.target.closest('.piece'); // Ensure we target the piece div
             if (!pieceElement) return;

            const squareElement = pieceElement.closest('.square');
            if (!squareElement) return;

            const startRow = parseInt(squareElement.dataset.row);
            const startCol = parseInt(squareElement.dataset.col);
            const pieceCode = board[startRow][startCol];
            const isPlayerTurn = (gameMode === '2P' || currentPlayer === playerColor);

            if (!pieceCode || !pieceCode.startsWith(currentPlayer) || !isPlayerTurn) {
                return;
            }

            event.preventDefault(); // Prevent scrolling/zooming while dragging piece

            // If a piece was selected via click, deselect it
            removePieceSelectionHighlight();
            selectedSquare = null;

            const touch = event.changedTouches[0];
            currentlyDragging.touchIdentifier = touch.identifier; // Store which finger is dragging

            currentlyDragging.isDragging = true; // Mark drag start
            currentlyDragging.pieceElement = pieceElement;
            currentlyDragging.startRow = startRow;
            currentlyDragging.startCol = startCol;
            currentlyDragging.pieceCode = pieceCode;
            currentlyDragging.validMoves = calculateValidMoves(startRow, startCol, pieceCode);
            validMoves = currentlyDragging.validMoves;

            // --- Create visual ghost for touch ---
            const rect = pieceElement.getBoundingClientRect();
            currentlyDragging.ghostElement = pieceElement.cloneNode(true);
            currentlyDragging.ghostElement.style.position = 'absolute';
            currentlyDragging.ghostElement.style.width = `${rect.width}px`;
            currentlyDragging.ghostElement.style.height = `${rect.height}px`;
            currentlyDragging.ghostElement.style.pointerEvents = 'none'; // Ignore pointer events
            currentlyDragging.ghostElement.style.zIndex = '1010'; // Above board pieces
            currentlyDragging.ghostElement.style.opacity = '0.8';
             // Calculate offset from touch point to top-left of piece
            currentlyDragging.offsetX = touch.clientX - rect.left;
            currentlyDragging.offsetY = touch.clientY - rect.top;
            // Position the ghost initially
            currentlyDragging.ghostElement.style.left = `${touch.clientX - currentlyDragging.offsetX}px`;
            currentlyDragging.ghostElement.style.top = `${touch.clientY - currentlyDragging.offsetY}px`;

            document.body.appendChild(currentlyDragging.ghostElement); // Add ghost to body

            // Make original piece transparent
            pieceElement.classList.add('piece-ghost');

            highlightValidMoves();
            // console.log(`Touch Start: ${pieceCode} at ${startRow},${startCol}`);
        }

        function handleTouchMove(event) {
             if (!currentlyDragging.isDragging || currentlyDragging.touchIdentifier === null) return;

             // Find the touch associated with this drag operation
             let currentTouch = null;
             for (let i = 0; i < event.changedTouches.length; i++) {
                 if (event.changedTouches[i].identifier === currentlyDragging.touchIdentifier) {
                     currentTouch = event.changedTouches[i];
                     break;
                 }
             }
             if (!currentTouch) return; // Not the finger we're tracking

             event.preventDefault(); // Prevent scroll/zoom

             // Move the ghost element
             if (currentlyDragging.ghostElement) {
                 currentlyDragging.ghostElement.style.left = `${currentTouch.clientX - currentlyDragging.offsetX}px`;
                 currentlyDragging.ghostElement.style.top = `${currentTouch.clientY - currentlyDragging.offsetY}px`;
             }

             // Highlight square under the touch point
             const elementUnderTouch = document.elementFromPoint(currentTouch.clientX, currentTouch.clientY);
             const squareElement = elementUnderTouch ? elementUnderTouch.closest('.square') : null;

             // Remove previous drag-over highlights
             document.querySelectorAll('.drag-over-highlight').forEach(el => el.classList.remove('drag-over-highlight'));

             if (squareElement) {
                 const row = parseInt(squareElement.dataset.row);
                 const col = parseInt(squareElement.dataset.col);
                 const isValidTarget = currentlyDragging.validMoves.some(move => move.row === row && move.col === col);
                 if (isValidTarget) {
                     squareElement.classList.add('drag-over-highlight');
                 }
             }
         }

         function handleTouchEnd(event) {
             if (!currentlyDragging.isDragging || currentlyDragging.touchIdentifier === null) return;

             // Find the touch associated with this drag operation ending
             let endedTouch = null;
             for (let i = 0; i < event.changedTouches.length; i++) {
                 if (event.changedTouches[i].identifier === currentlyDragging.touchIdentifier) {
                     endedTouch = event.changedTouches[i];
                     break;
                 }
             }
             if (!endedTouch) return; // Not the finger we were tracking

             // Remove ghost element
             if (currentlyDragging.ghostElement && currentlyDragging.ghostElement.parentNode) {
                 currentlyDragging.ghostElement.parentNode.removeChild(currentlyDragging.ghostElement);
             }

             // Determine the square where the touch ended
             const elementUnderTouch = document.elementFromPoint(endedTouch.clientX, endedTouch.clientY);
             const squareElement = elementUnderTouch ? elementUnderTouch.closest('.square') : null;

             let droppedOnValidSquare = false;
             if (squareElement && !isAnimating) {
                 const endRow = parseInt(squareElement.dataset.row);
                 const endCol = parseInt(squareElement.dataset.col);
                 const startRow = currentlyDragging.startRow;
                 const startCol = currentlyDragging.startCol;

                 const isValidDrop = currentlyDragging.validMoves.some(move => move.row === endRow && move.col === endCol);

                 if (isValidDrop) {
                     console.log(`[TOUCH] Dropped ${currentlyDragging.pieceCode} from ${startRow},${startCol} to ${endRow},${endCol}`);
                     initiateMove(startRow, startCol, endRow, endCol);
                     droppedOnValidSquare = true;
                 } else {
                     console.log(`[TOUCH] Invalid drop at ${endRow},${endCol}`);
                 }
             }

             // --- Cleanup ---
             if (currentlyDragging.pieceElement) {
                 currentlyDragging.pieceElement.classList.remove('piece-ghost');
             }
             document.querySelectorAll('.drag-over-highlight').forEach(el => el.classList.remove('drag-over-highlight'));
             removeMoveHighlights();
             resetDraggingState(); // Reset state AFTER potential move initiation

             // If dropped outside or on invalid square, the piece visually snaps back because renderBoard() isn't called with a changed board state after resetDraggingState() handles visual cleanup.
         }


        // --- Common Dragging Reset ---
        function resetDraggingState() {
             // Reset mouse/touch drag state
             if(currentlyDragging.ghostElement && currentlyDragging.ghostElement.parentNode) {
                currentlyDragging.ghostElement.parentNode.removeChild(currentlyDragging.ghostElement);
             }
             if(currentlyDragging.pieceElement) {
                 currentlyDragging.pieceElement.classList.remove('piece-ghost', 'dragging');
             }
             currentlyDragging.pieceElement = null;
             currentlyDragging.startRow = -1;
             currentlyDragging.startCol = -1;
             currentlyDragging.pieceCode = null;
             currentlyDragging.validMoves = [];
             currentlyDragging.isDragging = false;
             currentlyDragging.touchIdentifier = null;
             currentlyDragging.ghostElement = null;
             currentlyDragging.offsetX = 0;
             currentlyDragging.offsetY = 0;
         }

        // --- Move Execution and Animation ---
        function initiateMove(startRow, startCol, endRow, endCol) {
            if (isAnimating) return;
            console.log(`[MOVE] Initiating: ${startRow},${startCol} -> ${endRow},${endCol}`);
            isAnimating = true;
            updateUndoButton(); // Disable undo during animation

            const pieceCode = board[startRow][startCol];
            const startSquareEl = getSquareElement(startRow, startCol);
            const endSquareEl = getSquareElement(endRow, endCol);

            // Deselect piece if it was click-selected
            removePieceSelectionHighlight();
            selectedSquare = null;
            removeMoveHighlights(); // Clean highlights before animation

            animateMove(startSquareEl, endSquareEl, pieceCode, () => {
                // --- Actions *after* animation completes ---
                makeMove(startRow, startCol, endRow, endCol); // Update logical board
                saveState(); // Save the new state
                // selectedSquare = null; // Already cleared
                resetDraggingState(); // Ensure drag state is fully reset
                validMoves = []; // Clear valid moves list

                switchPlayer(); // Switch player, check game state, potentially trigger CPU

                isAnimating = false; // Re-enable interactions
                updateUndoButton(); // Re-evaluate undo button state
            });
        }

        function animateMove(startSquareEl, endSquareEl, pieceCode, onCompleteCallback) {
            if (!startSquareEl || !endSquareEl || !pieceCode || !boardElement || !gameContainer) {
                console.error("Animation error: Missing elements.");
                if (onCompleteCallback) onCompleteCallback();
                return;
            }

            const boardRect = boardElement.getBoundingClientRect();
            const startRect = startSquareEl.getBoundingClientRect();
            const endRect = endSquareEl.getBoundingClientRect();

            const pieceElToHide = startSquareEl.querySelector('.piece'); // The original piece element

            // Create the visual piece that will move
            const movingPiece = document.createElement('div');
            movingPiece.className = `moving-piece ${pieceCode}`; // Use specific class for animation styling if needed
            gameContainer.appendChild(movingPiece); // Add to game container for positioning relative to it

            // Calculate size and position relative to the gameContainer
            const pieceWidth = startRect.width * 0.9; // Match .piece style
            const pieceHeight = startRect.height * 0.9;
            const pieceOffsetX = (startRect.width - pieceWidth) / 2;
            const pieceOffsetY = (startRect.height - pieceHeight) / 2;

            const gameContainerRect = gameContainer.getBoundingClientRect();

            // Start position (relative to game container's top-left)
            const initialTopRelGameContainer = (startRect.top + pieceOffsetY) - gameContainerRect.top + gameContainer.scrollTop; // account for scroll
            const initialLeftRelGameContainer = (startRect.left + pieceOffsetX) - gameContainerRect.left + gameContainer.scrollLeft; // account for scroll

            // End position (relative to game container's top-left)
             const finalTopRelGameContainer = (endRect.top + pieceOffsetY) - gameContainerRect.top + gameContainer.scrollTop; // account for scroll
             const finalLeftRelGameContainer = (endRect.left + pieceOffsetX) - gameContainerRect.left + gameContainer.scrollLeft; // account for scroll


            // Calculate translation needed
            const translateX = finalLeftRelGameContainer - initialLeftRelGameContainer;
            const translateY = finalTopRelGameContainer - initialTopRelGameContainer;


            // Apply styles to the moving piece
            movingPiece.style.position = 'absolute';
            movingPiece.style.top = `${initialTopRelGameContainer}px`;
            movingPiece.style.left = `${initialLeftRelGameContainer}px`;
            movingPiece.style.width = `${pieceWidth}px`;
            movingPiece.style.height = `${pieceHeight}px`;
            movingPiece.style.transform = 'translate(0, 0)'; // Start transform
            movingPiece.style.zIndex = '1000'; // Ensure it's above board pieces
            movingPiece.style.pointerEvents = 'none'; // Don't interfere with clicks/drags


            // Hide the original piece during animation
            if (pieceElToHide) {
                 // Ensure ghost class is removed if it was a drag
                pieceElToHide.classList.remove('piece-ghost');
                pieceElToHide.classList.add('hidden-during-move');
            }

            // Force reflow/repaint before starting transition
            movingPiece.offsetHeight;

            // Apply the end transform to trigger the animation
            requestAnimationFrame(() => {
                 movingPiece.style.transform = `translate(${translateX}px, ${translateY}px)`;
            });

            // After animation duration, remove the moving piece and call the callback
            setTimeout(() => {
                if (movingPiece.parentNode) {
                    movingPiece.remove();
                }
                 // Note: We don't unhide the original piece here. renderBoard() in the callback will redraw it in the new position.
                if (onCompleteCallback) {
                    onCompleteCallback();
                }
            }, ANIMATION_DURATION_MS); // Use constant duration
        }


        function makeMove(startRow, startCol, endRow, endCol) {
            const piece = board[startRow][startCol];
            const captured = board[endRow][endCol];

            if (!piece) { console.error(`Move err: empty start ${startRow},${startCol}`); return; }
            // console.log(`[Board Update] ${piece}: ${startRow},${startCol} -> ${endRow},${endCol}. Capt: ${captured || 'no'}`);

            if (captured) {
                capturedPieces[piece[0]].push(captured); // Add captured piece to list
            }

            // Handle pawn promotion
            if (piece === 'wp' && endRow === 0) {
                board[endRow][endCol] = 'wq'; // Auto-promote to Queen for white
            } else if (piece === 'bp' && endRow === 7) {
                board[endRow][endCol] = 'bq'; // Auto-promote to Queen for black
            } else {
                // Normal move
                board[endRow][endCol] = piece;
            }

            board[startRow][startCol] = null; // Empty the start square

            // Update king position if king moved
            if (piece === 'wk') whiteKingPos = {row: endRow, col: endCol};
            else if (piece === 'bk') blackKingPos = {row: endRow, col: endCol};

            // Record the last move
            lastMove = { start: {row: startRow, col: startCol}, end: {row: endRow, col: endCol} };
        }

        // --- Selection and Highlighting ---
        function selectPiece(row, col, piece) {
            removePieceSelectionHighlight(); // Deselect any previous
            removeMoveHighlights();         // Clear old move highlights

            selectedSquare = { row, col };
            validMoves = calculateValidMoves(row, col, piece);

            const sqEl = getSquareElement(row, col);
            if (sqEl) sqEl.classList.add('selected'); // Highlight selected square

            highlightValidMoves(); // Show moves for the new selection
        }

        function removePieceSelectionHighlight(){
            if(selectedSquare){
                const prevEl = getSquareElement(selectedSquare.row, selectedSquare.col);
                if(prevEl) prevEl.classList.remove('selected');
            }
            // Failsafe: remove from all squares
            document.querySelectorAll('.square.selected').forEach(el => el.classList.remove('selected'));
        }

        function removeMoveHighlights(){
            document.querySelectorAll('.square.highlight').forEach(el => el.classList.remove('highlight', 'capture'));
        }

        function highlightValidMoves(){
            removeMoveHighlights(); // Clear previous highlights first
            validMoves.forEach(m => {
                const s = getSquareElement(m.row, m.col);
                if (s) {
                    s.classList.add('highlight');
                    const targetPiece = board[m.row][m.col];
                    // Add capture style if the move lands on an opponent's piece
                    if (targetPiece && getPieceColor(m.row, m.col) !== currentPlayer) {
                        s.classList.add('capture');
                    }
                }
            });
        }

        function getSquareElement(r, c){
            if (!isValid(r, c)) return null;
            return boardElement ? boardElement.querySelector(`.square[data-row="${r}"][data-col="${c}"]`) : null;
        }

        // --- Player Switching and Game Over Check ---
        function switchPlayer() {
             const previousPlayer = currentPlayer;
             currentPlayer = (currentPlayer === 'w') ? 'b' : 'w';

             // Update check status *before* checking for game over
             isWhiteInCheck = isKingInCheck('w');
             isBlackInCheck = isKingInCheck('b');

             console.log(`[TURN] Switched to ${currentPlayer}. W_Check: ${isWhiteInCheck}, B_Check: ${isBlackInCheck}`);

             // Calculate if the *new* current player has any legal moves
             const availableMoves = calculateAllValidMoves(currentPlayer);

             // --- Game Over Check ---
             if (availableMoves.length === 0) {
                 gameOver = true;
                 const winnerColor = previousPlayer; // The player whose turn it *was* delivers checkmate/stalemate
                 const loserColor = currentPlayer;   // The player whose turn it *is* has no moves
                 const winnerName = winnerColor === 'w' ? 'Human' : 'Orc';
                 const loserName = loserColor === 'w' ? 'Human' : 'Orc';

                 let title = "Game Over!";
                 let message = "";

                 // Check if the player with no moves is currently in check
                 if ((loserColor === 'w' && isWhiteInCheck) || (loserColor === 'b' && isBlackInCheck)) {
                      title = "Checkmate!";
                      message = `${winnerName} wins by checkmate!`;
                      showGameOverModal(title, message); // Use custom modal
                 } else {
                      // Not in check, but no legal moves = Stalemate
                      title = "Stalemate!";
                      message = "The game is a draw by stalemate.";
                      showGameOverModal(title, message); // Use custom modal
                 }
                 // Final render after game over declared
                 renderBoard();
                 renderCapturedPieces();
                 updateUndoButton(); // Disable undo when game over
                 return; // Stop further processing
             }
             // --- End Game Over Check ---

             // --- If game continues ---
             renderBoard(); // Render board with new highlights (check, last move)
             renderCapturedPieces(); // Update captured pieces display
             updateStatus(); // Update whose turn it is (and check status)

             isComputerTurn = (gameMode !== '2P' && currentPlayer !== playerColor);
             updateUndoButton(); // Update undo based on new state

             if (isComputerTurn && !gameOver) {
                 console.log("[TURN] CPU's turn starting...");
                 document.body.classList.add('computer-thinking');
                 updateStatus(); // Show "CPU thinking..."
                 // Add a slight delay before the AI starts calculating
                 setTimeout(makeComputerMove, 500);
             }
             else {
                 // Player's turn
                 document.body.classList.remove('computer-thinking');
                 console.log("[TURN] Player's turn.");
                 updateStatus(); // Ensure status shows player's turn
             }
         }

        function updateStatus() {
             if (!statusElement || gameOver) return; // Don't update if game is over

             let turnText = "";
             const currentSideName = currentPlayer === 'w' ? 'Human' : 'Orc';
             const isInCheck = (currentPlayer === 'w' && isWhiteInCheck) || (currentPlayer === 'b' && isBlackInCheck);

             if (gameMode === '2P') {
                 turnText = `${currentSideName}'s Turn`;
             } else { // vs CPU
                 if (document.body.classList.contains('computer-thinking')) {
                     turnText = `CPU thinking...`;
                 } else if (currentPlayer === playerColor) {
                     turnText = `Your Turn (${currentSideName})`; // Clarify player's side
                 } else {
                     turnText = `CPU's Turn (${currentSideName})`; // Clarify CPU's side
                 }
             }

             // Append Check status if applicable
             if (isInCheck) {
                 turnText += " (Check!)";
             }

             statusElement.textContent = turnText;
         }


        // --- Move Calculation & Check Logic (Largely unchanged) ---
        function isValid(r, c) { return r >= 0 && r < 8 && c >= 0 && c < 8; }
        function getPieceColor(r, c) { if (!isValid(r, c)) return null; const p = board[r][c]; return p ? p[0] : null; }
        function addSlidingMoves(moves, r, c, color, dr, dc, currentBoard) { let cr = r + dr; let cc = c + dc; while (isValid(cr, cc)) { const targetPiece = currentBoard[cr][cc]; if (targetPiece === null) { moves.push({ row: cr, col: cc }); } else { if (targetPiece[0] !== color) { moves.push({ row: cr, col: cc }); } break; } cr += dr; cc += dc; } }
        function getPawnMoves(r, c, color, currentBoard) { const moves = []; const dir = color === 'w' ? -1 : 1; const startRow = color === 'w' ? 6 : 1; const nextRow = r + dir; if (isValid(nextRow, c) && currentBoard[nextRow][c] === null) { moves.push({ row: nextRow, col: c }); const twoStepRow = r + 2 * dir; if (r === startRow && isValid(twoStepRow, c) && currentBoard[twoStepRow][c] === null) { moves.push({ row: twoStepRow, col: c }); } } const captureCols = [c - 1, c + 1]; captureCols.forEach(capCol => { if (isValid(nextRow, capCol)) { const targetPiece = currentBoard[nextRow][capCol]; if (targetPiece && targetPiece[0] !== color) { moves.push({ row: nextRow, col: capCol }); } } }); /* TODO: En passant */ return moves; }
        function getRookMoves(r, c, color, currentBoard) { const moves = []; const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; directions.forEach(([dr, dc]) => addSlidingMoves(moves, r, c, color, dr, dc, currentBoard)); return moves; }
        function getBishopMoves(r, c, color, currentBoard) { const moves = []; const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]]; directions.forEach(([dr, dc]) => addSlidingMoves(moves, r, c, color, dr, dc, currentBoard)); return moves; }
        function getQueenMoves(r, c, color, currentBoard) { const moves = []; const directions = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]]; directions.forEach(([dr, dc]) => addSlidingMoves(moves, r, c, color, dr, dc, currentBoard)); return moves; }
        function getKnightMoves(r, c, color, currentBoard) { const moves = []; const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]]; knightMoves.forEach(([dr, dc]) => { const nr = r + dr; const nc = c + dc; if (isValid(nr, nc)) { const targetPiece = currentBoard[nr][nc]; if (!targetPiece || targetPiece[0] !== color) { moves.push({ row: nr, col: nc }); } } }); return moves; }
        function getKingMoves(r, c, color, currentBoard) { const moves = []; const kingMoves = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]; kingMoves.forEach(([dr, dc]) => { const nr = r + dr; const nc = c + dc; if (isValid(nr, nc)) { const targetPiece = currentBoard[nr][nc]; if (!targetPiece || targetPiece[0] !== color) { moves.push({ row: nr, col: nc }); } } }); /* TODO: Castling */ return moves; }

        function calculateValidMoves(r, c, piece, currentBoard = board) {
            const legalMoves = [];
            if (!piece) return legalMoves;
            const type = piece[1];
            const color = piece[0];
            let pseudoLegalMoves = [];

            switch (type) {
                case 'p': pseudoLegalMoves = getPawnMoves(r, c, color, currentBoard); break;
                case 'r': pseudoLegalMoves = getRookMoves(r, c, color, currentBoard); break;
                case 'n': pseudoLegalMoves = getKnightMoves(r, c, color, currentBoard); break;
                case 'b': pseudoLegalMoves = getBishopMoves(r, c, color, currentBoard); break;
                case 'q': pseudoLegalMoves = getQueenMoves(r, c, color, currentBoard); break;
                case 'k': pseudoLegalMoves = getKingMoves(r, c, color, currentBoard); break;
                default: return legalMoves;
            }

            // Filter out moves that leave the king in check
            pseudoLegalMoves.forEach(move => {
                 // Use the correct board (could be the actual board or a simulated one)
                 // Pass the board explicitly to the check validation function
                 if (!moveLeavesKingInCheck(r, c, move.row, move.col, color, currentBoard)) {
                    legalMoves.push(move);
                 }
            });
            return legalMoves;
        }

        function isSquareAttacked(r, c, attackerColor, currentBoard) {
             const pawnDir = attackerColor === 'w' ? 1 : -1; // Direction pawns move to attack square (r,c)
             const pawnAttackSources = [{ dr: pawnDir, dc: -1 }, { dr: pawnDir, dc: 1 }];
             for (const { dr, dc } of pawnAttackSources) {
                 const sr = r + dr; const sc = c + dc;
                 if (isValid(sr, sc) && currentBoard[sr][sc] === attackerColor + 'p') return true;
             }

             const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
             for (const [dr, dc] of knightMoves) {
                 const sr = r + dr; const sc = c + dc;
                 if (isValid(sr, sc) && currentBoard[sr][sc] === attackerColor + 'n') return true;
             }

             const rookDirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
             const bishopDirs = [[-1, -1], [-1, 1], [1, -1], [1, 1]];

             function checkSliding(directions, pieceTypes) {
                 for (const [dr, dc] of directions) {
                     let cr = r + dr; let cc = c + dc;
                     while (isValid(cr, cc)) {
                         const p = currentBoard[cr][cc];
                         if (p !== null) { // Found a piece
                             if (p[0] === attackerColor && pieceTypes.includes(p[1])) return true; // It's an attacking piece
                             break; // Path blocked by a piece (either friendly or non-attacking opponent)
                         }
                         cr += dr; cc += dc; // Continue along the line
                     }
                 }
                 return false;
             }

             if (checkSliding(rookDirs, ['r', 'q'])) return true; // Check for Rooks and Queens
             if (checkSliding(bishopDirs, ['b', 'q'])) return true; // Check for Bishops and Queens

             const kingMoves = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
             for (const [dr, dc] of kingMoves) {
                 const sr = r + dr; const sc = c + dc;
                 if (isValid(sr, sc) && currentBoard[sr][sc] === attackerColor + 'k') return true;
             }

             return false; // Square is not attacked
         }

        function findKing(kingColor, currentBoard = board) {
             // Use cached position if checking the actual board state
             if (currentBoard === board) {
                 const cachedPos = kingColor === 'w' ? whiteKingPos : blackKingPos;
                 // Validate cache
                 if (cachedPos && isValid(cachedPos.row, cachedPos.col) && currentBoard[cachedPos.row][cachedPos.col] === kingColor + 'k') {
                     return cachedPos;
                 }
                 // console.warn(`King cache miss/invalid for ${kingColor}k.`);
             }
             // If cache miss/invalid or checking a simulated board, find it manually
             const foundPos = findKingOnBoard(kingColor, currentBoard);
             // Update cache only if operating on the main board and king was found
             if (currentBoard === board && foundPos) {
                 if (kingColor === 'w') whiteKingPos = foundPos;
                 else blackKingPos = foundPos;
             }
             return foundPos;
         }

         function isKingInCheck(kingColor, currentBoard = board) {
            const kingPos = findKing(kingColor, currentBoard);
            if (!kingPos) {
                console.error(`Cannot check king: ${kingColor}k not found on the board being checked!`);
                return false; // Or handle error differently
            }
            const attackerColor = kingColor === 'w' ? 'b' : 'w';
            // Pass the specific board state to isSquareAttacked
            return isSquareAttacked(kingPos.row, kingPos.col, attackerColor, currentBoard);
        }

        function moveLeavesKingInCheck(startRow, startCol, endRow, endCol, pieceColor, boardToCheck) {
             // 1. Create a temporary copy of the board state passed in
             const tempBoard = JSON.parse(JSON.stringify(boardToCheck));

             // 2. Simulate the move on the temporary board
             const piece = tempBoard[startRow][startCol];
             const capturedPiece = tempBoard[endRow][endCol]; // Store for restoration
             tempBoard[endRow][endCol] = piece;
             tempBoard[startRow][startCol] = null;

             // 3. Find the king's position *on the temporary board*
             let kingPosToCheck = findKing(pieceColor, tempBoard);

             // If the king itself moved, findKing should return the new position.
             // Handle case where king might not be found (shouldn't happen in valid state)
             if (!kingPosToCheck) {
                 console.error("Check validation error: King position unknown after simulated move!");
                 // In this error state, assume the move is invalid to be safe
                 return true;
             }

             // 4. Check if the king is attacked *on the temporary board*
             const check = isSquareAttacked(kingPosToCheck.row, kingPosToCheck.col, pieceColor === 'w' ? 'b' : 'w', tempBoard);

             // 5. No need to restore the board state, the temporary copy is discarded.
             // Return the result
             return check;
         }

        function calculateAllValidMoves(playerColor, currentBoard = board) {
             const allMoves = [];
             for (let r = 0; r < 8; r++) {
                 for (let c = 0; c < 8; c++) {
                     const piece = currentBoard[r][c];
                     if (piece && piece.startsWith(playerColor)) {
                         // Pass the currentBoard explicitly to calculateValidMoves
                         const moves = calculateValidMoves(r, c, piece, currentBoard);
                         moves.forEach(move => allMoves.push({
                             piece: piece,
                             startRow: r,
                             startCol: c,
                             endRow: move.row,
                             endCol: move.col
                         }));
                     }
                 }
             }
             return allMoves;
         }


        // --- AI Logic (Uses new simulation/calculation functions) ---
        function evaluateBoardFromState(boardState) {
             let score = 0;
             for (let r = 0; r < 8; r++) {
                 for (let c = 0; c < 8; c++) {
                     const piece = boardState[r][c];
                     if (piece) {
                         const value = pieceValues[piece[1]] || 0;
                         score += (piece[0] === 'w' ? value : -value);
                     }
                 }
             }
             return score;
         }

        function simulateMoveOnState(currentBoardState, move) {
            let newBoardState = JSON.parse(JSON.stringify(currentBoardState));
            const piece = newBoardState[move.startRow][move.startCol];

            if (!piece) { return [newBoardState, null]; } // Should not happen if move is valid

            const captured = newBoardState[move.endRow][move.endCol];

            // Handle promotion during simulation
            if (piece === 'wp' && move.endRow === 0) newBoardState[move.endRow][move.endCol] = 'wq';
            else if (piece === 'bp' && move.endRow === 7) newBoardState[move.endRow][move.endCol] = 'bq';
            else newBoardState[move.endRow][move.endCol] = piece;

            newBoardState[move.startRow][move.startCol] = null;

            return [newBoardState, captured];
        }

        // Renamed calculateAllValidMovesForState to use the improved calculateAllValidMoves
        // which now accepts a board state directly.

        function minimax(depth, boardState, alpha, beta, maximizingPlayer, playerToDoMove) {
             // Base case: depth limit or game over
             if (depth === 0) {
                 return evaluateBoardFromState(boardState);
             }

             const availableMoves = calculateAllValidMoves(playerToDoMove, boardState);

             // Base case: No legal moves (checkmate or stalemate)
             if (availableMoves.length === 0) {
                 if (isKingInCheck(playerToDoMove, boardState)) {
                     // Checkmate: Punish the player whose turn it was (maximizingPlayer) if they got checkmated
                     // Or reward them if they delivered checkmate
                     // Score is relative to the *initial* maximizing player of the minimax call
                     return maximizingPlayer ? -Infinity - depth : Infinity + depth; // Add depth to prioritize faster mates
                 } else {
                     // Stalemate: Neutral score
                     return 0;
                 }
             }

             // Recursive step
             if (playerToDoMove === 'w') { // White's turn (tries to maximize)
                 let maxEval = -Infinity;
                 for (const move of availableMoves) {
                     const [nextBoardState, _] = simulateMoveOnState(boardState, move);
                     const evaluation = minimax(depth - 1, nextBoardState, alpha, beta, maximizingPlayer, 'b'); // Next player is black
                     maxEval = Math.max(maxEval, evaluation);
                     alpha = Math.max(alpha, evaluation);
                     if (beta <= alpha) {
                         break; // Beta cut-off
                     }
                 }
                 return maxEval;
             } else { // Black's turn (tries to minimize)
                 let minEval = Infinity;
                 for (const move of availableMoves) {
                     const [nextBoardState, _] = simulateMoveOnState(boardState, move);
                     const evaluation = minimax(depth - 1, nextBoardState, alpha, beta, maximizingPlayer, 'w'); // Next player is white
                     minEval = Math.min(minEval, evaluation);
                     beta = Math.min(beta, evaluation);
                     if (beta <= alpha) {
                         break; // Alpha cut-off
                     }
                 }
                 return minEval;
             }
         }


        function makeComputerMove() {
            if (gameOver || !isComputerTurn || isAnimating) {
                if (!isComputerTurn && !gameOver) {
                    document.body.classList.remove('computer-thinking');
                    updateStatus();
                }
                return;
            }
            console.log(`[AI] ${gameMode} calculating for ${currentPlayer}...`);

            const aiColor = currentPlayer;
            const availableMoves = calculateAllValidMoves(aiColor, board); // Use current board

            if (availableMoves.length === 0) {
                console.error("AI Error: No moves available, but game wasn't over?");
                isComputerTurn = false;
                document.body.classList.remove('computer-thinking');
                updateStatus();
                updateUndoButton();
                return;
            }

            let bestMove = null;

            // --- Easy Mode ---
            if (gameMode === 'CPU-easy') {
                bestMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
            }
            // --- Medium Mode (Simple Heuristics) ---
            else if (gameMode === 'CPU-medium') {
                let bestScore = -Infinity;
                let candidateMoves = [];
                availableMoves.forEach(move => {
                    let moveScore = 0;
                    const targetPiece = board[move.endRow][move.endCol];
                    // 1. Capture Value
                    if (targetPiece) {
                        moveScore += (pieceValues[targetPiece[1]] || 0) * 10;
                    }
                    // 2. Check Bonus
                    const [nextBoardState, _] = simulateMoveOnState(board, move); // Simulate on current board
                    const opponentColor = aiColor === 'w' ? 'b' : 'w';
                    if (isKingInCheck(opponentColor, nextBoardState)) { // Check on simulated board
                        moveScore += 5; // Bonus for delivering check
                    }
                    // 3. Randomness
                    moveScore += Math.random() * 0.5; // Small random factor

                    if (moveScore > bestScore) {
                        bestScore = moveScore;
                        candidateMoves = [move];
                    } else if (moveScore === bestScore) {
                        candidateMoves.push(move);
                    }
                });
                bestMove = candidateMoves.length > 0
                    ? candidateMoves[Math.floor(Math.random() * candidateMoves.length)]
                    : availableMoves[Math.floor(Math.random() * availableMoves.length)]; // Fallback
            }
            // --- Hard Mode (Minimax) ---
            else if (gameMode === 'CPU-hard') {
                let bestScore = (aiColor === 'w') ? -Infinity : Infinity; // White maximizes, Black minimizes
                let depth = 2; // Adjust depth for desired difficulty/performance
                let candidateMoves = [];

                // Determine initial maximizing player based on AI color
                 const isAiMaximizing = (aiColor === 'w');

                availableMoves.forEach(move => {
                    const [nextBoardState, _] = simulateMoveOnState(board, move);
                    const opponentColor = (aiColor === 'w' ? 'b' : 'w');
                    // Call minimax for the opponent's turn on the resulting board state
                    const score = minimax(depth -1, nextBoardState, -Infinity, Infinity, isAiMaximizing, opponentColor); // Opponent makes the next move

                    if (isAiMaximizing) { // AI is White (maximizing)
                        if (score > bestScore) {
                            bestScore = score;
                            candidateMoves = [move];
                        } else if (score === bestScore) {
                            candidateMoves.push(move);
                        }
                    } else { // AI is Black (minimizing)
                        if (score < bestScore) {
                            bestScore = score;
                            candidateMoves = [move];
                        } else if (score === bestScore) {
                            candidateMoves.push(move);
                        }
                    }
                });
                // Choose randomly among the best moves
                bestMove = candidateMoves.length > 0
                    ? candidateMoves[Math.floor(Math.random() * candidateMoves.length)]
                    : availableMoves[Math.floor(Math.random() * availableMoves.length)]; // Fallback if something goes wrong

                 console.log(`[AI Hard] Best score: ${bestScore}, Moves: ${candidateMoves.length}`);
            }

            // --- Execute the chosen move ---
            if (bestMove) {
                console.log(`[AI] Chosen Move: ${bestMove.piece} ${bestMove.startRow},${bestMove.startCol} -> ${bestMove.endRow},${bestMove.endCol}`);
                // Use initiateMove for animation
                initiateMove(bestMove.startRow, bestMove.startCol, bestMove.endRow, bestMove.endCol);
            } else {
                console.error("AI failed to select a move!");
                isComputerTurn = false;
                document.body.classList.remove('computer-thinking');
                updateStatus();
                updateUndoButton();
            }
        }


        // --- Game Control ---
        function quitGame() {
            console.log("[CONTROL] Quitting game...");
            hideGameOverModal(); // Hide modal if open

            // Exit fullscreen if active
            if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
                 if (document.exitFullscreen) { document.exitFullscreen(); }
                 else if (document.mozCancelFullScreen) { document.mozCancelFullScreen(); }
                 else if (document.webkitExitFullscreen) { document.webkitExitFullscreen(); }
                 else if (document.msExitFullscreen) { document.msExitFullscreen(); }
            }
            if(fullscreenButton) fullscreenButton.classList.remove('active'); // Reset button state manually

            gameOver = true; // Mark game as over to stop potential AI turns etc.
            isAnimating = false; // Ensure animation flag is off
            document.body.classList.remove('computer-thinking'); // Remove thinking state

            // Reset UI elements
            if (gameAreaElement) gameAreaElement.style.display = 'none';
            if (modeSelectionElement) modeSelectionElement.style.display = 'flex'; // Show mode selection
            if (boardElement) boardElement.innerHTML = ''; // Clear board
            if (whiteCapturedElement) whiteCapturedElement.innerHTML = ''; // Clear captured
            if (blackCapturedElement) blackCapturedElement.innerHTML = ''; // Clear captured

            // Reset game state variables
            board = [];
            currentPlayer = 'w';
            playerColor = 'w';
            gameMode = null;
            selectedSquare = null;
            resetDraggingState(); // Full reset of drag variables
            validMoves = [];
            whiteKingPos = null; blackKingPos = null;
            isWhiteInCheck = false; isBlackInCheck = false;
            isComputerTurn = false;
            capturedPieces = { w: [], b: [] };
            lastMove = { start: null, end: null };
            moveHistory = [];
            selectedDifficulty = null;
            selectedModeType = null;

            if (boardElement) boardElement.classList.remove('board-flipped'); // Reset board orientation
            if (statusElement) statusElement.textContent = "Select mode to start"; // Reset status text

            // Reset mode selection UI state
            if (mode2pButton) mode2pButton.classList.remove('selected');
            if (modeCpuButton) modeCpuButton.classList.remove('selected');
            if (difficultyButtons) difficultyButtons.forEach(b => b.classList.remove('selected'));
            if (sideOptions) {
                sideOptions.forEach(o => o.classList.remove('selected'));
                const sideHuman = document.getElementById('side-human');
                if (sideHuman) sideHuman.classList.add('selected');
                const sideHumanRadio = document.getElementById('radio-human');
                if (sideHumanRadio) sideHumanRadio.checked = true;
            }
            if (cpuOptionsContainer) {
                cpuOptionsContainer.style.display = 'none'; // Hide CPU options
                cpuOptionsContainer.classList.remove('options-disabled');
            }

            updateUndoButton(); // Disable undo button
            if (startGameButton) startGameButton.disabled = true; // Disable start button

            // Re-select default mode (e.g., CPU Easy) to prepare for next game setup
            // Use timeout to ensure DOM updates are processed first if needed
            // setTimeout(() => {
            //    const cpuModeBtn = document.getElementById('mode-cpu');
            //    const easyDiffBtn = document.querySelector('[data-difficulty="CPU-easy"]');
            //    if(cpuModeBtn) cpuModeBtn.click();
            //     if (easyDiffBtn && !cpuModeBtn.classList.contains('selected')) { // Click difficulty only if CPU was selected
            //         // easyDiffBtn.click(); // Re-clicking difficulty might not be needed if CPU click handles it
            //     }
            //    console.log("Default mode re-selected after quit.");
            // }, 50); // Short delay
        }


        // --- Fullscreen Functionality ---
        function toggleFullScreen() {
             const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
             const elementToFullscreen = gameContainer; // Target the main container

             if (!isFullscreen) {
                 console.log("Entering Fullscreen...");
                 try {
                    let promise;
                    if (elementToFullscreen.requestFullscreen) { promise = elementToFullscreen.requestFullscreen(); }
                    else if (elementToFullscreen.mozRequestFullScreen) { promise = elementToFullscreen.mozRequestFullScreen(); }
                    else if (elementToFullscreen.webkitRequestFullscreen) { promise = elementToFullscreen.webkitRequestFullscreen(); }
                    else if (elementToFullscreen.msRequestFullscreen) { promise = elementToFullscreen.msRequestFullscreen(); }

                    if (promise) {
                        promise.then(() => { /* Successfully entered fullscreen */ })
                               .catch(err => {
                                   console.error(`Fullscreen error: ${err.message} (${err.name})`);
                                   alert(`Could not enter fullscreen: ${err.message}`);
                                   if(fullscreenButton) fullscreenButton.classList.remove('active'); // Ensure button state is correct
                               });
                    } else {
                        console.warn("Fullscreen API not supported by this browser.");
                        alert("Fullscreen mode is not supported by your browser.");
                    }
                 } catch (err) {
                     console.error("Error attempting to enter fullscreen:", err);
                      alert("An error occurred trying to enter fullscreen.");
                 }
             } else {
                 console.log("Exiting Fullscreen...");
                 try {
                    if (document.exitFullscreen) { document.exitFullscreen(); }
                    else if (document.mozCancelFullScreen) { document.mozCancelFullScreen(); }
                    else if (document.webkitExitFullscreen) { document.webkitExitFullscreen(); }
                    else if (document.msExitFullscreen) { document.msExitFullscreen(); }
                 } catch (err) {
                     console.error("Error attempting to exit fullscreen:", err);
                 }
             }
         }
        function handleFullscreenChange() {
             const isFullscreenNow = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
             const fsElement = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;

             if (isFullscreenNow && fsElement === gameContainer) {
                 if(fullscreenButton) fullscreenButton.classList.add('active');
                 console.log("Entered fullscreen (event).");
             } else {
                  // Check if we are exiting fullscreen specifically from our container
                  if (fullscreenButton && fullscreenButton.classList.contains('active')) {
                     fullscreenButton.classList.remove('active');
                     console.log("Exited fullscreen (event).");
                  } else {
                      // Fullscreen change occurred, but maybe not related to our button/container
                      // or state was already inactive.
                  }
             }
              // Optional: Force a re-render or resize calculation if needed after fullscreen change
             // renderBoard(); // Might be overkill unless layout breaks
         }
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);


        // --- Initial UI Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            try {
                console.log("DOM Loaded. Setting up.");
                setupModeSelectionListeners();
                console.log("Mode listeners attached.");

                // Check essential elements needed for core game loop and UI interaction
                 if (!gameContainer || !boardElement || !modeSelectionElement || !gameAreaElement || !statusElement || !fullscreenButton || !modeCpuButton || !newGameButton || !bottomPanel || !undoButton || !quitButton ) {
                    console.error("CRITICAL: Essential DOM element missing! Check IDs.");
                    alert("Error loading game components. Please refresh or check the console.");
                    return; // Stop initialization
                 }

                 if(statusElement) statusElement.textContent = "Select mode to start"; // Initial status

                 // Listener for the 'Play Again' button in the modal
                 newGameButton.addEventListener('click', () => {
                    console.log("New Game (from modal) clicked.");
                    quitGame(); // Use quitGame to reset everything
                    // Optional: Automatically select a default mode after quitting
                    setTimeout(() => {
                         const cpuModeBtn = document.getElementById('mode-cpu');
                         if(cpuModeBtn) {
                             cpuModeBtn.click();
                            // console.log("Default mode re-selected after Play Again.");
                         } else { console.error("Cannot select default mode after Play Again."); }
                     }, 50); // Short delay
                 });

                 // Set default mode selection (e.g., CPU Easy) on initial load
                 setTimeout(() => {
                     const cpuModeBtn = document.getElementById('mode-cpu');
                     if (cpuModeBtn) {
                         cpuModeBtn.click(); // Select CPU mode type
                         // The click handler for modeCpuButton should handle selecting Easy difficulty by default
                         console.log("Default mode (CPU) selected on load.");
                     } else { console.error("Cannot select default mode on load."); }
                 }, 0); // Timeout ensures listeners are attached

            } catch (error) {
                console.error("Initialization setup error:", error);
                alert("An error occurred while initializing the game. Please check the console.");
            }
        });

    </script>

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Knights Vs Goblins (Spell Charges)</title>
    <style>
        /* --- Base Styles --- */
        :root {
            --grid-cols: 8;
            --grid-rows: 10;
            --board-aspect-ratio: var(--grid-cols) / var(--grid-rows);
            font-size: clamp(8px, 1.8vmin, 16px);
            --death-fade-time: 1s;
            --attack-anim-time: 0.08s;
            --move-anim-time: 0.25s; /* Movement animation duration */
            --arrow-fly-time: 0.3s; /* Arrow animation duration */
            --frost-nova-hover-bg: rgba(100, 150, 255, 0.3);
            --frost-nova-hover-border: rgba(150, 200, 255, 0.7);
            --frozen-filter: hue-rotate(180deg) brightness(1.2) saturate(1.5);
            --frozen-shadow: inset 0 0 5px rgba(150, 200, 255, 0.6);
            /* Spell State Filters */
            --spell-locked-filter: sepia(0.8) saturate(3) hue-rotate(-55deg) brightness(0.7);
            --spell-used-filter: grayscale(90%) brightness(60%);
            /* Hover Outline Color */
            --hover-outline-color-player: yellow;
            --hover-outline-color-enemy: red;
            /* Heal Color */
            --heal-color: #50ff50; /* Light green */
            /* Cell size variable set by JS */
            --cell-size: 30px;
        }
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }
        body { display: flex; justify-content: center; align-items: center; background-color: #3a4a3a; font-family: 'Courier New', Courier, monospace; color: #eee; padding: 5px; box-sizing: border-box; }
        #game-container { display: flex; max-width: 100%; max-height: 100%; width: 100%; height: 100%; border: clamp(2px, 0.5vmin, 5px) solid #1e281e; background-color: #1e281e; box-shadow: 0 0 15px rgba(0,0,0,0.5); flex-direction: row; align-items: stretch; justify-content: center; padding: clamp(3px, 1vmin, 10px); box-sizing: border-box; gap: clamp(5px, 1vmin, 10px); }
        #game-container:fullscreen { padding: 0; border: none; gap: 5px; width: 100vw; height: 100vh; max-width: 100vw; max-height: 100vh; }
        #game-container:fullscreen > #ui-panel { border-left-color: #333; }

        /* --- Game Board & Cells --- */
        #game-board { display: grid; border: clamp(1px, 0.3vmin, 2px) solid #1e281e; position: relative; /* Needed for absolute positioning */ flex-grow: 0; flex-shrink: 1; grid-template-columns: repeat(var(--grid-cols), 1fr); grid-template-rows: repeat(var(--grid-rows), 1fr); aspect-ratio: var(--board-aspect-ratio); max-width: 100%; max-height: 100%; box-sizing: border-box; min-width: 160px; min-height: calc(160px / var(--board-aspect-ratio)); overflow: hidden; }
        /* Spell Targeting Cursors & Hovers */
        #game-board.fireball-targeting { cursor: crosshair !important; }
        #game-board.fireball-targeting .grid-cell:hover:not(.has-obstacle) { background-color: rgba(255, 100, 100, 0.4) !important; box-shadow: inset 0 0 0 2px rgba(255, 0, 0, 0.7); }
        #game-board.flame-wave-targeting .grid-cell:hover:not(.has-obstacle) { background-color: rgba(255, 150, 50, 0.3) !important; box-shadow: none; }
        #game-board.flame-wave-targeting .grid-cell:hover:not(.has-obstacle)::before { content: ''; position: absolute; top: 0; left: calc(-1 * var(--hover-col, 0) * 100%); width: calc(var(--grid-cols) * 100%); height: 100%; background-color: rgba(255, 80, 0, 0.4); border-top: 2px solid rgba(255, 50, 0, 0.8); border-bottom: 2px solid rgba(255, 50, 0, 0.8); pointer-events: none; z-index: 1; }
        #game-board.frost-nova-targeting { cursor: cell !important; }
        #game-board.frost-nova-targeting .grid-cell:hover:not(.has-obstacle) { background-color: transparent !important; box-shadow: none; }
        #game-board.frost-nova-targeting .grid-cell.frost-aoe-preview:not(.has-obstacle) { background-color: var(--frost-nova-hover-bg) !important; box-shadow: inset 0 0 0 1px var(--frost-nova-hover-border); z-index: 2; }
        #game-board.heal-targeting { cursor: help !important; }
        #game-board.heal-targeting .unit.player:not(.dead):not(.acted):not(.frozen):hover { filter: drop-shadow(0 0 3px var(--heal-color)); box-shadow: 0 0 0 2px var(--heal-color); }
        .grid-cell { border: 1px solid #7a8a7a; background-color: #6a7a6a; position: relative; display: flex; justify-content: center; align-items: center; cursor: pointer; transition: background-color 0.2s, box-shadow 0.2s; box-sizing: border-box; image-rendering: pixelated; min-width: 1px; min-height: 1px; overflow: hidden; grid-column: auto; grid-row: auto; }
        .grid-cell.valid-move:not(.has-obstacle) { background-color: #aaeaaa; opacity: 0.8; cursor: pointer; }
        .grid-cell.valid-attack:not(.has-obstacle) { background-color: #ffaaaa; opacity: 0.8; cursor: crosshair; } /* Use crosshair cursor */
        .grid-cell.has-obstacle { cursor: not-allowed !important; background-color: #5a6a5a; /* Slightly darker bg for obstacle cell */ } /* Indicate blocked cell and override others */

        /* --- Obstacles (NEW) --- */
        .obstacle {
             /* Placed via JS setting grid-column/row */
            grid-column: var(--obs-x, 1);
            grid-row: var(--obs-y, 1);
            align-self: center; justify-self: center;
            width: calc(var(--cell-size) * 0.8); /* Use dynamic cell size */
            height: calc(var(--cell-size) * 0.8);
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 2; /* Below units */
            pointer-events: none; /* Cannot be interacted with */
            image-rendering: pixelated;
            box-sizing: border-box;
            /* position: absolute; // Let grid position it */
            transition: width 0.1s, height 0.1s; /* Smooth resize */
        }
        .obstacle.rock { background-image: url('./sprites/rock.png'); }
        .obstacle.wall_rock { background-image: url('./sprites/wall_rock.png'); }


        /* --- Units --- */
        .unit { grid-column: var(--unit-x, 1); grid-row: var(--unit-y, 1); align-self: center; justify-self: center; border-radius: 3px; display: flex; justify-content: center; align-items: center; font-weight: bold; z-index: 10; transition: filter 0.2s, box-shadow 0.2s, width 0.1s, height 0.1s, opacity var(--death-fade-time) ease-in-out, background-image 0.1s ease-in, transform var(--move-anim-time) ease-out; transform: none; box-sizing: border-box; background-color: transparent; image-rendering: pixelated; background-size: contain; background-repeat: no-repeat; background-position: center; pointer-events: none; width: calc(var(--cell-size) * 0.8); height: calc(var(--cell-size) * 0.8); opacity: 1; filter: none; }
        #game-board .unit { pointer-events: auto; } /* Make units on board interactive */
        .unit.is-moving { z-index: 15; }
        .unit.selected { box-shadow: 0 0 0 clamp(1px, 0.5vmin, 3px) yellow; z-index: 13; }
        .unit.selected:not(:hover) { filter: drop-shadow(0 0 3px yellow); }
        .unit.acted:not(:hover):not(.is-moving) { filter: grayscale(50%) brightness(80%); }
        .unit.frozen:not(:hover):not(.is-moving) { filter: var(--frozen-filter); box-shadow: var(--frozen-shadow); }
        .unit.selected.frozen:not(:hover):not(.is-moving) { filter: var(--frozen-filter) drop-shadow(0 0 3px yellow); box-shadow: var(--frozen-shadow), 0 0 0 clamp(1px, 0.5vmin, 3px) yellow; }
        .unit.unit-hit-flash { animation: simple-hit-flash 0.2s ease-out; }
        @keyframes simple-hit-flash { 50% { filter: brightness(1.8); } }
        /* Simplified Unit Hover */
        #game-board .unit:not(.dead):not(.fading-out):not(.selected):not(.is-moving):hover {
            z-index: 12;
            cursor: pointer;
        }
        #game-board .unit.player:not(.dead):not(.fading-out):not(.selected):not(.is-moving):hover {
            filter: drop-shadow( 1px 0px 0 var(--hover-outline-color-player)) drop-shadow(-1px 0px 0 var(--hover-outline-color-player)) drop-shadow( 0px 1px 0 var(--hover-outline-color-player)) drop-shadow( 0px -1px 0 var(--hover-outline-color-player));
        }
        #game-board .unit.enemy:not(.dead):not(.fading-out):not(.selected):not(.is-moving):hover {
            filter: drop-shadow( 1px 0px 0 var(--hover-outline-color-enemy)) drop-shadow(-1px 0px 0 var(--hover-outline-color-enemy)) drop-shadow( 0px 1px 0 var(--hover-outline-color-enemy)) drop-shadow( 0px -1px 0 var(--hover-outline-color-enemy));
        }
        .unit.dead { z-index: 5; pointer-events: none !important; filter: none !important; box-shadow: none !important; opacity: 1; transition: opacity var(--death-fade-time) ease-in-out; transform: none !important; }
        .unit.fading-out { opacity: 0 !important; }

        /* --- Projectiles --- */
        .projectile {
            position: absolute;
            width: 15px; height: 15px;
            background-size: contain; background-repeat: no-repeat; background-position: center;
            z-index: 22; pointer-events: none; image-rendering: pixelated;
            transform-origin: center center;
            transition: left var(--arrow-fly-time) linear, top var(--arrow-fly-time) linear;
        }
        .projectile.arrow {
            background-image: url('./sprites/arrow.png');
            width: 20px; height: 5px;
        }


        /* --- UI Panel --- */
        #ui-panel { width: clamp(180px, 28vmin, 240px); flex-shrink: 0; max-height: 100%; padding: clamp(0.8rem, 1.5vmin, 1.5rem); background-color: #4a5a4a; border-left: clamp(1px, 0.4vmin, 3px) solid #1e281e; display: flex; flex-direction: column; justify-content: space-between; overflow-y: auto; font-size: 1.4rem; box-sizing: border-box; position: relative; }
        #level-display { text-align: center; margin-bottom: 1rem; font-weight: bold; color: #ffd700; background-color:#5a6a5a; padding: 0.5rem; border: 1px solid #1e281e; border-radius: 3px; font-size: 1.6rem; }
        #unit-info, #turn-info { background-color: #5a6a5a; padding: 1rem; margin-bottom: 1.5rem; border: 1px solid #1e281e; border-radius: 3px; min-height: 7rem; }
        #unit-info h3, #turn-info h3 { margin-top: 0; margin-bottom: 0.8rem; border-bottom: 1px solid #7a8a7a; padding-bottom: 0.5rem; color: #eee; font-size: 1.5rem; }
        #unit-info p, #turn-info p { margin: 0.4rem 0; font-size: 1.3rem; color: #ddd; line-height: 1.4; }
        #unit-status { color: #aadeff; font-style: italic; min-height: 1.4em; }

        /* Spell Area Grid Layout */
        #spell-area {
            margin-top: auto; margin-bottom: 1.5rem; padding: clamp(0.5rem, 1vmin, 1rem);
            background-color:#5a6a5a; border: 1px solid #1e281e; border-radius: 3px;
            min-height: auto; display: grid; grid-template-columns: repeat(2, 1fr);
            gap: clamp(8px, 1.5vmin, 15px); place-items: center; align-content: center;
        }
        .spell-container { display: flex; flex-direction: column; align-items: center; text-align: center; width: 100%; }
        .spell-icon { display: inline-block; width: clamp(30px, 4.5vmin, 40px); height: clamp(30px, 4.5vmin, 40px); border: clamp(1px, 0.3vmin, 2px) solid #333; border-radius: 4px; background-color: #444; background-size: contain; background-repeat: no-repeat; background-position: center; margin-bottom: 3px; transition: border-color 0.2s, box-shadow 0.2s, filter 0.2s; image-rendering: pixelated; vertical-align: middle; filter: none; cursor: default; box-shadow: none; }
        #fireball-spell { background-image: url('./sprites/sFireball1.png'); }
        #flame-wave-spell { background-image: url('./sprites/sFireball1.png'); }
        #frost-nova-spell { background-image: url('./sprites/sFrostbolt1.png'); }
        #heal-spell { background-image: url('./sprites/heal.png'); }
        .spell-label { font-size: clamp(0.9rem, 1.5vmin, 1.1rem); font-weight: bold; color: #eee; text-shadow: 1px 1px #111; line-height: 1.2; }
        .spell-icon.locked { filter: var(--spell-locked-filter); cursor: not-allowed; border-color: #553333; }
        .spell-icon.locked + .spell-label { color: #f88; }
        .spell-icon.used { filter: var(--spell-used-filter); cursor: not-allowed; border-color: #555; }
        .spell-icon.used + .spell-label { color: #aaa; }
        .spell-icon.available { filter: none; cursor: pointer; border-color: #888; }
        .spell-icon.available:hover { border-color: #eee; }
        .spell-icon.available + .spell-label { color: #eee; }
        .spell-icon.selected { filter: none !important; cursor: pointer; border-color: yellow !important; box-shadow: 0 0 8px yellow !important; }
        .spell-icon.selected + .spell-label { color: #eee; }

        #feedback-area { margin-bottom: 1rem; min-height: 2rem; font-size: 1.4rem; font-weight: bold; color: #fff; text-align: center; }
        .feedback-levelup { color: #ffd700; text-shadow: 1px 1px #443300; }
        .feedback-error { color: #ff8888; text-shadow: 1px 1px #550000; }
        #end-turn-button { padding: 1rem 1.5rem; background-color: #a0522d; border: 2px solid #1e281e; color: white; font-family: 'Courier New', Courier, monospace; cursor: pointer; font-size: 1.4rem; border-radius: 3px; text-align: center; transition: background-color 0.2s; width: 100%; box-sizing: border-box;}
        #end-turn-button:hover { background-color: #8B4513; }
        #end-turn-button.disabled { background-color: #888; cursor: not-allowed; color: #bbb; }

        /* --- UI Buttons --- */
        .ui-button { position: absolute; top: 5px; padding: 3px 5px; background-color: rgba(30, 40, 30, 0.6); border: 1px solid #7a8a7a; color: #eee; font-size: 1.6rem; line-height: 1; border-radius: 3px; cursor: pointer; z-index: 55; transition: background-color 0.2s; min-width: 25px; min-height: 25px; display: inline-flex; justify-content: center; align-items: center; user-select: none; -webkit-tap-highlight-color: transparent; }
        .ui-button:hover { background-color: rgba(60, 80, 60, 0.8); } .ui-button:disabled { opacity: 0.5; cursor: not-allowed; } #fullscreen-button { right: 5px; } #mute-button { right: 40px; }

        /* --- Popups & Overlays --- */
        .damage-popup, .freeze-popup, .heal-popup { position: absolute; font-weight: bold; animation: moveUpFadeOut 1s forwards; z-index: 30; /* Above projectiles */ pointer-events: none; }
        .damage-popup { color: red; font-size: clamp(1.2rem, 2vmin, 1.8rem); text-shadow: 1px 1px white; }
        .freeze-popup { color: #aadeff; font-size: clamp(1.2rem, 2vmin, 1.6rem); text-shadow: 1px 1px #112233; animation-duration: 0.8s; }
        .heal-popup { color: var(--heal-color); font-size: clamp(1.2rem, 2vmin, 1.8rem); text-shadow: 1px 1px #003300; }
        @keyframes moveUpFadeOut { 0% { opacity: 1; transform: translateY(0) translateX(-50%); } 100% { opacity: 0; transform: translateY(-30px) translateX(-50%); } } /* Added translateX for centering */
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; text-align: center; z-index: 50; padding: 20px; box-sizing: border-box; }
        .overlay h2 { color: #ffd700; margin-bottom: 2rem; font-size: clamp(2rem, 6vmin, 2.5rem); }
        .overlay p { font-size: clamp(1.2rem, 4vmin, 1.5rem); line-height: 1.6; margin-bottom: 2rem;}
        .overlay button { padding: clamp(0.8rem, 3vmin, 1rem) clamp(1.5rem, 6vmin, 2rem); font-size: clamp(1.2rem, 4vmin, 1.6rem); cursor: pointer; background-color: #a0522d; border: 2px solid #1e281e; color: white; font-family: 'Courier New', Courier, monospace; border-radius: 3px; }
        .overlay button:hover { background-color: #8B4513; }

        /* --- Media Query --- */
        @media (max-width: 700px), (max-aspect-ratio: 1/1) {
             #game-container { flex-direction: column; justify-content: flex-start; align-items: stretch; }
             #game-board { width: 100%; height: auto; margin: 0; min-height: calc(160px / var(--board-aspect-ratio)); }
             #ui-panel { width: 100%; height: auto; flex-grow: 1; flex-shrink: 1; border-left: none; border-top: clamp(1px, 0.4vmin, 3px) solid #1e281e; min-height: 100px; max-height: 40vh; font-size: 1.3rem; }
             .ui-button { top: 3px; font-size: 1.4rem; } #fullscreen-button { right: 3px; } #mute-button { right: 35px; }
             #unit-info h3, #turn-info h3 { font-size: 1.4rem;} #unit-info p, #turn-info p { font-size: 1.2rem;}
             #game-container:fullscreen > #ui-panel { border-top-color: #333; }
             .spell-icon { width: clamp(28px, 4.5vmin, 40px); height: clamp(28px, 4.5vmin, 40px); }
             .spell-label { font-size: 1.0rem; }
             /* Ensure cell size var is updated for smaller views if needed, though calculateCellSize handles it */
             /* .unit, .obstacle { width: calc(var(--cell-size) * 0.8); height: calc(var(--cell-size) * 0.8); } */ /* Already dynamic */
         }
    </style>
</head>
<body>
    <!-- HTML structure -->
    <div id="game-container">
        <div id="game-board"></div>
        <div id="ui-panel">
            <button id="mute-button" class="ui-button" title="Toggle Sound (M)">🔊</button>
            <button id="fullscreen-button" class="ui-button" title="Toggle Fullscreen (F)" disabled>&#x26F6;</button>
            <div id="level-display">Level: 1</div>
            <div id="turn-info"><h3 id="current-turn">Turn: Player</h3><p id="actions-left">Actions Left: 0</p></div>
            <div id="unit-info"><h3>Unit Info</h3><p id="unit-name"></p><p id="unit-hp">HP: -/-</p><p id="unit-atk">ATK: -</p><p id="unit-mov">MOV: -</p><p id="unit-status"></p></div>
             <!-- Spell Area -->
            <div id="spell-area">
                 <div id="fireball-container" class="spell-container">
                     <div id="fireball-spell" class="spell-icon locked" title="Unlock at Level 4"></div>
                     <span class="spell-label">Fireball [1]</span>
                 </div>
                 <div id="flame-wave-container" class="spell-container">
                     <div id="flame-wave-spell" class="spell-icon locked" title="Unlock at Level 8"></div>
                     <span class="spell-label">Flame Wave [2]</span>
                 </div>
                 <div id="frost-nova-container" class="spell-container">
                     <div id="frost-nova-spell" class="spell-icon locked" title="Unlock at Level 12"></div>
                     <span class="spell-label">Frost Nova [3]</span>
                 </div>
                 <div id="heal-container" class="spell-container">
                     <div id="heal-spell" class="spell-icon locked" title="Unlock at Level 16"></div>
                     <span class="spell-label">Heal [4]</span>
                 </div>
             </div>
            <div id="feedback-area"></div>
            <button id="end-turn-button" title="End Player Turn (E)">[E]nd Turn</button>
        </div>
        <div id="start-screen" class="overlay"><h2>Knights Vs Goblins</h2><p>Defeat all Goblins to advance levels.<br>Spells can only be used ONCE per level!</p><button id="start-button">Begin Conquest!</button></div>
        <div id="game-over-screen" class="overlay" style="display: none;"><h2 id="game-over-title">Defeat!</h2><p id="game-over-message"></p><button id="restart-button">Restart</button></div>
    </div>

    <script>
        // --- DOM Elements ---
        const gameContainer = document.getElementById('game-container');
        const gameBoard = document.getElementById('game-board');
        const uiPanel = document.getElementById('ui-panel');
        const levelDisplayElement = document.getElementById('level-display');
        const spellAreaElement = document.getElementById('spell-area');
        const fireballElement = document.getElementById('fireball-spell');
        const flameWaveElement = document.getElementById('flame-wave-spell');
        const frostNovaElement = document.getElementById('frost-nova-spell');
        const healElement = document.getElementById('heal-spell');
        const turnInfo = document.getElementById('turn-info');
        const unitInfo = document.getElementById('unit-info');
        const currentTurnDisplay = document.getElementById('current-turn');
        const actionsLeftDisplay = document.getElementById('actions-left');
        const unitNameDisplay = document.getElementById('unit-name');
        const unitHpDisplay = document.getElementById('unit-hp');
        const unitAtkDisplay = document.getElementById('unit-atk');
        const unitMovDisplay = document.getElementById('unit-mov');
        const unitStatusDisplay = document.getElementById('unit-status');
        const feedbackArea = document.getElementById('feedback-area');
        const endTurnButton = document.getElementById('end-turn-button');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const gameOverTitle = document.getElementById('game-over-title');
        const gameOverMessage = document.getElementById('game-over-message');
        const fullscreenButton = document.getElementById('fullscreen-button');
        const muteButton = document.getElementById('mute-button');

        // --- Audio Setup ---
        const musicTracks = [ 'audio/music_Treasure.mp3', 'audio/music_AoiUsagi-Die.mp3', 'audio/music_WormsTheme.mp3', 'audio/bgm.mp3' ];
        const sfx = { success: new Audio('audio/Success.wav'), error: new Audio('audio/Error.wav'), gameOver: new Audio('audio/GameOver.wav'), hit: new Audio('audio/sfxHit.wav'), defeat: new Audio('audio/sfxGoblinDead.wav'), move: new Audio('audio/sfxMove.wav'), select: new Audio('audio/sfxSelect.wav'), fireballCast: new Audio('audio/sfxFireballCast.wav'), fireballHit: new Audio('audio/sfxFireballHit.wav'), frostNovaCast: new Audio('audio/sfxFrostboltCast.wav'), frostNovaHit: new Audio('audio/sfxFrostboltHit.wav'), playerDie: new Audio('audio/player_die.wav'), startBeep: new Audio('audio/start_beep.wav'), heal: new Audio('audio/heal.wav'), arrowShoot: new Audio('audio/arrow_shoot.wav') /* Placeholder */ };
        let bgMusic = new Audio(); bgMusic.loop = true; bgMusic.volume = 0.3;
        let isMuted = false; let audioInitialized = false;
        Object.values(sfx).forEach(sound => { sound.volume = 0.6; sound.preload = 'auto'; });
        sfx.gameOver.volume = 0.8; sfx.fireballHit.volume = 0.8; sfx.frostNovaHit.volume = 0.7; sfx.move.volume = 0.4; sfx.select.volume = 0.5; sfx.hit.volume = 0.7; sfx.defeat.volume = 0.7; sfx.playerDie.volume = 0.7; sfx.heal.volume = 0.7; sfx.arrowShoot.volume = 0.5;

        // --- Audio Helpers ---
        function playSfx(sound) { if (isMuted || !audioInitialized || !sound) return; try { sound.currentTime = 0; sound.play().catch(e => console.warn(`SFX Play Fail: ${sound.src.split('/').pop()} - ${e.name} (${e.message})`)); } catch(e) { console.error("SFX play error", e); }}
        function startMusic() { if (isMuted || !audioInitialized) return; if (!bgMusic.src) { selectAndLoadMusic(); if (!bgMusic.src) { return; } } const playPromise = bgMusic.play(); if (playPromise !== undefined) { playPromise.catch(error => { if (error.name === 'NotAllowedError') { console.log("Music autoplay blocked."); } }); } }
        function stopMusic() { if (bgMusic && !bgMusic.paused) { bgMusic.pause(); bgMusic.currentTime = 0; } }
        function selectAndLoadMusic() { const i = Math.floor(Math.random() * musicTracks.length); const t = musicTracks[i]; bgMusic.src = t; bgMusic.load(); }
        function initializeAudio() { if (audioInitialized) return true; const AC = window.AudioContext || window.webkitAudioContext; if (!AC) { let success = false; try { const dummyAudio = new Audio(); dummyAudio.volume=0; dummyAudio.play().then(()=>{dummyAudio.pause(); success=true;}).catch(()=>{}); } catch(e){} audioInitialized = success; return audioInitialized; } const context = new AC(); const unlockAudio = () => { context.resume().then(() => { audioInitialized = true; startMusicIfNotPlaying(); document.removeEventListener('click', unlockAudio, true); document.removeEventListener('keydown', unlockAudio, true); }).catch(e => {}); }; if (context.state === 'suspended') { document.addEventListener('click', unlockAudio, { once: true, capture: true }); document.addEventListener('keydown', unlockAudio, { once: true, capture: true }); } else { audioInitialized = true; } return audioInitialized; }
        function startMusicIfNotPlaying() { if (!isGameOver() && startScreen.style.display === 'none' && !isMuted && bgMusic.paused) { startMusic(); } }

        // --- Game Config & State ---
        const GRID_COLS = 8; const GRID_ROWS = 10; let currentCellSize = 30;
        const FIREBALL_UNLOCK_LEVEL = 4; const FIREBALL_DAMAGE = 2;
        const FLAME_WAVE_UNLOCK_LEVEL = 8; const FLAME_WAVE_DAMAGE = 1;
        const FROST_NOVA_UNLOCK_LEVEL = 12; const FROST_NOVA_DURATION = 3; // Turns
        const HEAL_UNLOCK_LEVEL = 16; const HEAL_AMOUNT = 3;
        const ARCHER_INTRO_LEVEL = 3; const CLUBBER_INTRO_LEVEL = 7;
        const ARROW_FLY_DURATION_MS = 300;
        const ENEMY_SPAWN_ROWS = 3; // How many rows from the top enemies can spawn
        const PLAYER_SPAWN_ROWS = 2; // How many rows from the bottom players can spawn
        const MIN_OBSTACLES = 2; // Base number of obstacles
        const MAX_OBSTACLES_PER_LEVEL = 0.75; // Max additional obstacles per level (float for scaling)
        const WALL_ROCK_CHANCE = 0.4; // Chance an obstacle is a wall_rock (LoS blocker)

        const UNIT_DATA = {
            knight: { name: "Knight", hp: 6, atk: 1, mov: 3, range: 1, team: 'player', spriteUrl: './sprites/Knight.png', deadSpriteUrl: './sprites/Knight_dead.png' },
            goblin: { name: "Goblin", hp: 2, atk: 1, mov: 4, range: 1, team: 'enemy', spriteUrl: './sprites/Goblin.png', deadSpriteUrl: './sprites/Goblin_dead.png' },
            goblin_archer: { name: "Goblin Archer", hp: 1, atk: 1, mov: 3, range: 4, team: 'enemy', spriteUrl: './sprites/goblin_archer.png', deadSpriteUrl: './sprites/Goblin_dead.png' },
            goblin_clubber: { name: "Goblin Clubber", hp: 3, atk: 2, mov: 3, range: 1, knockback: true, team: 'enemy', spriteUrl: './sprites/goblin_club.png', deadSpriteUrl: './sprites/Goblin_dead.png' }
        };
        const OBSTACLE_TYPES = { // NEW
            rock: { blocksMove: true, blocksLOS: false, spriteClass: 'rock' },
            wall_rock: { blocksMove: true, blocksLOS: true, spriteClass: 'wall_rock' }
        };

        let units = []; let selectedUnit = null; let currentTurn = 'player'; let validMoves = []; let validAttacks = []; let unitCounter = 0; let isProcessing = false;
        let currentLevel = 1; let clickedUnitObject = null;
        let currentSpell = null;
        // **** NEW: spellUses tracks availability PER LEVEL ****
        let spellUses = { fireball: false, flameWave: false, frostNova: false, heal: false };
        let resizeTimeout = null; let winCheckTimeout = null;
        let MOVE_ANIMATION_DURATION_MS = 250;
        let gridState = []; // NEW: 2D array for storing obstacle types ('rock', 'wall_rock', or null)

        // --- Helper Functions ---
        function isUnitAliveAndValid(unit) { return unit && unit.hp > 0 && !unit.element?.classList.contains('dead'); }
        function isCellInBounds(x, y) { return x >= 0 && x < GRID_COLS && y >= 0 && y < GRID_ROWS; } // NEW helper
        function getObstacleAt(x, y) { // NEW helper
            if (!isCellInBounds(x,y) || !gridState[y] || gridState[y].length <= x) return null; // Added bounds check for column
            const obstacleType = gridState[y][x];
            return obstacleType ? OBSTACLE_TYPES[obstacleType] : null;
        }

        // **** NEW: Resets spell state only for a new level ****
        function resetSpellStateForNewLevel() {
            console.log(`Resetting spell charges for level ${currentLevel}.`);
            currentSpell = null; // Still need to clear active selection
            spellUses = {
                fireball: currentLevel >= FIREBALL_UNLOCK_LEVEL,
                flameWave: currentLevel >= FLAME_WAVE_UNLOCK_LEVEL,
                frostNova: currentLevel >= FROST_NOVA_UNLOCK_LEVEL,
                heal: currentLevel >= HEAL_UNLOCK_LEVEL
            };
            console.log("Spell availability:", spellUses);
            updateSpellUI();
            gameBoard.className = ''; // Clear targeting classes
            clearFrostNovaPreview();
            gameBoard.style.removeProperty('--hover-col');
        }

        function resetLevelState() {
             console.log("Resetting level state...");
            units = [];
            unitCounter = 0;
            selectedUnit = null;
            clickedUnitObject = null;
            validMoves = [];
            validAttacks = [];
            currentTurn = 'player';
            gridState = []; // Clear obstacle data
            // **** THIS NOW RESETS SPELLS FOR THE NEW LEVEL ****
            resetSpellStateForNewLevel();
            if(winCheckTimeout) clearTimeout(winCheckTimeout); winCheckTimeout = null;
            if(resizeTimeout) clearTimeout(resizeTimeout); resizeTimeout = null;
            isProcessing = false; // Ensure reset here too
            // Clear visuals: units, popups, projectiles, obstacles
            document.querySelectorAll('#game-board .unit, #game-board .damage-popup, #game-board .freeze-popup, #game-board .heal-popup, #game-board .projectile, #game-board .obstacle').forEach(el => el.remove());
            // Clear cell state classes
            document.querySelectorAll('#game-board .grid-cell').forEach(cell => cell.classList.remove('has-obstacle'));
            clearHighlights();
             console.log("Level state reset complete.");
        }

        // --- Layout & Resize ---
        function calculateCellSize() {
            const boardWidth = gameBoard.clientWidth;
            const boardHeight = gameBoard.clientHeight;
            if (boardWidth > 1 && boardHeight > 1) {
                const cellWidth = Math.floor(boardWidth / GRID_COLS);
                const cellHeight = Math.floor(boardHeight / GRID_ROWS);
                currentCellSize = Math.max(1, Math.min(cellWidth, cellHeight));
            } else {
                currentCellSize = Math.max(currentCellSize, 20); // Fallback minimum
            }
            currentCellSize = Math.max(currentCellSize, 10); // Absolute minimum
            document.documentElement.style.setProperty('--cell-size', `${currentCellSize}px`);
        }
        function applyLayout() {
            if (currentCellSize < 10) calculateCellSize();
            if (currentCellSize < 10) return;
            units.forEach(u => { if (u.element && !u.element.classList.contains('dead')) updateUnitPosition(u, true); });
            document.querySelectorAll('#game-board .unit.dead').forEach(deadEl => { updateUnitPositionVisualsOnly(deadEl); });
            if (selectedUnit) { highlightMoves(selectedUnit); }
        }

        function updateUnitPositionVisualsOnly(element) {
             if (!element) return;
             // Update size based on currentCellSize if needed (handled by CSS var usually)
             // const unitSize = Math.floor(currentCellSize * 0.8);
             // const finalSize = Math.max(unitSize, 8); // Ensure minimum size
             // const newSizePx = `${finalSize}px`;
             // if (element.style.width !== newSizePx) {
             //     element.style.width = newSizePx;
             //     element.style.height = newSizePx;
             // }
        }
        const handleResize = () => { if (resizeTimeout) clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() => { if (isGameOver() || startScreen.style.display !== 'none') return; requestAnimationFrame(() => { try { calculateCellSize(); applyLayout(); } catch (e) { console.error("Resize applyLayout error:", e); }}); }, 100); };

        // --- Fullscreen ---
        function isFullscreen() { return !!(document.fullscreenElement||document.webkitFullscreenElement||document.mozFullScreenElement||document.msFullscreenElement); }
        function toggleFullscreen() { initializeAudio(); const fsEnabled = document.fullscreenEnabled||document.webkitFullscreenEnabled||document.mozFullScreenEnabled||document.msFullscreenEnabled; if (!fsEnabled) return; if (!isFullscreen()) { const el = gameContainer; if (el.requestFullscreen) el.requestFullscreen().catch(err => {}); else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen().catch(err => {}); else if (el.mozRequestFullScreen) el.mozRequestFullScreen().catch(err => {}); else if (el.msRequestFullscreen) el.msRequestFullscreen().catch(err => {}); } else { if (document.exitFullscreen) document.exitFullscreen().catch(err => {}); else if (document.webkitExitFullscreen) document.webkitExitFullscreen().catch(err => {}); else if (document.mozCancelFullScreen) document.mozCancelFullScreen().catch(err => {}); else if (document.msExitFullscreen) document.msExitFullscreen().catch(err => {}); } }
        function updateFullscreenButton() { const fsEnabled = document.fullscreenEnabled||document.webkitFullscreenEnabled||document.mozFullScreenEnabled||document.msFullscreenEnabled; if(fullscreenButton){ fullscreenButton.disabled = !fsEnabled; fullscreenButton.innerHTML=isFullscreen()?'&#x2715;':'&#x26F6;'; fullscreenButton.title=isFullscreen()?'Exit Fullscreen (F)':'Enter Fullscreen (F)'; } }

        // --- Initialization ---
        function initGame() {
            console.clear(); // Clear console for new game
            console.log("Init Game starting...");
            isProcessing = true;
            console.log("isProcessing set to true at init start.");

            if (!audioInitialized) initializeAudio();
            playSfx(sfx.startBeep);
            currentLevel = 1;
            resetLevelState(); // Reset state (also calls resetSpellStateForNewLevel)
            isProcessing = true; // Set again after resetLevelState might have briefly set it false
            console.log("isProcessing set to true after resetLevelState.");

            stopMusic(); sfx.gameOver.pause(); sfx.gameOver.currentTime = 0;
            selectAndLoadMusic();
            console.log(`Start Game - Lvl ${currentLevel}`);

            try {
                setupBoard();
                initializeGridState(); // Initialize grid data structure
                updateLevelDisplay();
                updateUnitInfo(null);
                feedbackArea.textContent = ''; feedbackArea.className = '';
                endTurnButton.classList.remove('disabled'); endTurnButton.disabled = false;
                gameOverScreen.style.display = 'none';
                startScreen.style.display = 'none';
                console.log(`Start screen hidden: ${startScreen.style.display}`);

                window.addEventListener('resize', handleResize, { passive: true });
                document.addEventListener('fullscreenchange', updateFullscreenButton);
                document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
                document.addEventListener('mozfullscreenchange', updateFullscreenButton);
                document.addEventListener('MSFullscreenChange', updateFullscreenButton);
                updateFullscreenButton();

                console.log("Requesting animation frame for main init sequence...");
                requestAnimationFrame(() => {
                    console.log("Init rAF started.");
                    try {
                        calculateCellSize();
                        spawnObstacles();
                        spawnInitialUnits();
                        units.forEach(u => { if (u.team === 'player') u.acted = false; u.isFrozen = false; u.frozenTurnsLeft = 0; });
                        renderAllUnits();
                        applyLayout();
                        updateTurnDisplay();
                        startMusicIfNotPlaying();
                    } catch(rafError) {
                        console.error("Init rAF Main Error:", rafError);
                        isProcessing = false;
                        updateTurnDisplay();
                        console.error("isProcessing forced to false due to rAF error.");
                    } finally {
                        isProcessing = false;
                        updateTurnDisplay();
                        console.log("Init rAF finished. isProcessing set to false. Input should be enabled.");
                    }
                });
            } catch (initError) {
                 console.error("Outer Init Error (before rAF):", initError);
                 isProcessing = false;
                 updateTurnDisplay();
                 console.error("isProcessing forced to false due to outer init error.");
            }
        }

        // --- Board & Spawning ---
        function setupBoard() { gameBoard.innerHTML = ''; gameBoard.className = ''; for (let r = 0; r < GRID_ROWS; r++) { for (let c = 0; c < GRID_COLS; c++) { const cell = document.createElement('div'); cell.classList.add('grid-cell'); cell.dataset.x = c; cell.dataset.y = r; cell.addEventListener('click', handleCellClick); cell.addEventListener('mouseenter', handleCellMouseEnter); cell.addEventListener('mouseleave', handleCellMouseLeave); cell.style.gridColumn = c + 1; cell.style.gridRow = r + 1; gameBoard.appendChild(cell); } } gameBoard.addEventListener('mouseover', handleMouseEnterOnBoard); gameBoard.addEventListener('mouseleave', handleMouseLeaveOnBoard); }
        function initializeGridState() { gridState = Array.from({ length: GRID_ROWS }, () => Array(GRID_COLS).fill(null)); console.log("Grid state initialized."); }
        function spawnObstacles() {
            const numObstacles = MIN_OBSTACLES + Math.floor(currentLevel * MAX_OBSTACLES_PER_LEVEL);
            const validSpawnMinY = ENEMY_SPAWN_ROWS; const validSpawnMaxY = GRID_ROWS - PLAYER_SPAWN_ROWS - 1;
            let spawnedCount = 0; let attempts = 0; const maxAttempts = numObstacles * 20;
            console.log(`Attempting to spawn ${numObstacles} obstacles between rows ${validSpawnMinY} and ${validSpawnMaxY}.`);
            if (validSpawnMinY > validSpawnMaxY) { console.warn("No valid rows for obstacle spawning."); return; }

            while (spawnedCount < numObstacles && attempts < maxAttempts) {
                attempts++; const x = Math.floor(Math.random() * GRID_COLS); const y = Math.floor(Math.random() * (validSpawnMaxY - validSpawnMinY + 1)) + validSpawnMinY;
                if (isCellInBounds(x, y) && gridState[y] && gridState[y][x] === null) {
                    const isWall = Math.random() < WALL_ROCK_CHANCE; const obstacleType = isWall ? 'wall_rock' : 'rock'; gridState[y][x] = obstacleType;
                    const obstacleData = OBSTACLE_TYPES[obstacleType]; const obsEl = document.createElement('div'); obsEl.classList.add('obstacle', obstacleData.spriteClass); obsEl.style.gridColumn = x + 1; obsEl.style.gridRow = y + 1; gameBoard.appendChild(obsEl);
                    const cellEl = getCellElement(x, y); if (cellEl) cellEl.classList.add('has-obstacle');
                    spawnedCount++;
                }
            }
             if (spawnedCount < numObstacles) console.warn(`Could only spawn ${spawnedCount}/${numObstacles} obstacles after ${maxAttempts} attempts.`);
        }
        function spawnInitialUnits() {
            const occupied = new Set();
            const knightPositions = [{ x: 1, y: GRID_ROWS - 1 }, { x: 3, y: GRID_ROWS - 1 }, { x: 5, y: GRID_ROWS - 1 }, { x: 7, y: GRID_ROWS - 1 }, { x: 0, y: GRID_ROWS - 2 }, { x: 2, y: GRID_ROWS - 2 }, { x: 4, y: GRID_ROWS - 2 }, { x: 6, y: GRID_ROWS - 2 }];
            let numKnights = 3 + Math.floor(currentLevel / 6); numKnights = Math.min(numKnights, knightPositions.length);
            let knightsSpawned = 0;
            for (let i = 0; i < knightPositions.length && knightsSpawned < numKnights; i++) {
                const p = knightPositions[i];
                 if (isCellInBounds(p.x, p.y) && gridState[p.y] && gridState[p.y][p.x] === null) { createUnit('knight', p.x, p.y); occupied.add(`${p.x},${p.y}`); knightsSpawned++; }
                 else { console.warn(`Skipping knight spawn at (${p.x}, ${p.y}) - Out of bounds or obstacle present.`); }
            }
            if (knightsSpawned < numKnights) console.warn(`Could only spawn ${knightsSpawned}/${numKnights} knights due to obstacles.`);

            const numEnemies = 3 + currentLevel; let spawnedEnemies = 0; const unitsToSpawn = [];
            if (currentLevel === ARCHER_INTRO_LEVEL) { unitsToSpawn.push('goblin_archer'); for (let i=0; i<numEnemies-1; i++) unitsToSpawn.push('goblin'); }
            else if (currentLevel === CLUBBER_INTRO_LEVEL) { unitsToSpawn.push('goblin_clubber'); const remaining = ['goblin']; if (currentLevel >= ARCHER_INTRO_LEVEL) remaining.push('goblin_archer'); for (let i=0; i<numEnemies-1; i++) unitsToSpawn.push(remaining[Math.floor(Math.random() * remaining.length)]); }
            else { const types = ['goblin']; if (currentLevel >= ARCHER_INTRO_LEVEL) types.push('goblin_archer'); if (currentLevel >= CLUBBER_INTRO_LEVEL) types.push('goblin_clubber'); for (let i=0; i<numEnemies; i++) unitsToSpawn.push(types[Math.floor(Math.random() * types.length)]); }

            for (const typeToSpawn of unitsToSpawn) {
                let spawned = false; let attempts = 0; const maxAttempts = GRID_COLS * ENEMY_SPAWN_ROWS * 3;
                while (!spawned && attempts < maxAttempts) {
                    attempts++; const x = Math.floor(Math.random() * GRID_COLS); const y = Math.floor(Math.random() * ENEMY_SPAWN_ROWS); const key = `${x},${y}`;
                    if (isCellInBounds(x, y) && gridState[y] && gridState[y][x] === null && !occupied.has(key)) { createUnit(typeToSpawn, x, y); occupied.add(key); spawned = true; spawnedEnemies++; }
                }
                if (!spawned) console.warn(`Enemy spawn failed for type ${typeToSpawn}. Could not find empty, non-obstacle spot.`);
            }
            console.log(`Spawned ${knightsSpawned} Knights, ${spawnedEnemies} Enemies (Target: ${numEnemies}).`);
        }
        function createUnit(type, x, y) { const data = UNIT_DATA[type]; if(!data) { console.warn(`Unit data not found for type: ${type}`); return; } const unit={id:unitCounter++,type,x,y,hp:data.hp,maxHp:data.hp,atk:data.atk,mov:data.mov,range:data.range, knockback: data.knockback || false, team:data.team,acted:false,element:null, deadSpriteUrl: data.deadSpriteUrl, isFrozen: false, frozenTurnsLeft: 0 }; units.push(unit); }

        // --- Rendering ---
        function renderAllUnits() { document.querySelectorAll('#game-board .unit').forEach(el => el.remove()); units.forEach(unit => renderUnit(unit)); }
        function renderUnit(unit) { if (unit.element?.parentNode) { unit.element.parentNode.removeChild(unit.element); } const el = document.createElement('div'); el.classList.add('unit', unit.team); el.dataset.id = unit.id; const data = UNIT_DATA[unit.type]; if (data?.spriteUrl) el.style.backgroundImage = `url('${data.spriteUrl}')`; el.classList.toggle('selected', selectedUnit?.id === unit.id); el.classList.toggle('acted', unit.acted); el.classList.toggle('frozen', unit.isFrozen); el.addEventListener('click', (ev) => { handleUnitClick(ev, unit); }); unit.element = el; gameBoard.appendChild(el); updateUnitPosition(unit, true); } // Force size update on initial render
        function updateUnitPosition(unit, forceUpdateSize = false) { if (!unit?.element || unit.element.classList.contains('dead')) return; const targetCol = unit.x + 1; const targetRow = unit.y + 1; if (unit.element.style.gridColumn !== `${targetCol}`) { unit.element.style.gridColumn = `${targetCol}`; } if (unit.element.style.gridRow !== `${targetRow}`) { unit.element.style.gridRow = `${targetRow}`; } unit.element.classList.toggle('acted', unit.acted); unit.element.classList.toggle('selected', selectedUnit?.id === unit.id); unit.element.classList.toggle('frozen', unit.isFrozen); if (!unit.element.classList.contains('is-moving') && (!unit.element.style.transform || unit.element.style.transform !== 'none')) { unit.element.style.transform = 'none'; } unit.element.style.opacity = '1'; }
        function clearHighlights() { document.querySelectorAll('.grid-cell.valid-move, .grid-cell.valid-attack').forEach(c => c.classList.remove('valid-move', 'valid-attack')); validMoves = []; validAttacks = []; }
        function highlightMoves(unit) { clearHighlights(); if (!unit || unit.acted || unit.isFrozen || !isUnitAliveAndValid(unit)) return; validMoves = getValidMoves(unit); validAttacks = getValidAttacks(unit); validMoves.forEach(p => { const c = getCellElement(p.x, p.y); if (c && !c.classList.contains('has-obstacle')) c.classList.add('valid-move'); }); validAttacks.forEach(id => { const targetUnit = units.find(u => u.id === id); if (isUnitAliveAndValid(targetUnit)) { const c = getCellElement(targetUnit.x, targetUnit.y); if (c && !c.classList.contains('has-obstacle')) c.classList.add('valid-attack'); } }); }
        function showPopup(x, y, text, className) { const popup = document.createElement('div'); popup.classList.add(className); popup.textContent = text; const boardRect = gameBoard.getBoundingClientRect(); const cellEl = getCellElement(x, y); if (!cellEl) return; const cellRect = cellEl.getBoundingClientRect(); const popupX = cellRect.left - boardRect.left + cellRect.width / 2; const popupY = cellRect.top - boardRect.top + cellRect.height / 2 - 15; popup.style.left = `${popupX}px`; popup.style.top = `${popupY}px`; popup.style.transform = 'translateX(-50%)'; gameBoard.appendChild(popup); const duration = (className === 'freeze-popup') ? 800 : 1000; setTimeout(() => popup.remove(), duration); }
        function showDamagePopup(x, y, damage) { showPopup(x, y, `-${damage}`, 'damage-popup'); }
        function showFreezePopup(x, y) { showPopup(x, y, `Frozen!`, 'freeze-popup'); }
        function showHealPopup(x, y, amount) { showPopup(x, y, `+${amount}`, 'heal-popup'); }

        // --- UI Updates ---
        function updateLevelDisplay() { if(levelDisplayElement) levelDisplayElement.textContent=`Level: ${currentLevel}`; }
        function updateSpellUI() {
            const spellData = [
                {el: fireballElement,  name: 'fireball',  unlock: FIREBALL_UNLOCK_LEVEL, label: "Fireball"},
                {el: flameWaveElement, name: 'flameWave', unlock: FLAME_WAVE_UNLOCK_LEVEL, label: "Flame Wave"},
                {el: frostNovaElement, name: 'frostNova', unlock: FROST_NOVA_UNLOCK_LEVEL, label: "Frost Nova"},
                {el: healElement,      name: 'heal',      unlock: HEAL_UNLOCK_LEVEL, label: "Heal"}
            ];

            spellData.forEach(spell => {
                const isUnlocked = currentLevel >= spell.unlock;
                // **** Check level-based availability ****
                const isAvailableThisLevel = spellUses[spell.name];
                if (!spell.el) return;
                spell.el.className = 'spell-icon'; // Reset classes

                if (!isUnlocked) {
                    spell.el.classList.add('locked');
                    spell.el.title = `Unlock at Level ${spell.unlock}`;
                } else if (!isAvailableThisLevel) { // If unlocked but not available this level
                    spell.el.classList.add('used');
                    // **** Updated Tooltip ****
                    spell.el.title = `${spell.label} (Used this level)`;
                } else { // Unlocked and available this level
                    spell.el.classList.add('available');
                    spell.el.title = spell.label;
                    if (currentSpell === spell.name) {
                        spell.el.classList.add('selected');
                    }
                }
            });

            // Update board targeting classes (no change needed here)
            gameBoard.classList.toggle('fireball-targeting', currentSpell === 'fireball');
            gameBoard.classList.toggle('flame-wave-targeting', currentSpell === 'flameWave');
            gameBoard.classList.toggle('frost-nova-targeting', currentSpell === 'frostNova');
            gameBoard.classList.toggle('heal-targeting', currentSpell === 'heal');
        }
        function updateTurnDisplay() {
            if(!currentTurnDisplay || !actionsLeftDisplay || !endTurnButton) return; // Guard
            const isPlayer = currentTurn === 'player';
            currentTurnDisplay.textContent = `Turn: ${isPlayer ? 'Player' : 'Enemy'}`;
            let btnDisabled = false;
            let btnClassDisabled = false;
            if (isPlayer) {
                const rem = units.filter(u => u.team === 'player' && !u.acted && !u.isFrozen && isUnitAliveAndValid(u)).length;
                actionsLeftDisplay.textContent = `Actions Left: ${rem}`;
                btnDisabled = isProcessing;
                btnClassDisabled = isProcessing;
            } else {
                actionsLeftDisplay.textContent = `AI Thinking...`;
                btnDisabled = true;
                btnClassDisabled = true;
            }
            endTurnButton.disabled = btnDisabled;
            endTurnButton.classList.toggle('disabled', btnClassDisabled);
        }
        function updateUnitInfo(unit) {
             clickedUnitObject = unit; // Update clicked unit ref
             if (isUnitAliveAndValid(unit)) {
                 const data = UNIT_DATA[unit.type];
                 unitNameDisplay.textContent = `${data?.name || unit.type}`;
                 unitHpDisplay.textContent = `HP:${unit.hp}/${unit.maxHp}`;
                 unitAtkDisplay.textContent = `ATK:${unit.atk}`;
                 unitMovDisplay.textContent = `MOV:${unit.mov}`;
                 if (unit.isFrozen) { unitStatusDisplay.textContent = `Status: Frozen (${unit.frozenTurnsLeft} turns)`; }
                 else { unitStatusDisplay.textContent = ''; }
             } else {
                 unitNameDisplay.textContent = '-: -'; unitHpDisplay.textContent = '-/-'; unitAtkDisplay.textContent = '-'; unitMovDisplay.textContent = '-'; unitStatusDisplay.textContent = '';
             }
         }
        function showFeedback(message, type = '') { feedbackArea.textContent = message; feedbackArea.className = type; if (type !== 'feedback-levelup') { setTimeout(() => { if (feedbackArea.textContent === message) feedbackArea.textContent = ''; }, 2500); } }

        // --- Spell Selection ---
        function setActiveSpell(spellName) {
             if (!audioInitialized) initializeAudio();
             const wasSelected = currentSpell === spellName;
             currentSpell = null; clearFrostNovaPreview(); gameBoard.style.removeProperty('--hover-col');

             if (wasSelected) { showFeedback(''); playSfx(sfx.select); }
             else if (spellName) {
                 const spellDataMap = {
                     fireball: { unlock: FIREBALL_UNLOCK_LEVEL, available: spellUses.fireball, feedback: 'Select ENEMY target for Fireball.' },
                     flameWave: { unlock: FLAME_WAVE_UNLOCK_LEVEL, available: spellUses.flameWave, feedback: 'Click target ROW for Flame Wave.' },
                     frostNova: { unlock: FROST_NOVA_UNLOCK_LEVEL, available: spellUses.frostNova, feedback: 'Select CENTER cell for Frost Nova.' },
                     heal: { unlock: HEAL_UNLOCK_LEVEL, available: spellUses.heal, feedback: 'Select FRIENDLY unit to Heal.' }
                 };
                 const data = spellDataMap[spellName];
                 const isUnlocked = currentLevel >= data.unlock;
                 const isAvailableThisLevel = data.available; // Checks level-based availability

                 // **** Check unlock AND level-based availability ****
                 if (isProcessing || currentTurn !== 'player' || !isUnlocked || !isAvailableThisLevel) {
                     if (!isUnlocked) { showFeedback(`Unlock at Level ${data.unlock}!`, "feedback-error"); }
                     else if (!isAvailableThisLevel) { // Was unlocked, but already used this level
                        const formattedName = spellName.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                        // **** Updated Feedback ****
                        showFeedback(`${formattedName} already used this level.`, 'feedback-error');
                     } else { showFeedback("Cannot select spell now.", "feedback-error"); }
                     playSfx(sfx.error);
                 } else { // Is unlocked and available this level
                     currentSpell = spellName;
                     deselectUnit();
                     showFeedback(data.feedback);
                     playSfx(sfx.select);
                 }
             }
             updateSpellUI(); // Update visuals for all spells
         }

        // --- Logic Handlers ---
        async function handleCellClick(event) {
            if (event.target.classList.contains('unit') || isProcessing) return;
            if (!audioInitialized) initializeAudio();
            const cell = event.currentTarget; const x = parseInt(cell.dataset.x); const y = parseInt(cell.dataset.y);

             if (!isCellInBounds(x, y) || (gridState[y] && gridState[y][x] !== null)) { playSfx(sfx.error); showFeedback("Cannot target obstacle.", "feedback-error"); if (currentSpell) setActiveSpell(null); if (selectedUnit) deselectUnit(); return; }
            const unitOnCell = getUnitAt(x, y);

            switch (currentSpell) {
                case 'fireball': if (unitOnCell && unitOnCell.team === 'enemy') castFireball(unitOnCell); else { playSfx(sfx.error); showFeedback("Target an ENEMY unit.", "feedback-error"); setActiveSpell(null); } return;
                case 'frostNova': castFrostNova(x, y); return;
                case 'flameWave': castFlameWave(y); return;
                case 'heal': playSfx(sfx.error); showFeedback("Select a FRIENDLY unit.", "feedback-error"); setActiveSpell(null); return;
            }

            if (currentTurn === 'player') {
                if (selectedUnit) {
                    const isMoveValid = validMoves.some(p => p.x === x && p.y === y);
                    if (isMoveValid && !unitOnCell && isCellInBounds(x,y) && gridState[y] && gridState[y][x] === null) {
                        const unitToMove = selectedUnit; if(unitToMove.element) unitToMove.element.classList.remove('selected'); clearHighlights(); selectedUnit = null; isProcessing = true; updateTurnDisplay();
                        await moveUnit(unitToMove, x, y);
                        finishAction(unitToMove); updateUnitInfo(null); isProcessing = false; updateTurnDisplay();
                    } else { playSfx(sfx.error); deselectUnit(); updateUnitInfo(unitOnCell); }
                } else { updateUnitInfo(unitOnCell); }
            } else { updateUnitInfo(unitOnCell); }
        }
        function handleUnitClick(event, clickedUnit) {
            event.stopPropagation();
            if (isProcessing || !isUnitAliveAndValid(clickedUnit)) { deselectUnit(); updateUnitInfo(null); return; }
            if (clickedUnit.isFrozen && currentSpell !== 'heal') { updateUnitInfo(clickedUnit); showFeedback("Unit is Frozen!", "feedback-error"); playSfx(sfx.error); deselectUnit(false); return; }
            if (!audioInitialized) initializeAudio();

            switch (currentSpell) {
                 case 'fireball': if (clickedUnit.team === 'enemy') castFireball(clickedUnit); else { playSfx(sfx.error); showFeedback("Target an ENEMY unit.", "feedback-error"); setActiveSpell(null); updateUnitInfo(clickedUnit); } return;
                 case 'frostNova': castFrostNova(clickedUnit.x, clickedUnit.y); return;
                 case 'flameWave': castFlameWave(clickedUnit.y); return;
                 case 'heal': if (clickedUnit.team === 'player') castHeal(clickedUnit); else { playSfx(sfx.error); showFeedback("Target a FRIENDLY unit.", "feedback-error"); setActiveSpell(null); updateUnitInfo(clickedUnit); } return;
             }

            updateUnitInfo(clickedUnit);
            if (currentTurn === 'player') {
                if (selectedUnit) {
                    if (clickedUnit.team === 'enemy' && validAttacks.includes(clickedUnit.id)) { const attacker = selectedUnit; deselectUnit(false); isProcessing = true; updateTurnDisplay(); attackUnit(attacker, clickedUnit); }
                    else if (clickedUnit.team === 'player' && clickedUnit.id !== selectedUnit.id && !clickedUnit.acted && !clickedUnit.isFrozen) { selectUnit(clickedUnit); }
                    else if (clickedUnit.id === selectedUnit.id) { deselectUnit(); }
                    else { playSfx(sfx.error);
                         if(clickedUnit.team === 'player' && clickedUnit.acted) showFeedback("Unit already acted.", "feedback-error");
                         else if(clickedUnit.team === 'enemy' && !validAttacks.includes(clickedUnit.id)) { const targetExists = units.find(u => u.id === clickedUnit.id && isUnitAliveAndValid(u)); if (targetExists) { if (getDistance(selectedUnit, targetExists) > selectedUnit.range) showFeedback("Enemy out of range.", "feedback-error"); else if (selectedUnit.range > 1 && !hasLineOfSight(selectedUnit.x, selectedUnit.y, targetExists.x, targetExists.y)) showFeedback("Line of sight blocked.", "feedback-error"); else showFeedback("Invalid target.", "feedback-error"); } else showFeedback("Invalid target.", "feedback-error"); }
                         else if (clickedUnit.isFrozen) showFeedback("Unit is Frozen!", "feedback-error");
                         else showFeedback("Invalid action.", "feedback-error"); }
                } else {
                    if (clickedUnit.team === 'player' && !clickedUnit.acted && !clickedUnit.isFrozen) { selectUnit(clickedUnit); }
                    else if (clickedUnit.team === 'player' && clickedUnit.acted) { showFeedback("Unit already acted.", "feedback-error"); playSfx(sfx.error); }
                    else if (clickedUnit.team === 'player' && clickedUnit.isFrozen) { showFeedback("Unit is Frozen!", "feedback-error"); playSfx(sfx.error); }
                }
            }
         }
        function handleMouseEnterOnBoard(event) { if (isProcessing || currentSpell) return; if(event.target.classList.contains('unit') && !event.target.classList.contains('dead')) { const unitId = parseInt(event.target.dataset.id); const hoveredUnit = units.find(un => un.id === unitId); if(hoveredUnit && hoveredUnit !== selectedUnit && hoveredUnit !== clickedUnitObject) { updateUnitInfo(hoveredUnit); } } }
        function handleMouseLeaveOnBoard(event) { if (isProcessing || currentSpell) return; if(event.target.classList.contains('unit') && !event.target.classList.contains('dead')) { const restoreTarget = selectedUnit || (clickedUnitObject && isUnitAliveAndValid(clickedUnitObject) ? clickedUnitObject : null); updateUnitInfo(restoreTarget); } if (currentSpell !== 'flameWave') { gameBoard.style.removeProperty('--hover-col'); } }
        function handleCellMouseEnter(event) { if (isProcessing) return; const cell = event.currentTarget; if (cell.classList.contains('has-obstacle')) { clearFrostNovaPreview(); return; } if (currentSpell === 'flameWave') { const colIndex = parseInt(cell.dataset.x); gameBoard.style.setProperty('--hover-col', colIndex); } else if (currentSpell === 'frostNova') { clearFrostNovaPreview(); const x = parseInt(cell.dataset.x); const y = parseInt(cell.dataset.y); highlightFrostNovaArea(x, y); } }
        function handleCellMouseLeave(event) { if (currentSpell === 'frostNova' && !isProcessing) { clearFrostNovaPreview(); } }
        function highlightFrostNovaArea(centerX, centerY) { for (let dx = -1; dx <= 1; dx++) { for (let dy = -1; dy <= 1; dy++) { const targetX = centerX + dx; const targetY = centerY + dy; if (isCellInBounds(targetX, targetY) && gridState[targetY] && gridState[targetY][targetX] === null) { const cell = getCellElement(targetX, targetY); if (cell) { cell.classList.add('frost-aoe-preview'); } } } } }
        function clearFrostNovaPreview() { document.querySelectorAll('.grid-cell.frost-aoe-preview').forEach(cell => cell.classList.remove('frost-aoe-preview')); }

        // --- Unit Actions ---
        function selectUnit(unit) { if (!unit || unit.acted || unit.isFrozen || unit.team !== 'player' || currentTurn !== 'player' || isProcessing || !isUnitAliveAndValid(unit)) { if (unit?.isFrozen) { showFeedback("Unit is Frozen!", "feedback-error"); playSfx(sfx.error); } return; } if (currentSpell) setActiveSpell(null); if (selectedUnit === unit) return; deselectUnit(false); selectedUnit = unit; if (unit.element) unit.element.classList.add('selected'); highlightMoves(unit); updateUnitInfo(unit); playSfx(sfx.select); }
        function deselectUnit(updateInfo = true) { if (selectedUnit?.element) { selectedUnit.element.classList.remove('selected'); } selectedUnit = null; clearHighlights(); if (updateInfo) { const restoreTarget = (clickedUnitObject && isUnitAliveAndValid(clickedUnitObject)) ? clickedUnitObject : null; updateUnitInfo(restoreTarget); } }
        function finishAction(unit) { if (!unit || unit.acted || !isUnitAliveAndValid(unit)) return; unit.acted = true; console.log(`Action finished: ${unit.type} ${unit.id}`); if (unit.element) { unit.element.classList.add('acted'); unit.element.classList.remove('selected'); } if (selectedUnit?.id === unit.id) { selectedUnit = null; clearHighlights(); } updateUnitPosition(unit); checkWinLossConditions(); }
        function moveUnit(unit, targetX, targetY) {
             return new Promise((resolve) => {
                 if (!unit || unit.isFrozen || !isUnitAliveAndValid(unit) || !unit.element || !isCellInBounds(targetX, targetY) || (gridState[targetY] && gridState[targetY][targetX] !== null)) { console.warn(`Move cancelled for unit ${unit?.id} to invalid cell (${targetX}, ${targetY}) or invalid state.`); resolve(); return; }
                 const startX = unit.x; const startY = unit.y; const deltaX = targetX - startX; const deltaY = targetY - startY; if (deltaX === 0 && deltaY === 0) { resolve(); return; }
                 const translateX = deltaX * currentCellSize; const translateY = deltaY * currentCellSize; unit.element.style.transform = 'none'; unit.element.style.gridColumn = `${startX + 1}`; unit.element.style.gridRow = `${startY + 1}`; unit.element.classList.add('is-moving'); void unit.element.offsetWidth; unit.element.style.transform = `translate(${translateX}px, ${translateY}px)`; playSfx(sfx.move);
                 let moveFinalized = false; const finalizeMove = () => { if (moveFinalized || !unit.element) return; moveFinalized = true; unit.element.removeEventListener('transitionend', transitionEndHandler); unit.element.classList.remove('is-moving'); unit.x = targetX; unit.y = targetY; unit.element.style.transition = 'none'; unit.element.style.transform = 'none'; unit.element.style.gridColumn = `${targetX + 1}`; unit.element.style.gridRow = `${targetY + 1}`; void unit.element.offsetWidth; unit.element.style.transition = ''; resolve(); };
                 const transitionEndHandler = (event) => { if (event.target === unit.element && event.propertyName === 'transform') { finalizeMove(); } }; unit.element.addEventListener('transitionend', transitionEndHandler);
                 setTimeout(() => { if(unit.element && !moveFinalized) { console.warn(`Unit ${unit.id} move finalize fallback triggered.`); finalizeMove(); } else if (!unit.element) { console.warn(`Unit ${unit.id} element removed before move fallback timeout.`); resolve(); } }, MOVE_ANIMATION_DURATION_MS + 50);
             });
         }
        function shootArrow(attacker, defender) {
            const projectile = document.createElement('div');
            projectile.classList.add('projectile', 'arrow');
            const attackerEl = attacker.element;
            const defenderEl = defender.element;
            if (!attackerEl || !defenderEl) return; // Need elements for positioning

            const boardRect = gameBoard.getBoundingClientRect();
            const startRect = attackerEl.getBoundingClientRect();
            const endRect = defenderEl.getBoundingClientRect();

            const startX = startRect.left - boardRect.left + startRect.width / 2;
            const startY = startRect.top - boardRect.top + startRect.height / 2;
            const endX = endRect.left - boardRect.left + endRect.width / 2;
            const endY = endRect.top - boardRect.top + endRect.height / 2;

            const angleRad = Math.atan2(endY - startY, endX - startX);
            const angleDeg = angleRad * (180 / Math.PI);

            projectile.style.left = `${startX}px`;
            projectile.style.top = `${startY}px`;
            projectile.style.transform = `rotate(${angleDeg}deg)`;

            gameBoard.appendChild(projectile);
            playSfx(sfx.arrowShoot);

            // Force reflow to apply initial position before transition
            void projectile.offsetWidth;

            // Set target position and start transition
            projectile.style.left = `${endX}px`;
            projectile.style.top = `${endY}px`;

            // Remove projectile after animation
            setTimeout(() => { projectile.remove(); }, ARROW_FLY_DURATION_MS);
        }
        function attackUnit(attacker, defender) {
            if (!attacker || !defender || attacker.acted || attacker.isFrozen || !isUnitAliveAndValid(attacker) || !isUnitAliveAndValid(defender)) { console.warn(`Attack cancelled pre-cond: A=${attacker?.id}(Acted:${attacker?.acted},Frozen:${attacker?.isFrozen},HP:${attacker?.hp}) D=${defender?.id}(HP:${defender?.hp})`); if (currentTurn === 'enemy' && attacker && !attacker.acted && !attacker.isFrozen && isUnitAliveAndValid(attacker)) { finishAction(attacker); } else if (currentTurn === 'player'){ isProcessing = false; updateTurnDisplay(); } return; }
            const attackerElement = attacker.element; const defenderElement = defender.element; if (!attackerElement?.parentNode || !defenderElement?.parentNode) { console.warn("Attack cancelled: Attacker or defender element missing."); if (currentTurn === 'enemy' && attacker && !attacker.acted && !attacker.isFrozen && isUnitAliveAndValid(attacker)) { finishAction(attacker); } else if(currentTurn === 'player') { isProcessing = false; updateTurnDisplay(); } return; }

            const originalZIndex = window.getComputedStyle(attackerElement).zIndex || '10'; const attackZIndex = '25'; const distance = getDistance(attacker, defender); const isRangedArcherAttack = attacker.type === 'goblin_archer' && distance > 1;

            if (isRangedArcherAttack) shootArrow(attacker, defender);

            const deltaX = defender.x - attacker.x; const deltaY = defender.y - attacker.y; const tapDistanceFactor = 0.4 * currentCellSize; const translateX = deltaX * tapDistanceFactor; const translateY = deltaY * tapDistanceFactor; const transformValue = `translate(${translateX}px, ${translateY}px)`;
            const animDurationString = getComputedStyle(document.documentElement).getPropertyValue('--attack-anim-time').trim().toLowerCase(); let animDurationMs = 80; if (animDurationString.endsWith('ms')) animDurationMs = parseFloat(animDurationString); else if (animDurationString.endsWith('s')) animDurationMs = parseFloat(animDurationString) * 1000;
            const strikePause = 50; const returnPause = 60; const damage = attacker.atk; const isFatal = damage >= defender.hp; let defenderDiedVisually = false;

            if (isFatal) {
                defender.hp = 0; const defenderData = UNIT_DATA[defender.type]; if (defenderData?.deadSpriteUrl) { defenderElement.style.backgroundImage = `url('${defenderData.deadSpriteUrl}')`; }
                defenderElement.classList.add('dead'); defenderElement.classList.remove('selected', 'acted', 'unit-hit-flash', 'player', 'enemy', 'valid-attack', 'valid-move', 'frozen'); defenderElement.style.filter = 'none'; defenderElement.style.boxShadow = 'none'; defenderElement.style.transform = 'none'; defenderElement.style.pointerEvents = 'none';
                playSfx(defender.team === 'player' ? sfx.playerDie : sfx.defeat); defenderDiedVisually = true; if (clickedUnitObject?.id === defender.id) { updateUnitInfo(null); }
            }

            if (!isRangedArcherAttack) { attackerElement.style.zIndex = attackZIndex; attackerElement.style.transform = transformValue; if (!defenderDiedVisually) { playSfx(sfx.move); } }
            const impactDelay = isRangedArcherAttack ? Math.max(ARROW_FLY_DURATION_MS, animDurationMs + strikePause) : animDurationMs + strikePause;

            setTimeout(() => {
                if (attackerElement?.parentNode && !isRangedArcherAttack) { attackerElement.style.transform = 'none'; attackerElement.style.zIndex = originalZIndex; }
                else if (!attackerElement?.parentNode) console.warn(`Attacker ${attacker.id} removed mid-anim return.`);
                const effectDelay = isRangedArcherAttack ? 50 : returnPause;

                setTimeout(() => {
                    const stillAttacker = units.find(u => u.id === attacker.id); const stillDefender = units.find(u => u.id === defender.id);
                    if (!stillAttacker || (!stillDefender && !defenderDiedVisually)) { console.warn(`Attacker or Defender invalid after attack anim. A:${!!stillAttacker}, D:${!!stillDefender} (DiedVisually:${defenderDiedVisually})`); if (stillAttacker && !stillAttacker.acted && isUnitAliveAndValid(stillAttacker)) finishAction(stillAttacker); if (currentTurn === 'player') { isProcessing = false; updateTurnDisplay(); } return; }

                    let wasKnockedBack = false;
                    if (!defenderDiedVisually && isUnitAliveAndValid(stillDefender)) {
                        playSfx(sfx.hit); stillDefender.hp -= damage; if (stillDefender.hp < 0) stillDefender.hp = 0; showDamagePopup(stillDefender.x, stillDefender.y, damage);
                        if (defenderElement?.parentNode) { defenderElement.classList.add('unit-hit-flash'); setTimeout(() => { defenderElement?.classList.remove('unit-hit-flash'); }, 200); }
                        if (clickedUnitObject?.id === stillDefender.id) { updateUnitInfo(stillDefender); }

                        if (attacker.knockback && stillDefender.hp > 0) {
                            const kbDirX = Math.sign(stillDefender.x - attacker.x); const kbDirY = Math.sign(stillDefender.y - attacker.y); const kbX = stillDefender.x + kbDirX; const kbY = stillDefender.y + kbDirY;
                            if (isCellInBounds(kbX, kbY) && !getUnitAt(kbX, kbY) && gridState[kbY] && gridState[kbY][kbX] === null) { console.log(`Unit ${stillDefender.id} knocked back to (${kbX}, ${kbY}) by ${attacker.id}`); stillDefender.x = kbX; stillDefender.y = kbY; updateUnitPosition(stillDefender, true); wasKnockedBack = true; }
                            else { console.log(`Knockback for ${stillDefender.id} to (${kbX}, ${kbY}) blocked.`); }
                        }
                        if (stillDefender.hp <= 0) { removeUnit(stillDefender); }
                    } else if (defenderDiedVisually) { removeUnit(defender); }
                    else { console.log(`Attack effects skipped: Defender ${defender.id} state changed or already dead.`); }

                    if (stillAttacker && isUnitAliveAndValid(stillAttacker) && !stillAttacker.acted) { finishAction(stillAttacker); }
                    else { console.warn(`Attacker ${attacker?.id} could not finish action (HP:${stillAttacker?.hp}, Acted:${stillAttacker?.acted}).`); }

                    if (currentTurn === 'player') { isProcessing = false; updateTurnDisplay(); console.log("Player attack finished, isProcessing set to false."); }
                }, effectDelay);
            }, impactDelay);
        }


        // --- Spell Casting (with level-based checks) ---
        function castFireball(targetUnit) {
            // **** Check level availability ****
            if (!spellUses.fireball || !isUnitAliveAndValid(targetUnit) || targetUnit.team !== 'enemy' || isProcessing) {
                if (currentLevel < FIREBALL_UNLOCK_LEVEL) showFeedback(`Unlock at Level ${FIREBALL_UNLOCK_LEVEL}!`, "feedback-error");
                else if (!spellUses.fireball) showFeedback("Fireball already used this level.", "feedback-error");
                else showFeedback("Invalid Fireball target/state.", "feedback-error");
                playSfx(sfx.error); setActiveSpell(null);
                // Don't unlock processing here if it was already locked for another reason
                return;
            }
            isProcessing = true; updateTurnDisplay(); setActiveSpell(null);
            // **** Mark as used THIS LEVEL ****
            spellUses.fireball = false;
            updateSpellUI(); // Update UI immediately
            playSfx(sfx.fireballCast); console.log(`Casting Fireball on ${targetUnit.id}`);
            setTimeout(() => {
                const stillTarget = units.find(u => u.id === targetUnit.id);
                if (isUnitAliveAndValid(stillTarget)) {
                    playSfx(sfx.fireballHit); stillTarget.hp -= FIREBALL_DAMAGE; if (stillTarget.hp < 0) stillTarget.hp = 0; showDamagePopup(stillTarget.x, stillTarget.y, FIREBALL_DAMAGE);
                    if(stillTarget.element) { stillTarget.element.classList.add('unit-hit-flash'); setTimeout(() => { stillTarget.element?.classList.remove('unit-hit-flash'); }, 200); }
                    if (clickedUnitObject?.id === stillTarget.id) { updateUnitInfo(stillTarget); }
                    if (stillTarget.hp <= 0) removeUnit(stillTarget);
                } else { console.log("Fireball target became invalid before impact."); }
                isProcessing = false; checkWinLossConditions(); updateTurnDisplay();
            }, 300);
        }
        function castFlameWave(targetRow) {
            // **** Check level availability ****
            if (!spellUses.flameWave || isProcessing || targetRow < 0 || targetRow >= GRID_ROWS) {
                if (currentLevel < FLAME_WAVE_UNLOCK_LEVEL) showFeedback(`Unlock at Level ${FLAME_WAVE_UNLOCK_LEVEL}!`, "feedback-error");
                else if (!spellUses.flameWave) showFeedback("Flame Wave already used this level.", "feedback-error");
                else showFeedback("Invalid Flame Wave target/state.", "feedback-error");
                playSfx(sfx.error); setActiveSpell(null);
                return;
            }
            isProcessing = true; updateTurnDisplay(); setActiveSpell(null);
            // **** Mark as used THIS LEVEL ****
            spellUses.flameWave = false;
            updateSpellUI(); // Update UI immediately
            playSfx(sfx.fireballCast); console.log(`Casting Flame Wave on row ${targetRow}`);
            const cellsInRow = [];
            for (let x = 0; x < GRID_COLS; x++) { const cell = getCellElement(x, targetRow); if (cell && isCellInBounds(x, targetRow) && gridState[targetRow]?.[x] === null) { cellsInRow.push(cell); cell.style.backgroundColor = 'rgba(255, 100, 0, 0.6)'; cell.style.transition = 'background-color 0.3s ease-out'; } }
            setTimeout(() => { cellsInRow.forEach(cell => { cell.style.backgroundColor = ''; cell.style.transition = ''; }); }, 300);
            setTimeout(() => {
                const unitsInRow = units.filter(u => u.y === targetRow && isUnitAliveAndValid(u) && gridState[u.y]?.[u.x] === null);
                let soundPlayed = false; let unitsKilled = [];
                unitsInRow.forEach(unit => {
                    if (!soundPlayed) { playSfx(sfx.fireballHit); soundPlayed = true; } unit.hp -= FLAME_WAVE_DAMAGE; if (unit.hp < 0) unit.hp = 0; showDamagePopup(unit.x, unit.y, FLAME_WAVE_DAMAGE);
                    if (unit.element) { unit.element.classList.add('unit-hit-flash'); setTimeout(() => { unit.element?.classList.remove('unit-hit-flash'); }, 200); }
                    if (clickedUnitObject?.id === unit.id) { updateUnitInfo(unit); } if (unit.hp <= 0) { unitsKilled.push(unit); }
                });
                unitsKilled.forEach(unit => removeUnit(unit));
                isProcessing = false; checkWinLossConditions(); updateTurnDisplay();
            }, 150);
        }
        function castFrostNova(centerX, centerY) {
            // **** Check level availability ****
            if (!spellUses.frostNova || isProcessing || !isCellInBounds(centerX, centerY) || (gridState[centerY]?.[centerX] !== null)) {
                 if (currentLevel < FROST_NOVA_UNLOCK_LEVEL) showFeedback(`Unlock at Level ${FROST_NOVA_UNLOCK_LEVEL}!`, "feedback-error");
                 else if (!spellUses.frostNova) showFeedback("Frost Nova already used this level.", "feedback-error");
                 else if (gridState[centerY]?.[centerX] !== null) showFeedback("Cannot cast Frost Nova on obstacle.", "feedback-error");
                 else showFeedback("Invalid Frost Nova target/state.", "feedback-error");
                 playSfx(sfx.error); setActiveSpell(null);
                 return;
            }
            isProcessing = true; updateTurnDisplay(); setActiveSpell(null);
            // **** Mark as used THIS LEVEL ****
            spellUses.frostNova = false;
            updateSpellUI(); // Update UI immediately
            playSfx(sfx.frostNovaCast); console.log(`Casting Frost Nova centered at (${centerX}, ${centerY})`);
            setTimeout(() => {
                let unitsFrozenCount = 0; let newlyFrozen = false;
                for (let dx = -1; dx <= 1; dx++) { for (let dy = -1; dy <= 1; dy++) { const targetX = centerX + dx; const targetY = centerY + dy; if (isCellInBounds(targetX, targetY) && gridState[targetY]?.[targetX] === null) { const unit = getUnitAt(targetX, targetY); if (unit && unit.team === 'enemy' && isUnitAliveAndValid(unit)) { if (!unit.isFrozen) newlyFrozen = true; unit.isFrozen = true; unit.frozenTurnsLeft = FROST_NOVA_DURATION; console.log(`Froze unit ${unit.id} for ${unit.frozenTurnsLeft} turns.`); showFreezePopup(unit.x, unit.y); updateUnitPosition(unit); if (clickedUnitObject?.id === unit.id) { updateUnitInfo(unit); } unitsFrozenCount++; } } } }
                if (unitsFrozenCount > 0 && newlyFrozen) { playSfx(sfx.frostNovaHit); } else if (unitsFrozenCount === 0) { playSfx(sfx.error); showFeedback("No enemies hit by Frost Nova.", "feedback-error"); }
                isProcessing = false; checkWinLossConditions(); updateTurnDisplay();
            }, 200);
        }
        function castHeal(targetUnit) {
            // **** Check level availability ****
            if (!spellUses.heal || !isUnitAliveAndValid(targetUnit) || targetUnit.team !== 'player' || isProcessing) {
                if (currentLevel < HEAL_UNLOCK_LEVEL) showFeedback(`Unlock at Level ${HEAL_UNLOCK_LEVEL}!`, "feedback-error");
                else if (!spellUses.heal) showFeedback("Heal already used this level.", "feedback-error");
                else showFeedback("Invalid Heal target/state.", "feedback-error");
                playSfx(sfx.error); setActiveSpell(null);
                return;
            }
            if (targetUnit.hp >= targetUnit.maxHp) { showFeedback("Unit already at full HP.", "feedback-error"); playSfx(sfx.error); setActiveSpell(null); return; }
            isProcessing = true; updateTurnDisplay(); setActiveSpell(null);
            // **** Mark as used THIS LEVEL ****
            spellUses.heal = false;
            updateSpellUI(); // Update UI immediately
            playSfx(sfx.heal); console.log(`Casting Heal on ${targetUnit.id}`);
            const healApplied = Math.min(HEAL_AMOUNT, targetUnit.maxHp - targetUnit.hp); targetUnit.hp += healApplied; showHealPopup(targetUnit.x, targetUnit.y, healApplied);
            if (targetUnit.element) { targetUnit.element.classList.add('unit-hit-flash'); setTimeout(() => { targetUnit.element?.classList.remove('unit-hit-flash'); }, 200); }
            if (clickedUnitObject?.id === targetUnit.id) { updateUnitInfo(targetUnit); }
            isProcessing = false; updateTurnDisplay(); checkWinLossConditions();
        }

        // --- Unit Removal ---
        function removeUnit(unit) {
            if (!unit) return; const unitIndex = units.findIndex(u => u.id === unit.id); const unitElement = unit.element || gameBoard.querySelector(`.unit[data-id='${unit.id}']`); unit.hp = 0; if (unitIndex !== -1) { units.splice(unitIndex, 1); }
            if (unitElement && unitElement.parentNode) {
                if (!unitElement.classList.contains('dead')) { const deathSpriteUrl = UNIT_DATA[unit.type]?.deadSpriteUrl; if (deathSpriteUrl) { unitElement.style.backgroundImage = `url('${deathSpriteUrl}')`; } unitElement.classList.add('dead'); unitElement.classList.remove('selected', 'acted', 'unit-hit-flash', 'player', 'enemy', 'valid-attack', 'valid-move', 'frozen', 'is-moving'); unitElement.style.filter = 'none'; unitElement.style.boxShadow = 'none'; unitElement.style.opacity = '1'; unitElement.style.transform = 'none'; unitElement.style.pointerEvents = 'none'; }
                const deathDisplayTime = 1500; const fadeDurationString = getComputedStyle(document.documentElement).getPropertyValue('--death-fade-time').trim().toLowerCase(); let fadeDuration = 1000; if (fadeDurationString.endsWith('ms')) fadeDuration = parseFloat(fadeDurationString); else if (fadeDurationString.endsWith('s')) fadeDuration = parseFloat(fadeDurationString) * 1000; fadeDuration = Math.max(fadeDuration, 100);
                setTimeout(() => { if (unitElement?.parentNode && unitElement.classList.contains('dead') && !unitElement.classList.contains('fading-out')) { unitElement.classList.add('fading-out'); setTimeout(() => { unitElement?.remove(); }, fadeDuration); } }, deathDisplayTime);
            } else { console.log(`Unit ${unit.id} element not found for removal visual.`); }
            if (selectedUnit?.id === unit.id) { deselectUnit(); } else if (clickedUnitObject?.id === unit.id) { updateUnitInfo(null); }
            checkWinLossConditions();
        }

        // --- Utilities ---
        function getUnitAt(x, y) { return units.find(unit => unit.x === x && unit.y === y && isUnitAliveAndValid(unit)); }
        function getCellElement(x, y) { if (!isCellInBounds(x,y)) return null; return gameBoard.querySelector(`.grid-cell[data-x='${x}'][data-y='${y}']`); }
        function getDistance(unitA, unitB) { if (!unitA || !unitB) return Infinity; return Math.abs(unitA.x - unitB.x) + Math.abs(unitA.y - unitB.y); }
        function getValidMoves(unit) {
            if (!unit || unit.acted || unit.isFrozen || !isUnitAliveAndValid(unit)) return []; const moves = []; const queue = [{ x: unit.x, y: unit.y, distance: 0 }]; const visited = new Set([`${unit.x},${unit.y}`]);
            while (queue.length > 0) {
                const current = queue.shift(); const neighbors = [ { x: current.x, y: current.y - 1 }, { x: current.x, y: current.y + 1 }, { x: current.x - 1, y: current.y }, { x: current.x + 1, y: current.y } ];
                for (const neighbor of neighbors) {
                    const key = `${neighbor.x},${neighbor.y}`; if (!isCellInBounds(neighbor.x, neighbor.y) || visited.has(key)) continue; const newDistance = current.distance + 1; if (newDistance > unit.mov) continue;
                    const unitAtNeighbor = getUnitAt(neighbor.x, neighbor.y); const obstacleAtNeighbor = gridState[neighbor.y]?.[neighbor.x]; // Safe access
                    if (unitAtNeighbor || obstacleAtNeighbor !== null) continue; // Check against null
                    moves.push({ x: neighbor.x, y: neighbor.y }); visited.add(key); queue.push({ x: neighbor.x, y: neighbor.y, distance: newDistance });
                }
            } return moves;
        }
        function hasLineOfSight(startX, startY, endX, endY) {
            let x = startX; let y = startY; const dx = Math.abs(endX - startX); const dy = Math.abs(endY - startY); const sx = startX < endX ? 1 : -1; const sy = startY < endY ? 1 : -1; let err = dx - dy; const maxSteps = dx + dy + 2; let steps = 0;
            while (steps++ < maxSteps) {
                let nextX = x, nextY = y; let e2 = 2 * err; let moved = false;
                if (e2 > -dy) { if (x === endX) break; err -= dy; nextX += sx; moved = true; }
                if (e2 < dx) { if (y === endY) break; let checkY = y + sy; let checkX = (moved ? nextX : x);
                    if (moved && Math.abs(nextX - startX) + Math.abs(checkY - startY) < Math.abs(endX - startX) + Math.abs(endY - startY)) {
                        const diagUnit = getUnitAt(checkX, checkY); const diagObstacleType = gridState[checkY]?.[checkX]; const diagObstacleData = diagObstacleType ? OBSTACLE_TYPES[diagObstacleType] : null;
                        if (diagUnit || (diagObstacleData && diagObstacleData.blocksLOS)) return false;
                    } err += dx; nextY += sy; moved = true;
                }
                x = nextX; y = nextY; if (x === endX && y === endY) break;
                const unitInCell = getUnitAt(x, y); const obstacleType = gridState[y]?.[x]; const obstacleData = obstacleType ? OBSTACLE_TYPES[obstacleType] : null;
                if (unitInCell || (obstacleData && obstacleData.blocksLOS)) return false;
                if (!moved) break;
            } return true;
        }
        function getValidAttacks(unit) {
            const attacks = []; if (!unit || unit.acted || unit.isFrozen || !isUnitAliveAndValid(unit)) return attacks; const unitRange = unit.range || 1;
            units.forEach(target => { if (target.team !== unit.team && isUnitAliveAndValid(target)) { const distance = getDistance(unit, target); if (distance <= unitRange) { if (unitRange === 1 || hasLineOfSight(unit.x, unit.y, target.x, target.y)) { attacks.push(target.id); } } } }); return attacks;
        }

        // --- Turn Management & AI ---
        function processFreezeTicks(team) { let thawedCount = 0; units.filter(u => u.team === team && u.isFrozen && isUnitAliveAndValid(u)).forEach(unit => { unit.frozenTurnsLeft--; if (unit.frozenTurnsLeft <= 0) { unit.isFrozen = false; thawedCount++; console.log(`Unit ${unit.id} thawed.`); updateUnitPosition(unit); } if (clickedUnitObject?.id === unit.id) { updateUnitInfo(unit); } }); return thawedCount; }
        function endTurn() { if (currentTurn !== 'player' || isProcessing || isGameOver()) { return; }
            if (!audioInitialized) initializeAudio(); playSfx(sfx.select); console.log("--- Player Ends Turn ---"); isProcessing = true; updateTurnDisplay(); deselectUnit(); setActiveSpell(null); updateUnitInfo(null); showFeedback(''); currentTurn = 'enemy';
            console.log("Processing enemy freeze ticks..."); processFreezeTicks('enemy');
            units.filter(u => u.team === 'enemy' && isUnitAliveAndValid(u)).forEach(u => { u.acted = false; updateUnitPosition(u); });
            updateTurnDisplay(); setTimeout(runAITurn, 400);
        }
        endTurnButton.addEventListener('click', () => { if (currentTurn === 'player' && !isProcessing && !isGameOver()) endTurn(); });

        function runAITurn() {
            console.log("--- AI Turn Start ---"); const unitsToAct = units.filter(u => u.team === 'enemy' && isUnitAliveAndValid(u) && !u.acted && !u.isFrozen); let currentAIUnitIndex = 0; const totalActions = unitsToAct.length; const actionInterval = 150; const minActionDuration = Math.max(MOVE_ANIMATION_DURATION_MS, ARROW_FLY_DURATION_MS) + 150; console.log(`AI processing ${totalActions} active units`);

            async function processNextAIUnit() {
                if (isGameOver()) { console.log("AI turn interrupted: Game Over."); endAITurnSequence(true); return; }
                if (currentAIUnitIndex >= totalActions) { endAITurnSequence(false); return; }

                const unitToProcess = unitsToAct[currentAIUnitIndex]; currentAIUnitIndex++; const stillValidUnit = units.find(u => u.id === unitToProcess.id && isUnitAliveAndValid(u) && !u.acted && !u.isFrozen);
                if (stillValidUnit) {
                    const actionStartTime = Date.now();
                    try { updateTurnDisplay(); await performAIAction(stillValidUnit); }
                    catch(e) { console.error(`AI Error processing ${stillValidUnit?.id}:`, e); if (stillValidUnit && isUnitAliveAndValid(stillValidUnit) && !stillValidUnit.acted) { finishAction(stillValidUnit); } }
                    finally { const actionEndTime = Date.now(); const duration = actionEndTime - actionStartTime; const delayNeeded = Math.max(actionInterval, minActionDuration - duration); setTimeout(processNextAIUnit, delayNeeded); }
                } else { setTimeout(processNextAIUnit, 50); }
            }

            function endAITurnSequence(interrupted) {
                console.log(`--- AI Turn End --- (Interrupted: ${interrupted})`);
                if (!isGameOver()) {
                    currentTurn='player';
                    console.log("Processing player freeze ticks..."); processFreezeTicks('player');
                    units.forEach(u => { if (u.team === 'player' && isUnitAliveAndValid(u)) { u.acted = false; updateUnitPosition(u); } });
                    // **** DO NOT RESET SPELL STATE HERE ANYMORE ****
                    // resetSpellState(); <-- REMOVED
                    showFeedback("Player Turn!"); isProcessing = false; updateTurnDisplay(); console.log("Player turn started. isProcessing set to false.");
                } else { console.log("AI turn ended, game over state detected."); endTurnButton.disabled = true; endTurnButton.classList.add('disabled'); isProcessing = true; updateTurnDisplay(); }
            }

            if (totalActions === 0) { console.log("AI: No active units to act."); endAITurnSequence(false); }
            else { setTimeout(processNextAIUnit, 100); }
        }
        async function performAIAction(unit) {
            const livingPlayers = units.filter(u => u.team === 'player' && isUnitAliveAndValid(u)); if (livingPlayers.length === 0) { if (!unit.acted) finishAction(unit); return; } const unitRange = unit.range || 1;
            const possibleAttacks = getValidAttacks(unit);
            if (possibleAttacks.length > 0) {
                let targetToAttack = null; let isRangedTargetSelected = false; let lowestHp = Infinity;
                possibleAttacks.forEach(id => { const target = units.find(u => u.id === id); if (isUnitAliveAndValid(target)) { const distance = getDistance(unit, target); const currentTargetIsRanged = (distance > 1); if (unitRange > 1) { if (currentTargetIsRanged && !isRangedTargetSelected) { targetToAttack = target; lowestHp = target.hp; isRangedTargetSelected = true; } else if (currentTargetIsRanged && isRangedTargetSelected && target.hp < lowestHp) { targetToAttack = target; lowestHp = target.hp; } else if (!isRangedTargetSelected && target.hp < lowestHp) { targetToAttack = target; lowestHp = target.hp; } else if (!targetToAttack) { targetToAttack = target; lowestHp = target.hp; } } else { if (target.hp < lowestHp) { targetToAttack = target; lowestHp = target.hp; } else if (!targetToAttack) { targetToAttack = target; lowestHp = target.hp; } } } });
                if (targetToAttack) { attackUnit(unit, targetToAttack); return; }
            }
            let nearestPlayer = null; let minDistance = Infinity; livingPlayers.forEach(p => { if(isUnitAliveAndValid(p)) { const d = getDistance(unit, p); if (d < minDistance) { minDistance = d; nearestPlayer = p; } } });
            if (nearestPlayer) {
                const possibleMoves = getValidMoves(unit);
                if (possibleMoves.length > 0) {
                    let bestMove = null; let shortestDistToTarget = minDistance; let bestDistForRanged = minDistance;
                    possibleMoves.forEach(moveOption => { const distAfterMove = Math.abs(moveOption.x - nearestPlayer.x) + Math.abs(moveOption.y - nearestPlayer.y); if (unitRange > 1) { const currentBestIsAdjacent = bestMove ? (Math.abs(bestMove.x - nearestPlayer.x) + Math.abs(bestMove.y - nearestPlayer.y) <= 1) : true; const newMoveIsAdjacent = distAfterMove <= 1; if (!newMoveIsAdjacent && (currentBestIsAdjacent || distAfterMove < bestDistForRanged)) { bestDistForRanged = distAfterMove; bestMove = moveOption; } else if (newMoveIsAdjacent && currentBestIsAdjacent && distAfterMove < bestDistForRanged) { bestDistForRanged = distAfterMove; bestMove = moveOption; } else if (!bestMove) { bestMove = moveOption; bestDistForRanged = distAfterMove; } } else { if (distAfterMove < shortestDistToTarget) { shortestDistToTarget = distAfterMove; bestMove = moveOption; } else if (!bestMove) { bestMove = moveOption; shortestDistToTarget = distAfterMove; } } });
                    if (bestMove) { await moveUnit(unit, bestMove.x, bestMove.y); finishAction(unit); return; }
                }
            }
            finishAction(unit);
        }

        // --- Win/Loss & Level Progression ---
        function checkWinLossConditions() {
            if (winCheckTimeout) clearTimeout(winCheckTimeout);
            winCheckTimeout = setTimeout(() => {
                if (isGameOver()) { winCheckTimeout = null; return; }
                const playersLeft = units.some(u => u.team === 'player' && isUnitAliveAndValid(u)); const enemiesLeft = units.some(u => u.team === 'enemy' && isUnitAliveAndValid(u));
                if (!enemiesLeft && playersLeft) { console.log(`Lvl ${currentLevel} Cleared!`); playSfx(sfx.success); isProcessing = true; updateTurnDisplay(); showFeedback(`Level ${currentLevel} Cleared!`, 'feedback-levelup'); setTimeout(startNextLevel, 1800); }
                else if (!playersLeft) { console.log("Loss Condition Met."); gameOver(false); }
                winCheckTimeout = null;
            }, 100);
        }
        function startNextLevel() {
            if (isGameOver()) return;
            currentLevel++; console.log(`--- Start Lvl ${currentLevel} ---`); isProcessing = true; stopMusic(); selectAndLoadMusic();
            // **** resetLevelState ALREADY resets spell charges for the new level ****
            resetLevelState();
            initializeGridState(); updateLevelDisplay(); updateUnitInfo(null); endTurnButton.disabled = false; endTurnButton.classList.remove('disabled'); showFeedback(`Level ${currentLevel} Start!`, 'feedback-levelup'); setTimeout(() => { if (!isGameOver() && feedbackArea.textContent === `Level ${currentLevel} Start!`) showFeedback(''); }, 2000);

            requestAnimationFrame(() => {
                 console.log("StartNextLevel rAF started.");
                try {
                    calculateCellSize(); spawnObstacles(); spawnInitialUnits();
                    units.forEach(u => { if (u.team === 'player') u.acted = false; u.isFrozen = false; u.frozenTurnsLeft = 0; });
                    renderAllUnits(); applyLayout(); updateTurnDisplay(); startMusicIfNotPlaying();
                } catch (e) { console.error("Error during startNextLevel rAF:", e); }
                finally { isProcessing = false; updateTurnDisplay(); console.log(`Lvl ${currentLevel} ready. isProcessing set to false.`); }
            });
        }
        function isGameOver() { return gameOverScreen.style.display !== 'none'; }
        function gameOver(playerWon) {
            if (isGameOver()) return; console.log(`--- Game Over --- Player Won: ${playerWon}, Final Level: ${currentLevel}`); isProcessing = true; stopMusic(); if (!playerWon) { playSfx(sfx.gameOver); } else { playSfx(sfx.success); } deselectUnit(); updateUnitInfo(null); setActiveSpell(null); endTurnButton.disabled = true; endTurnButton.classList.add('disabled'); gameOverTitle.textContent = playerWon ? "Victory!" : "Defeat!"; gameOverMessage.textContent = playerWon ? `You are victorious!` : `You have fallen on Level ${currentLevel}!`; gameOverScreen.style.display = 'flex';
            window.removeEventListener('resize', handleResize); document.removeEventListener('fullscreenchange', updateFullscreenButton); document.removeEventListener('webkitfullscreenchange', updateFullscreenButton); document.removeEventListener('mozfullscreenchange', updateFullscreenButton); document.removeEventListener('MSFullscreenChange', updateFullscreenButton);
            if (winCheckTimeout) clearTimeout(winCheckTimeout); winCheckTimeout = null; if (resizeTimeout) clearTimeout(resizeTimeout); resizeTimeout = null; updateTurnDisplay();
        }

        // --- Mute Function ---
        function toggleMute() { if (!audioInitialized) initializeAudio(); isMuted = !isMuted; bgMusic.muted = isMuted; Object.values(sfx).forEach(s => s.muted = isMuted); updateMuteButtonVisual(); if (!isMuted && audioInitialized && !isGameOver() && startScreen.style.display === 'none') { startMusicIfNotPlaying(); } else if (isMuted) { stopMusic(); } console.log("Muted:", isMuted); }
        function updateMuteButtonVisual() { if (muteButton) { muteButton.innerHTML = isMuted ? '🔇' : '🔊'; muteButton.title = isMuted ? 'Unmute (M)' : 'Mute Sound (M)'; } }

        // --- Global Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
             console.log("DOMContentLoaded.");
            try {
                 const moveDurationStr = getComputedStyle(document.documentElement).getPropertyValue('--move-anim-time').trim(); if (moveDurationStr.endsWith('ms')) { MOVE_ANIMATION_DURATION_MS = parseFloat(moveDurationStr); } else if (moveDurationStr.endsWith('s')) { MOVE_ANIMATION_DURATION_MS = parseFloat(moveDurationStr) * 1000; }
                 const arrowDurationStr = getComputedStyle(document.documentElement).getPropertyValue('--arrow-fly-time').trim(); let cssArrowDuration = 300; if (arrowDurationStr.endsWith('ms')) { cssArrowDuration = parseFloat(arrowDurationStr); } else if (arrowDurationStr.endsWith('s')) { cssArrowDuration = parseFloat(arrowDurationStr) * 1000; }
                 if (cssArrowDuration !== ARROW_FLY_DURATION_MS) { console.warn(`Mismatch between JS ARROW_FLY_DURATION_MS (${ARROW_FLY_DURATION_MS}) and CSS --arrow-fly-time (${cssArrowDuration}). Using JS value.`); }
                 console.log(`Move animation duration set to: ${MOVE_ANIMATION_DURATION_MS}ms`); console.log(`Arrow animation duration set to: ${ARROW_FLY_DURATION_MS}ms`);
            } catch (e) { console.warn("Could not read animation times from CSS, using defaults.", e); MOVE_ANIMATION_DURATION_MS = 250; }

            if (muteButton) muteButton.addEventListener('click', toggleMute);
            if (fireballElement) fireballElement.addEventListener('click', () => setActiveSpell('fireball'));
            if (flameWaveElement) flameWaveElement.addEventListener('click', () => setActiveSpell('flameWave'));
            if (frostNovaElement) frostNovaElement.addEventListener('click', () => setActiveSpell('frostNova'));
            if (healElement) healElement.addEventListener('click', () => setActiveSpell('heal'));
            if (fullscreenButton) fullscreenButton.addEventListener('click', toggleFullscreen);
            if (startButton) startButton.addEventListener('click', () => { console.log("Start button clicked."); if (!audioInitialized) initializeAudio(); if (startScreen.style.display !== 'none' && !isProcessing) { initGame(); } else { console.warn("Start button clicked but game already started or processing."); } });
            if (restartButton) restartButton.addEventListener('click', () => { if (!audioInitialized) initializeAudio(); initGame(); });

            startScreen.style.display = 'flex'; gameOverScreen.style.display = 'none'; endTurnButton.classList.add('disabled'); endTurnButton.disabled = true; updateUnitInfo(null); updateLevelDisplay(); setupBoard();
            // Initialize spell state/UI based on level 1 availability (done via resetLevelState called below indirectly)
            resetLevelState(); // Call this to initialize grid, spells etc. for the initial view before game starts
            isProcessing = false; // Ensure UI is interactive for start screen
            updateTurnDisplay(); updateMuteButtonVisual();

            requestAnimationFrame(() => { try { calculateCellSize(); updateFullscreenButton(); } catch(e) { console.error("Initial rAF error:", e)} });
            window.addEventListener('keydown', handleKeyDown);
            console.log("Initial setup complete. Waiting for start button.");
        });

        // --- Hotkey Handler ---
        function handleKeyDown(event) {
            if ((isProcessing && !['m', 'f'].includes(event.key.toLowerCase())) || (event.metaKey || event.ctrlKey || event.altKey) && !(event.shiftKey && event.code === 'KeyT')) return;
            const gameActive = startScreen.style.display === 'none' && gameOverScreen.style.display === 'none';

            switch(event.key.toLowerCase()) {
                case '1': if (gameActive && currentTurn === 'player' && !isProcessing) { setActiveSpell('fireball'); event.preventDefault(); } break;
                case '2': if (gameActive && currentTurn === 'player' && !isProcessing) { setActiveSpell('flameWave'); event.preventDefault(); } break;
                case '3': if (gameActive && currentTurn === 'player' && !isProcessing) { setActiveSpell('frostNova'); event.preventDefault(); } break;
                case '4': if (gameActive && currentTurn === 'player' && !isProcessing) { setActiveSpell('heal'); event.preventDefault(); } break;
                case 'e': if (gameActive && currentTurn === 'player' && !isProcessing) { endTurn(); event.preventDefault(); } break;
                case 'm': toggleMute(); event.preventDefault(); break;
                case 'f': toggleFullscreen(); event.preventDefault(); break;
                case 't': if (event.shiftKey && gameActive && currentTurn === 'player' && !isProcessing) { console.warn("CHEAT: Skip Level!"); isProcessing = true; updateTurnDisplay(); deselectUnit(); setActiveSpell(null); showFeedback("Cheating...", "feedback-levelup"); playSfx(sfx.success); setTimeout(startNextLevel, 100); event.preventDefault(); } break;
                case 'escape': if (gameActive && currentTurn === 'player' && !isProcessing) { if (currentSpell) { setActiveSpell(null); playSfx(sfx.select); event.preventDefault(); } else if (selectedUnit) { deselectUnit(); playSfx(sfx.select); event.preventDefault(); } } break;
            }
        }

    </script>
</body>
</html>
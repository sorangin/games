<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Knights Vs Goblins (Centering Fix)</title>
    <style>
        /* --- Base Styles (Unchanged) --- */
        :root {
            --grid-cols: 8;
            --grid-rows: 10;
            --board-aspect-ratio: var(--grid-cols) / var(--grid-rows);
            font-size: clamp(8px, 1.8vmin, 16px);
        }
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }
        body { display: flex; justify-content: center; align-items: center; background-color: #3a4a3a; font-family: 'Courier New', Courier, monospace; color: #eee; padding: 5px; box-sizing: border-box; }
        #game-container { display: flex; max-width: 100%; max-height: 100%; width: 100%; height: 100%; border: clamp(2px, 0.5vmin, 5px) solid #1e281e; background-color: #1e281e; box-shadow: 0 0 15px rgba(0,0,0,0.5); flex-direction: row; align-items: stretch; justify-content: center; padding: clamp(3px, 1vmin, 10px); box-sizing: border-box; gap: clamp(5px, 1vmin, 10px); }
        #game-container:fullscreen { padding: 0; border: none; gap: 5px; width: 100vw; height: 100vh; max-width: 100vw; max-height: 100vh; }
        #game-container:fullscreen > #ui-panel { border-left-color: #333; }

        /* --- Game Board & Cells (Unchanged) --- */
        #game-board {
            display: grid;
            border: clamp(1px, 0.3vmin, 2px) solid #1e281e;
            position: relative; /* Needed for absolute positioned popups */
            flex-grow: 0;
            flex-shrink: 1;
            grid-template-columns: repeat(var(--grid-cols), 1fr);
            grid-template-rows: repeat(var(--grid-rows), 1fr);
            aspect-ratio: var(--board-aspect-ratio);
            max-width: 100%;
            max-height: 100%;
            box-sizing: border-box;
            min-width: 160px; /* Minimum practical size */
            min-height: calc(160px / var(--board-aspect-ratio));
            overflow: hidden; /* Prevent units slightly overflowing grid */
        }
        #game-board.spell-targeting { cursor: crosshair !important; }
        #game-board.spell-targeting .grid-cell:hover { background-color: rgba(255, 100, 100, 0.4) !important; box-shadow: inset 0 0 0 2px rgba(255, 0, 0, 0.7); }
        .grid-cell {
            border: 1px solid #7a8a7a;
            background-color: #6a7a6a;
            position: relative; /* May not be strictly needed now */
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
            box-sizing: border-box;
            image-rendering: pixelated; /* Apply to cell */
            min-width: 1px; /* Prevent collapse */
            min-height: 1px; /* Prevent collapse */
            overflow: hidden; /* Prevent highlight overflow */
            grid-column: auto; /* Explicitly set defaults */
            grid-row: auto; /* Explicitly set defaults */
        }
        .grid-cell.valid-move { background-color: #aaeaaa; opacity: 0.8; }
        .grid-cell.valid-attack { background-color: #ffaaaa; opacity: 0.8; }

        /* --- Units (MODIFIED FOR GRID POSITIONING) --- */
        .unit {
            /* position: absolute; --- REMOVED */
            /* top: 0; left: 0; --- REMOVED (Controlled by grid-row/grid-column) */
            grid-column: var(--unit-x, 1); /* Set defaults or via JS */
            grid-row: var(--unit-y, 1); /* Set defaults or via JS */
            align-self: center; /* NEW: Center vertically in grid cell */
            justify-self: center; /* NEW: Center horizontally in grid cell */

            /* --- Other Styles (Mostly Unchanged) --- */
            border-radius: 3px;
            display: flex; /* Still useful for potential internal content */
            justify-content: center; /* For potential internal content */
            align-items: center; /* For potential internal content */
            font-weight: bold;
            z-index: 10;
            /* Adjusted transition */
            transition: filter 0.2s, box-shadow 0.2s, width 0.1s, height 0.1s; /* Removed top/left */
            box-sizing: border-box;
            background-color: transparent;
            image-rendering: pixelated;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            pointer-events: none; /* Default, overridden below */
            /* Width/Height set by JS based on cell size */
            width: 10px; /* Initial placeholder */
            height: 10px; /* Initial placeholder */
        }
        #game-board .unit {
             pointer-events: auto; /* Units on board are clickable */
        }
        .unit.selected {
            box-shadow: 0 0 0 clamp(1px, 0.5vmin, 3px) yellow;
            z-index: 11;
        }

        /* --- UI Panel (Unchanged) --- */
        #ui-panel { width: clamp(180px, 28vmin, 240px); flex-shrink: 0; max-height: 100%; padding: clamp(0.8rem, 1.5vmin, 1.5rem); background-color: #4a5a4a; border-left: clamp(1px, 0.4vmin, 3px) solid #1e281e; display: flex; flex-direction: column; justify-content: space-between; overflow-y: auto; font-size: 1.4rem; box-sizing: border-box; position: relative; }
        #level-display { text-align: center; margin-bottom: 1rem; font-weight: bold; color: #ffd700; background-color:#5a6a5a; padding: 0.5rem; border: 1px solid #1e281e; border-radius: 3px; font-size: 1.6rem; }
        #unit-info, #turn-info { background-color: #5a6a5a; padding: 1rem; margin-bottom: 1.5rem; border: 1px solid #1e281e; border-radius: 3px; min-height: 7rem; }
        #unit-info h3, #turn-info h3 { margin-top: 0; margin-bottom: 0.8rem; border-bottom: 1px solid #7a8a7a; padding-bottom: 0.5rem; color: #eee; font-size: 1.5rem; }
        #unit-info p, #turn-info p { margin: 0.4rem 0; font-size: 1.3rem; color: #ddd; line-height: 1.4; }
        #spell-area { margin-top: auto; margin-bottom: 1.5rem; padding: 0.8rem 0.5rem; background-color:#5a6a5a; border: 1px solid #1e281e; border-radius: 3px; min-height: 5rem; display: none; align-items: center; justify-content: center; flex-wrap: wrap; }
        #spell-area.visible { display: flex; }
        .spell-icon { display: inline-block; width: clamp(30px, 5vmin, 45px); height: clamp(30px, 5vmin, 45px); border: clamp(1px, 0.3vmin, 2px) solid #333; border-radius: 4px; background-color: #444; background-size: contain; background-repeat: no-repeat; background-position: center; cursor: pointer; margin: 0 0.5rem; transition: border-color 0.2s, box-shadow 0.2s, filter 0.2s; image-rendering: pixelated; vertical-align: middle; }
        #fireball-spell { background-image: url('./sprites/sFireball1.png'); }
        .spell-label { font-size: 1.3rem; margin-left: 0.8rem; font-weight: bold; color: #eee; text-shadow: 1px 1px #111; }
        .spell-icon.unavailable { filter: grayscale(90%) brightness(60%); cursor: not-allowed; border-color: #555; }
        .spell-icon.available { filter: none; cursor: pointer; border-color: #888; }
        .spell-icon.available:hover { border-color: #eee; }
        .spell-icon.selected { border-color: yellow; box-shadow: 0 0 8px yellow; }
        #feedback-area { margin-bottom: 1rem; min-height: 2rem; font-size: 1.4rem; font-weight: bold; color: #fff; text-align: center; }
        .feedback-levelup { color: #ffd700; text-shadow: 1px 1px #443300; }
        #end-turn-button { padding: 1rem 1.5rem; background-color: #a0522d; border: 2px solid #1e281e; color: white; font-family: 'Courier New', Courier, monospace; cursor: pointer; font-size: 1.4rem; border-radius: 3px; text-align: center; transition: background-color 0.2s; width: 100%; box-sizing: border-box;}
        #end-turn-button:hover { background-color: #8B4513; }
        #end-turn-button.disabled { background-color: #888; cursor: not-allowed; color: #bbb; }

        /* --- UI Buttons (Fullscreen & Mute - Unchanged) --- */
        .ui-button { position: absolute; top: 5px; padding: 3px 5px; background-color: rgba(30, 40, 30, 0.6); border: 1px solid #7a8a7a; color: #eee; font-size: 1.6rem; line-height: 1; border-radius: 3px; cursor: pointer; z-index: 5; transition: background-color 0.2s; min-width: 25px; min-height: 25px; display: inline-flex; justify-content: center; align-items: center; user-select: none; -webkit-tap-highlight-color: transparent; }
         .ui-button:hover { background-color: rgba(60, 80, 60, 0.8); }
         .ui-button:disabled { opacity: 0.5; cursor: not-allowed; }
        #fullscreen-button { right: 5px; }
        #mute-button { right: 40px; }

        /* --- Popups & Overlays (Unchanged) --- */
        /* Damage popup still needs absolute positioning relative to game board */
        .damage-popup { position: absolute; color: red; font-size: clamp(1.2rem, 2vmin, 1.8rem); font-weight: bold; animation: moveUpFadeOut 1s forwards; z-index: 20; pointer-events: none; text-shadow: 1px 1px white; }
        @keyframes moveUpFadeOut { 0% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(-30px); } }
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; text-align: center; z-index: 50; padding: 20px; box-sizing: border-box; }
        .overlay h2 { color: #ffd700; margin-bottom: 2rem; font-size: 2.5rem; }
        .overlay p { font-size: 1.5rem; line-height: 1.6; margin-bottom: 2rem;}
        .overlay button { padding: 1rem 2rem; font-size: 1.6rem; cursor: pointer; background-color: #a0522d; border: 2px solid #1e281e; color: white; font-family: 'Courier New', Courier, monospace; border-radius: 3px; }
        .overlay button:hover { background-color: #8B4513; }

        /* --- Media Query (Unchanged) --- */
        @media (max-width: 700px), (max-aspect-ratio: 1/1) {
             #game-container { flex-direction: column; justify-content: flex-start; align-items: stretch; }
             #game-board { width: 100%; height: auto; margin: 0; min-height: calc(160px / var(--board-aspect-ratio)); }
             #ui-panel { width: 100%; height: auto; flex-grow: 1; flex-shrink: 1; border-left: none; border-top: clamp(1px, 0.4vmin, 3px) solid #1e281e; min-height: 100px; max-height: 40vh; font-size: 1.3rem; }
             .ui-button { top: 3px; font-size: 1.4rem; }
             #fullscreen-button { right: 3px; }
             #mute-button { right: 35px; }
             #unit-info h3, #turn-info h3 { font-size: 1.4rem;}
             #unit-info p, #turn-info p { font-size: 1.2rem;}
             #game-container:fullscreen > #ui-panel { border-top-color: #333; }
        }
    </style>
</head>
<body>
    <!-- HTML structure (Unchanged) -->
    <div id="game-container">
        <div id="game-board">
            <!-- Grid cells added by JS -->
            <!-- Unit elements will be added here directly by JS -->
        </div>
        <div id="ui-panel">
            <button id="mute-button" class="ui-button" title="Toggle Sound">🔊</button>
            <button id="fullscreen-button" class="ui-button" title="Toggle Fullscreen" disabled>&#x26F6;</button>
            <div id="level-display">Level: 1</div>
            <div id="turn-info"> <h3>Turn Info</h3> <p id="current-turn">Turn: Player</p> <p id="actions-left">Actions Left: 0</p> </div>
            <div id="unit-info"> <h3>Unit Info</h3> <p id="unit-name">Name: -</p> <p id="unit-hp">HP: -/-</p> <p id="unit-atk">ATK: -</p> <p id="unit-mov">MOV: -</p> </div>
            <div id="spell-area"> <div id="fireball-spell" class="spell-icon unavailable"></div> <span class="spell-label">Fireball</span> </div>
            <div id="feedback-area"></div>
            <button id="end-turn-button">End Turn</button>
        </div>
        <div id="start-screen" class="overlay"> <h2>Knights Vs Goblins</h2> <p>Defeat all Goblins to advance levels.<br>Unlock Fireball at Lvl 4!</p> <button id="start-button">Begin Conquest!</button> </div>
        <div id="game-over-screen" class="overlay" style="display: none;"> <h2 id="game-over-title">Defeat!</h2> <p id="game-over-message"></p> <button id="restart-button">Play Again? (Lvl 1)</button> </div>
    </div>

    <script>
        // --- DOM Elements (Unchanged) ---
        const gameContainer = document.getElementById('game-container');
        const gameBoard = document.getElementById('game-board');
        const uiPanel = document.getElementById('ui-panel');
        const levelDisplayElement = document.getElementById('level-display');
        const spellAreaElement = document.getElementById('spell-area');
        const fireballElement = document.getElementById('fireball-spell');
        const turnInfo = document.getElementById('turn-info');
        const unitInfo = document.getElementById('unit-info');
        const currentTurnDisplay = document.getElementById('current-turn');
        const actionsLeftDisplay = document.getElementById('actions-left');
        const unitNameDisplay = document.getElementById('unit-name');
        const unitHpDisplay = document.getElementById('unit-hp');
        const unitAtkDisplay = document.getElementById('unit-atk');
        const unitMovDisplay = document.getElementById('unit-mov');
        const feedbackArea = document.getElementById('feedback-area');
        const endTurnButton = document.getElementById('end-turn-button');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const gameOverTitle = document.getElementById('game-over-title');
        const gameOverMessage = document.getElementById('game-over-message');
        const fullscreenButton = document.getElementById('fullscreen-button');
        const muteButton = document.getElementById('mute-button');

        // --- Audio Setup (Unchanged) ---
        const musicTracks = [ 'audio/music_Treasure.mp3', 'audio/music_AoiUsagi-Die.mp3', 'audio/music_WormsTheme.mp3' ];
        const sfxSuccessPath = 'audio/Success.wav'; const sfxErrorPath = 'audio/Error.wav'; const sfxGameOverPath = 'audio/GameOver.wav'; const sfxHitPath = 'audio/sfxHit.wav'; const sfxDefeatPath = 'audio/sfxGoblinDead.wav'; const sfxMovePath = 'audio/sfxMove.wav'; const sfxSelectPath = 'audio/sfxSelect.wav'; const sfxFireballCastPath = 'audio/sfxFireballCast.wav'; const sfxFireballHitPath = 'audio/sfxFireballHit.wav';
        let bgMusic = new Audio(); bgMusic.loop = true; bgMusic.volume = 0.3;
        let sfxSuccess = new Audio(sfxSuccessPath); sfxSuccess.volume = 0.6; let sfxError = new Audio(sfxErrorPath); sfxError.volume = 0.6; let sfxGameOver = new Audio(sfxGameOverPath); sfxGameOver.volume = 0.8; let sfxHit = new Audio(sfxHitPath); sfxHit.volume = 0.7; let sfxDefeat = new Audio(sfxDefeatPath); sfxDefeat.volume = 0.7; let sfxMove = new Audio(sfxMovePath); sfxMove.volume = 0.5; let sfxSelect = new Audio(sfxSelectPath); sfxSelect.volume = 0.5; let sfxFireballCast = new Audio(sfxFireballCastPath); sfxFireballCast.volume = 0.7; let sfxFireballHit = new Audio(sfxFireballHitPath); sfxFireballHit.volume = 0.8;
        let isMuted = false; let audioInitialized = false;

        // --- Audio Helper Functions (Unchanged) ---
        function playSfx(sfx) {
            let sfxName = sfx ? (sfx.src ? sfx.src.split('/').pop() : 'No Source') : 'INVALID SFX';
            if (isMuted || !audioInitialized) return;
            if (sfx && sfx.src && sfx.readyState >= 2) {
                 sfx.currentTime = 0;
                 sfx.play().catch(e => console.warn(`!!! SFX Play Fail: ${sfxName} - ${e.name} (${e.message})`));
            } else if (sfx && sfx.src) {
                 console.warn(`!!! SFX Not Ready: ${sfxName}, State: ${sfx.readyState}`);
            } else {
                 console.error(`!!! SFX Error: Invalid SFX object passed to playSfx.`);
            }
        }
        function startMusic() {
             if (isMuted || !audioInitialized) return;
             if (bgMusic.src && bgMusic.readyState >= 2) {
                  bgMusic.play().catch(e => console.error("Music play failed:", e.name, bgMusic.src));
             } else if (bgMusic.src) {
                 bgMusic.addEventListener('canplaythrough', () => {
                     if (!isMuted && audioInitialized) {
                          bgMusic.play().catch(e => console.error("Music play (deferred) failed:", e.name, bgMusic.src));
                     }
                 }, { once: true });
                  console.warn("Music not ready, attempting play when loaded:", bgMusic.src);
             } else {
                  console.warn("Attempted to play music, but no source is set.");
             }
        }
        function stopMusic() { if (bgMusic) { bgMusic.pause(); bgMusic.currentTime = 0; } }
        function initializeAudio() {
            if (audioInitialized) return;
            console.log("Attempting to initialize audio context...");
            const soundsToUnlock = [ bgMusic, sfxSuccess, sfxError, sfxGameOver, sfxHit, sfxDefeat, sfxMove, sfxSelect, sfxFireballCast, sfxFireballHit ];
            let promiseChain = Promise.resolve();
            soundsToUnlock.forEach(sound => {
                promiseChain = promiseChain.then(() => {
                    if (sound && typeof sound.play === 'function') {
                        const wasMuted = sound.muted; sound.muted = false;
                        const playPromise = sound.play();
                        if (playPromise && typeof playPromise.then === 'function') {
                            return playPromise.then(() => { sound.pause(); sound.muted = wasMuted; }).catch(err => { sound.muted = wasMuted; });
                        } else { sound.muted = wasMuted; }
                    }
                    return Promise.resolve();
                });
            });
            promiseChain.then(() => {
                if (!audioInitialized) {
                    audioInitialized = true;
                    console.log("Audio context potentially initialized by user action.");
                    if (!isGameOver() && startScreen.style.display === 'none' && !isMuted) { startMusic(); }
                }
            }).catch(e => console.warn("Audio context unlock sequence had issues:", e));
        }

        // --- Game Config & State (Unchanged) ---
        const GRID_COLS = 8; const GRID_ROWS = 10; let currentCellSize = 30; const FIREBALL_UNLOCK_LEVEL = 4; const FIREBALL_DAMAGE = 2; const UNIT_DATA = { knight: { name: "Knight", hp: 6, atk: 1, mov: 3, team: 'player', spriteUrl: './sprites/Knight.png'}, goblin: { name: "Goblin", hp: 2, atk: 1, mov: 4, team: 'enemy', spriteUrl: './sprites/Goblin.png'} };
        let units = []; let selectedUnit = null; let currentTurn = 'player'; let validMoves = []; let validAttacks = []; let unitCounter = 0; let isProcessing = false; let currentLevel = 1; let clickedUnitObject = null; let hasFireball = false; let fireballSelected = false; let resizeTimeout = null; let winCheckTimeout = null;

        // --- Layout & Resize (MODIFIED: calculateCellSize primarily for unit size, applyLayout updates unit sizes/positions) ---
        function calculateCellSize() {
             const bw = gameBoard.clientWidth;
             const bh = gameBoard.clientHeight;
             // Calculate based on actual board dimensions, use floor to avoid fractional pixels.
             if (bw > 1 && bh > 1) {
                  const cellWidth = Math.floor(bw / GRID_COLS);
                  const cellHeight = Math.floor(bh / GRID_ROWS);
                  // Use the smaller dimension to ensure cells fit, important for aspect ratio mismatches.
                  currentCellSize = Math.min(cellWidth, cellHeight);
             } else {
                  // Fallback if board dimensions aren't available yet
                  currentCellSize = Math.max(currentCellSize, 20); // Use previous or default
             }
             // Ensure a minimum practical size
             currentCellSize = Math.max(currentCellSize, 10);
             // console.log(`Calculated Cell Size: ${currentCellSize} (Board: ${bw}x${bh})`); // Debugging
        }

        function applyLayout() {
             if (currentCellSize < 10) return; // Don't apply if size is invalid
             // Update position and size for all units
             units.forEach(u => {
                 if (u.element) updateUnitPosition(u, true); // Force size update on resize
             });
             // Re-highlight moves if a unit is selected, as cell elements might have changed
             if (selectedUnit) {
                 highlightMoves(selectedUnit);
             }
             // Note: Damage popups might need recalculation if board size changes drastically,
             // but they are short-lived, so it might not be a major issue.
        }

        const handleResize = () => {
             if (resizeTimeout) clearTimeout(resizeTimeout);
             resizeTimeout = setTimeout(() => {
                 if (isGameOver() || startScreen.style.display !== 'none') return; // Don't resize if game not active
                 requestAnimationFrame(() => { // Use rAF for smoother rendering
                     calculateCellSize(); // Recalculate based on new dimensions
                     applyLayout();       // Apply new sizes and potentially positions
                 });
             }, 100); // Debounce resize events
        };

        // --- Fullscreen API Logic (Unchanged - includes initializeAudio call) ---
        function isFullscreen() { return !!(document.fullscreenElement||document.webkitFullscreenElement||document.mozFullScreenElement||document.msFullscreenElement); }
        function toggleFullscreen() {
            initializeAudio(); // <<< Call initialize on interaction
            if(!(document.fullscreenEnabled||document.webkitFullscreenEnabled||document.mozFullScreenEnabled||document.msFullscreenEnabled)) return;
            if(!isFullscreen()){const el=gameContainer; if(el.requestFullscreen) el.requestFullscreen(); else if(el.webkitRequestFullscreen) el.webkitRequestFullscreen(); else if(el.mozRequestFullScreen) el.mozRequestFullScreen(); else if(el.msRequestFullscreen) el.msRequestFullscreen();}
            else {if(document.exitFullscreen) document.exitFullscreen(); else if(document.webkitExitFullscreen) document.webkitExitFullscreen(); else if(document.mozCancelFullScreen) document.mozCancelFullScreen(); else if(document.msExitFullscreen) document.msExitFullscreen();}
        }
        function updateFullscreenButton() { if(fullscreenButton){ if(isFullscreen()){fullscreenButton.innerHTML='&#x2715;'; fullscreenButton.title='Exit Fullscreen';} else {fullscreenButton.innerHTML='&#x26F6;'; fullscreenButton.title='Enter Fullscreen';} fullscreenButton.disabled=!(document.fullscreenEnabled||document.webkitFullscreenEnabled||document.mozFullScreenEnabled||document.msFullscreenEnabled);} }

        // --- Initialization & Setup (Unchanged) ---
        function initGame() {
            console.log("Init Game CALLED."); initializeAudio(); isProcessing = true; units = []; unitCounter = 0; selectedUnit = null; validMoves = []; validAttacks = []; currentTurn = 'player'; currentLevel = 1; clickedUnitObject = null; hasFireball = false; fireballSelected = false; if(winCheckTimeout) clearTimeout(winCheckTimeout); if(resizeTimeout) clearTimeout(resizeTimeout); stopMusic(); sfxGameOver.pause(); sfxGameOver.currentTime = 0;
            const randomIndex = Math.floor(Math.random() * musicTracks.length); const selectedTrack = musicTracks[randomIndex]; console.log("Selected music:", selectedTrack); bgMusic.src = selectedTrack; bgMusic.load(); startMusic();
            console.clear(); console.log(`Start Game - Lvl ${currentLevel}`);
            try {
                setupBoard(); updateLevelDisplay(); updateSpellAreaVisibility(); updateSpellUI(); updateUnitInfo(null); feedbackArea.textContent = ''; feedbackArea.className = ''; endTurnButton.classList.remove('disabled'); endTurnButton.disabled = false; gameOverScreen.style.display = 'none'; startScreen.style.display = 'none';
                window.addEventListener('resize', handleResize, { passive: true }); document.addEventListener('fullscreenchange', updateFullscreenButton); document.addEventListener('webkitfullscreenchange', updateFullscreenButton); document.addEventListener('mozfullscreenchange', updateFullscreenButton); document.addEventListener('MSFullscreenChange', updateFullscreenButton); updateFullscreenButton();
                requestAnimationFrame(() => { try { calculateCellSize(); spawnInitialUnits(); updateTurnDisplay(); renderAllUnits(); } catch(rafError) { console.error("Error during initGame rAF:", rafError); } finally { isProcessing = false; console.log("Init complete. Processing unlocked."); } });
            } catch (initError) { console.error("Error during sync initGame:", initError); isProcessing = false; }
        }

        // --- Board & Spawning (Unchanged) ---
        function setupBoard() {
            gameBoard.innerHTML = ''; // Clear previous cells and units
            gameBoard.className = ''; // Reset classes
            // Create grid cells
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    cell.dataset.x = c;
                    cell.dataset.y = r;
                    cell.addEventListener('click', handleCellClick);
                    // Set grid area for the cell itself (optional but good practice)
                    cell.style.gridColumn = c + 1;
                    cell.style.gridRow = r + 1;
                    gameBoard.appendChild(cell);
                }
            }
            // Add hover listeners for unit info display
            gameBoard.addEventListener('mouseover', handleMouseEnterOnBoard);
            gameBoard.addEventListener('mouseout', handleMouseLeaveOnBoard);
        }
        function spawnInitialUnits() { const o=new Set(); const kP=[{x:1,y:8},{x:5,y:8},{x:3,y:9},{x:7,y:8},{x:0,y:8},{x:2,y:9},{x:4,y:9},{x:6,y:9}]; let k=3+Math.floor(currentLevel/6); k=Math.min(k,kP.length); for(let i=0;i<k;i++){const p=kP[i];createUnit('knight',p.x,p.y);o.add(`${p.x},${p.y}`);} const g=3+currentLevel; const r=3; let sG=0; for(let i=0;i<g;i++){ let s=false; let a=0; const mA=GRID_COLS*r*3; while(!s&&a<mA){a++; const x=Math.floor(Math.random()*GRID_COLS); const y=Math.floor(Math.random()*r); const key=`${x},${y}`; if(!o.has(key)){createUnit('goblin',x,y); o.add(key); s=true; sG++;}} if(!s) console.warn(`G spawn fail ${i+1}`);} console.log(`Spawned ${k}k, ${sG}g.`); }
        function createUnit(type, x, y) { const data = UNIT_DATA[type]; if(!data) return; const unit={id:unitCounter++,type,x,y,hp:data.hp,maxHp:data.hp,atk:data.atk,mov:data.mov,team:data.team,acted:false,element:null}; units.push(unit); }

        // --- Rendering (MODIFIED: renderUnit appends to board, updateUnitPosition sets grid pos & size) ---
        function renderAllUnits() {
             // Remove only unit elements, keep grid cells
             document.querySelectorAll('#game-board .unit').forEach(el => el.remove());
             units.forEach(unit => renderUnit(unit));
        }

        function renderUnit(unit) {
             // Remove existing element if it exists (e.g., during level change)
             if (unit.element?.parentNode) {
                 unit.element.parentNode.removeChild(unit.element);
             }
             const el = document.createElement('div');
             el.classList.add('unit', unit.team);
             el.dataset.id = unit.id;
             const d = UNIT_DATA[unit.type];
             if (d.spriteUrl) el.style.backgroundImage = `url('${d.spriteUrl}')`;
             el.classList.toggle('selected', selectedUnit?.id === unit.id);
             el.addEventListener('click', (ev) => { handleUnitClick(ev, unit); });
             // el.style.pointerEvents = 'auto'; // Already set by #game-board .unit selector

             unit.element = el;
             gameBoard.appendChild(el); // Append directly to the grid container
             updateUnitPosition(unit, true); // Set initial grid position and size
        }

        function updateUnitPosition(unit, forceUpdateSize = false) {
            // Check if unit element exists and if cell size is valid
            if (!unit.element || currentCellSize < 10) return;

            // --- Position Update (Using CSS Grid) ---
            // CSS Grid lines are 1-based
            const targetCol = unit.x + 1;
            const targetRow = unit.y + 1;

            // Update grid position if it has changed
            if (unit.element.style.gridColumn !== `${targetCol}`) {
                unit.element.style.gridColumn = targetCol;
            }
            if (unit.element.style.gridRow !== `${targetRow}`) {
                unit.element.style.gridRow = targetRow;
            }

            // --- Size Update ---
            // Calculate desired size (e.g., 80% of cell size)
            const unitSize = Math.floor(currentCellSize * 0.8);
            const finalSize = Math.max(unitSize, 8); // Ensure minimum size
            const newSizePx = `${finalSize}px`;

            // Update size if forced or if it has changed
            if (forceUpdateSize || unit.element.style.width !== newSizePx) {
                unit.element.style.width = newSizePx;
                unit.element.style.height = newSizePx;
            }
        }

        function clearHighlights() {
             document.querySelectorAll('.grid-cell.valid-move, .grid-cell.valid-attack').forEach(c => c.classList.remove('valid-move', 'valid-attack'));
             validMoves = [];
             validAttacks = [];
        }

        function highlightMoves(unit) {
             clearHighlights();
             if (!unit || currentCellSize < 10) return;
             validMoves = getValidMoves(unit);
             validAttacks = getValidAttacks(unit);
             validMoves.forEach(p => {
                 const c = getCellElement(p.x, p.y);
                 if (c) c.classList.add('valid-move');
             });
             // Highlight the *cell* under the attackable unit
             validAttacks.forEach(id => {
                 const targetUnit = units.find(u => u.id === id);
                 if (targetUnit) {
                     const c = getCellElement(targetUnit.x, targetUnit.y);
                     if (c) c.classList.add('valid-attack');
                 }
             });
        }
        // Damage popup positioning remains absolute relative to the board
        function showDamagePopup(x, y, damage) {
            playSfx(sfxHit);
            const popup = document.createElement('div');
            popup.classList.add('damage-popup');
            popup.textContent = `-${damage}`;
            // Calculate approximate center of the target cell for the popup
            const popupX = Math.round(x * currentCellSize + currentCellSize / 2 - 10); // Adjust offset as needed
            const popupY = Math.round(y * currentCellSize + currentCellSize / 2 - 15); // Adjust offset as needed
            popup.style.left = `${popupX}px`;
            popup.style.top = `${popupY}px`;
            gameBoard.appendChild(popup); // Append to gameBoard for absolute positioning context
            setTimeout(() => popup.remove(), 1000);
        }

        // --- UI Update Functions (Unchanged) ---
        function updateLevelDisplay() { if(levelDisplayElement) levelDisplayElement.textContent=`Level: ${currentLevel}`; }
        function updateSpellAreaVisibility() { if(spellAreaElement) spellAreaElement.classList.toggle('visible',currentLevel>=FIREBALL_UNLOCK_LEVEL); }
        function updateSpellUI() { if (!fireballElement) return; fireballElement.className = 'spell-icon'; if (hasFireball) { fireballElement.classList.add('available'); if (fireballSelected) fireballElement.classList.add('selected'); fireballElement.title = "Fireball (Available)"; } else { fireballElement.classList.add('unavailable'); fireballElement.title = (currentLevel < FIREBALL_UNLOCK_LEVEL) ? `Unlock Lvl ${FIREBALL_UNLOCK_LEVEL}` : "Used this level"; } gameBoard.classList.toggle('spell-targeting', fireballSelected); }
        function updateTurnDisplay() { if(!currentTurnDisplay||!actionsLeftDisplay) return; currentTurnDisplay.textContent=`Turn: ${currentTurn==='player'?'Player':'Enemy'}`; if(currentTurn==='player'){const rem=units.filter(u=>u.team==='player'&&!u.acted).length; actionsLeftDisplay.textContent=`Actions Left: ${rem}`; endTurnButton.disabled=false; endTurnButton.classList.remove('disabled');} else {actionsLeftDisplay.textContent=`AI Thinking...`; endTurnButton.disabled=true; endTurnButton.classList.add('disabled');}}
        function updateUnitInfo(unit) { clickedUnitObject=unit; if(unit){const d=UNIT_DATA[unit.type]; unitNameDisplay.textContent=`${d.name}(${unit.id})`; unitHpDisplay.textContent=`HP:${unit.hp}/${unit.maxHp}`; unitAtkDisplay.textContent=`ATK:${unit.atk}`; unitMovDisplay.textContent=`MOV:${unit.mov}`;} else {unitNameDisplay.textContent='-'; unitHpDisplay.textContent='-/-'; unitAtkDisplay.textContent='-'; unitMovDisplay.textContent='-';}}

        // --- Game Logic Handlers (Unchanged - includes initializeAudio calls) ---
        function handleCellClick(event) {
            // Prevent clicks on units bubbling up to the cell if units have pointer-events: auto
            if (event.target.classList.contains('unit') || isProcessing) return;

            initializeAudio(); // Initialize on interaction
            const cell = event.currentTarget;
            const x = parseInt(cell.dataset.x);
            const y = parseInt(cell.dataset.y);
            const unitOnCell = getUnitAt(x, y); // Check if a unit is visually on this cell

            // If clicking a cell while fireball is selected, try to cast or deselect fireball
            if (fireballSelected) {
                // Casting logic might need adjustment if targeting empty cells is intended
                // For now, clicking empty cell deselects fireball
                fireballSelected = false;
                updateSpellUI();
                updateUnitInfo(null); // Clear info panel
                // playSfx(sfxUIClick); // Optional UI sound
                return;
            }

            if (currentTurn === 'player') {
                if (selectedUnit) {
                    // Check if the clicked cell is a valid move destination
                    const isMoveValid = validMoves.some(p => p.x === x && p.y === y);

                    if (isMoveValid) {
                        const unitToMove = selectedUnit;
                        moveUnit(unitToMove, x, y); // Move the unit
                        deselectUnit();             // Deselect after moving
                        finishAction(unitToMove);   // Mark unit as acted
                        updateUnitInfo(null);       // Clear unit info panel
                    } else {
                        // Clicked an invalid cell while a unit was selected
                        deselectUnit();             // Deselect the unit
                        updateUnitInfo(unitOnCell); // Show info for unit on cell, if any
                        playSfx(sfxError);          // Play error sound
                    }
                } else {
                    // No unit selected, just update info for unit on cell (if any)
                    updateUnitInfo(unitOnCell);
                }
            } else {
                // Not player's turn, just show info for unit on cell (if any)
                updateUnitInfo(unitOnCell);
            }
        }
        function handleUnitClick(event, clickedUnit) {
            event.stopPropagation(); // Prevent triggering cell click
            if (isProcessing) return;

            initializeAudio(); // Initialize on interaction

            // If fireball is selected, target the clicked unit
            if (fireballSelected) {
                if (clickedUnit.team === 'enemy') {
                    castFireball(clickedUnit);
                    hasFireball = false;       // Mark fireball as used for this level/turn
                    fireballSelected = false;  // Deselect fireball mode
                    updateSpellUI();
                    updateUnitInfo(null);      // Clear info panel
                } else {
                    // Clicked friendly unit or self with fireball selected, just deselect fireball
                    fireballSelected = false;
                    updateSpellUI();
                    updateUnitInfo(clickedUnit); // Show info for the clicked friendly unit
                    // playSfx(sfxUIClick); // Optional UI sound
                }
                return; // Action handled (cast or cancel fireball)
            }

            // Update info panel regardless of whose turn it is
            updateUnitInfo(clickedUnit);

            // Handle clicks during player's turn
            if (currentTurn === 'player') {
                if (selectedUnit) {
                    // A unit is already selected
                    if (clickedUnit.team === 'enemy' && validAttacks.includes(clickedUnit.id)) {
                        // Clicked a valid enemy target to attack
                        const attacker = selectedUnit;
                        attackUnit(attacker, clickedUnit);
                        deselectUnit();
                        finishAction(attacker);
                    } else if (clickedUnit.team === 'player' && clickedUnit.id !== selectedUnit.id && !clickedUnit.acted) {
                        // Clicked another friendly unit that hasn't acted yet -> switch selection
                        selectUnit(clickedUnit);
                    } else if (clickedUnit.id === selectedUnit.id) {
                        // Clicked the selected unit again -> deselect
                        deselectUnit();
                        updateUnitInfo(null); // Clear info panel on deselect
                        // playSfx(sfxUIClick); // Optional UI sound
                    } else {
                        // Clicked an invalid target (e.g., friendly acted unit, enemy out of range)
                        // Keep current selection, play error sound? Or deselect? Let's deselect.
                        deselectUnit();
                        updateUnitInfo(clickedUnit); // Show info for the clicked unit
                        playSfx(sfxError);
                    }
                } else {
                    // No unit currently selected
                    if (clickedUnit.team === 'player' && !clickedUnit.acted) {
                        // Clicked a friendly unit that can act -> select it
                        selectUnit(clickedUnit);
                    }
                    // If clicked enemy or acted friendly, info is already updated, do nothing else
                }
            }
            // If it's not the player's turn, clicking units only updates the info panel
        }

        // --- Mouse Over/Out (Unchanged) ---
        function handleMouseEnterOnBoard(event) { if(event.target.classList.contains('unit')){const u=units.find(un=>un.id===parseInt(event.target.dataset.id)); if(u&&u!==clickedUnitObject) updateUnitInfo(u);}}
        function handleMouseLeaveOnBoard(event) { if(event.target.classList.contains('unit')){ updateUnitInfo(selectedUnit||clickedUnitObject||null);}}

        // --- Game Logic Actions (MODIFIED: moveUnit calls updated updateUnitPosition) ---
        function handleFireballClick() {
            if (isProcessing || currentTurn !== 'player' || !hasFireball) return;
            initializeAudio(); // Initialize on interaction
            fireballSelected = !fireballSelected;
            if (fireballSelected && selectedUnit) { deselectUnit(); } // Deselect unit if selecting fireball
            // playSfx(sfxUIClick); // Optional UI sound
            console.log(`Fireball toggled: ${fireballSelected}`);
            updateSpellUI(); // Update visual state of fireball icon and board cursor
        }
        function selectUnit(unit) {
             if (!unit || unit.acted || unit.team !== 'player' || currentTurn !== 'player') return;
             if (fireballSelected) { fireballSelected = false; updateSpellUI(); } // Cancel fireball if selecting unit
             deselectUnit(); // Deselect any previously selected unit
             selectedUnit = unit;
             if (unit.element) unit.element.classList.add('selected');
             highlightMoves(unit); // Show valid moves/attacks
             updateUnitInfo(unit); // Update UI panel
             playSfx(sfxSelect);
        }
        function deselectUnit() {
             if (selectedUnit?.element) selectedUnit.element.classList.remove('selected');
             selectedUnit = null;
             clearHighlights(); // Remove move/attack highlights
             // Don't clear unit info here, let clicks handle that
        }
        function finishAction(unit) {
             if (!unit || unit.acted) return;
             unit.acted = true;
             console.log(`Action finished for ${unit.type} ${unit.id}, acted=${unit.acted}`);
             updateTurnDisplay(); // Update actions left count
             checkWinLossConditions(); // Check game state after action
        }
        function moveUnit(unit, targetX, targetY) {
             if (!unit) return;
             unit.x = targetX;
             unit.y = targetY;
             updateUnitPosition(unit); // Update the element's grid position
             playSfx(sfxMove);
        }
        function attackUnit(attacker, defender) {
             if (!attacker || !defender) return;
             playSfx(sfxSuccess); // Sound for successful attack start
             const dmg = attacker.atk;
             defender.hp -= dmg;
             if (defender.hp < 0) defender.hp = 0;
             showDamagePopup(defender.x, defender.y, dmg); // Display damage number (also plays sfxHit)
             if (defender.element) { // Visual feedback on hit
                 defender.element.style.filter = 'brightness(1.8)';
                 setTimeout(() => { if (defender.element) defender.element.style.filter = ''; }, 150);
             }
             updateUnitInfo(clickedUnitObject?.id === defender.id ? defender : clickedUnitObject); // Update info if defender was being viewed
             if (defender.hp <= 0) {
                 removeUnit(defender); // Handle unit death (plays sfxDefeat)
             }
             checkWinLossConditions(); // Check game state after attack resolves
        }
        function castFireball(targetUnit) {
            if (!targetUnit || targetUnit.team !== 'enemy') return;
            playSfx(sfxFireballCast); // Play cast sound
            isProcessing = true; // Prevent other actions during animation/effect
            // Visual effect on target before damage
            if (targetUnit.element) {
                targetUnit.element.style.filter = 'sepia(1) saturate(3) hue-rotate(-40deg) brightness(1.2)';
                setTimeout(() => { if (targetUnit.element) targetUnit.element.style.filter = ''; }, 250);
            }
            // Apply damage after a short delay
            setTimeout(() => {
                playSfx(sfxFireballHit); // Play hit sound
                targetUnit.hp -= FIREBALL_DAMAGE;
                if (targetUnit.hp < 0) targetUnit.hp = 0;
                showDamagePopup(targetUnit.x, targetUnit.y, FIREBALL_DAMAGE); // Display damage (also plays sfxHit)
                updateUnitInfo(clickedUnitObject?.id === targetUnit.id ? targetUnit : clickedUnitObject); // Update info if target was viewed
                if (targetUnit.hp <= 0) {
                    removeUnit(targetUnit); // Handle unit death (plays sfxDefeat)
                }
                checkWinLossConditions(); // Check game state
                isProcessing = false; // Allow actions again
            }, 100); // Delay matches sound/visual timing potentially
        }
        function removeUnit(unit) {
            if (!unit) return;
            playSfx(sfxDefeat); // Play death sound
            unit.element?.remove(); // Remove element from DOM
            units = units.filter(u => u.id !== unit.id); // Remove from active units array
            // If the removed unit was selected or being viewed, clear selection/info
            if (selectedUnit?.id === unit.id) { deselectUnit(); updateUnitInfo(null); }
            else if (clickedUnitObject?.id === unit.id) { updateUnitInfo(null); }
            updateTurnDisplay(); // May affect actions left if player unit is removed (unlikely scenario)
            checkWinLossConditions(); // Check game state after removal
        }

        // --- Utility Functions (Unchanged) ---
        function getUnitAt(x, y) { return units.find(unit => unit.x === x && unit.y === y); }
        function getCellElement(x, y) { return gameBoard.querySelector(`.grid-cell[data-x='${x}'][data-y='${y}']`); }
        function getDistance(unitA, unitB) { if (!unitA || !unitB) return Infinity; return Math.abs(unitA.x - unitB.x) + Math.abs(unitA.y - unitB.y); }
        function getValidMoves(unit) { if (!unit) return []; const moves = []; const queue = [{ x: unit.x, y: unit.y, distance: 0 }]; const visited = new Set([`${unit.x},${unit.y}`]); while (queue.length > 0) { const current = queue.shift(); const neighbors = [{ x: current.x, y: current.y - 1 }, { x: current.x, y: current.y + 1 }, { x: current.x - 1, y: current.y }, { x: current.x + 1, y: current.y }]; for (const neighbor of neighbors) { const key = `${neighbor.x},${neighbor.y}`; if (neighbor.x < 0 || neighbor.x >= GRID_COLS || neighbor.y < 0 || neighbor.y >= GRID_ROWS || visited.has(key)) continue; const newDistance = current.distance + 1; if (newDistance > unit.mov) continue; const unitAtNeighbor = getUnitAt(neighbor.x, neighbor.y); if (unitAtNeighbor) continue; /* Cannot move onto occupied cell */ moves.push({ x: neighbor.x, y: neighbor.y }); visited.add(key); queue.push({ x: neighbor.x, y: neighbor.y, distance: newDistance }); } } return moves; }
        function getValidAttacks(unit) { const attacks = []; if (!unit) return attacks; units.forEach(target => { if (target.team !== unit.team && target.hp > 0 && getDistance(unit, target) === 1) { attacks.push(target.id); } }); return attacks; }

        // --- Turn Management & AI (Unchanged - includes initializeAudio call in endTurn) ---
        function endTurn() {
            if ((currentTurn === 'player' && isProcessing) || currentTurn === 'enemy') return;
            initializeAudio(); // Initialize on interaction
            // playSfx(sfxUIClick); // Optional UI sound
            deselectUnit(); // Clear player selection
            fireballSelected = false; updateSpellUI(); // Reset fireball state
            updateUnitInfo(null); // Clear info panel
            feedbackArea.textContent = ''; feedbackArea.className = ''; // Clear feedback messages

            if (currentTurn === 'player') {
                 isProcessing = true; // Block player input during AI turn
                 currentTurn = 'enemy';
                 units.filter(u => u.team === 'enemy').forEach(u => u.acted = false); // Reset enemy actions
                 updateTurnDisplay(); // Show "AI Thinking..."
                 setTimeout(runAITurn, 50); // Start AI logic after a brief delay
            }
            // No transition from enemy to player here, AI turn completion handles that
        }
        endTurnButton.addEventListener('click', () => { if (currentTurn === 'player' && !isProcessing) endTurn(); });

        // --- AI Logic (Unchanged) ---
        function runAITurn() { isProcessing=true; const toAct=units.filter(u=>u.team==='enemy'&&u.hp>0&&!u.acted); let done=0; const total=toAct.length; const interval=350; let delay=0; function checkDone(){ done++; if(done>=total) setTimeout(()=>{if(!isGameOver()){currentTurn='player'; units.filter(u=>u.team==='player').forEach(u=>u.acted=false); updateTurnDisplay(); isProcessing=false; console.log("AI Turn End. Player Turn.");} else { isProcessing = false; }}, 50);} if(total===0){ setTimeout(()=>{if(!isGameOver()){currentTurn='player'; units.filter(u=>u.team==='player').forEach(u=>u.acted=false); updateTurnDisplay(); isProcessing=false; console.log("AI Turn End (no units). Player Turn.");}}, 100); return; } toAct.forEach(u=>{ setTimeout(()=>{ if(isGameOver()){checkDone(); return;} try { const stillValid=units.find(un=>un.id===u.id&&un.hp>0&&!un.acted); if(stillValid) performAIAction(stillValid); else if(u) u.acted=true;} catch(e){console.error(`AI Error ${u?.id}:`,e); if(u) u.acted=true;} finally {checkDone();} }, delay); delay+=interval; }); }
        function performAIAction(unit) { const targets=units.filter(u=>u.team==='player'&&u.hp>0); if(targets.length===0){unit.acted=true; return;} let attackTarget=null; const attacks=getValidAttacks(unit); if(attacks.length>0){let lowHP=Infinity; attacks.forEach(id=>{const t=units.find(u=>u.id===id); if(t && t.hp < lowHP) {lowHP=t.hp; attackTarget=t;}}); } if(attackTarget){attackUnit(unit,attackTarget); unit.acted=true; return;} let nearest=null; let minDist=Infinity; targets.forEach(t=>{const d=getDistance(unit,t); if(d<minDist){minDist=d; nearest=t;}}); if(nearest){ const moves=getValidMoves(unit); if(moves.length > 0){let bestMove=null; let closest=minDist; moves.forEach(m=>{const d = Math.abs(m.x-nearest.x)+Math.abs(m.y-nearest.y); if(d<closest){closest=d; bestMove=m;}}); if(bestMove && (bestMove.x!==unit.x || bestMove.y !== unit.y)){moveUnit(unit,bestMove.x,bestMove.y); unit.acted=true; return;}}} unit.acted=true;}

        // --- Win/Loss & Level Progression (Unchanged) ---
        function checkWinLossConditions() { if (winCheckTimeout) clearTimeout(winCheckTimeout); winCheckTimeout = setTimeout(() => { if (isGameOver() || isProcessing) return; const pLeft = units.some(u => u.team === 'player' && u.hp > 0); const eLeft = units.some(u => u.team === 'enemy' && u.hp > 0); if (!eLeft && pLeft) { console.log(`Level ${currentLevel} Cleared!`); /* playSfx(sfxLevelWin); */ isProcessing = true; feedbackArea.textContent = `Level ${currentLevel} Cleared!`; feedbackArea.className = 'feedback-levelup'; setTimeout(startNextLevel, 1500); } else if (!pLeft) { gameOver(false); } }, 250); }
        function startNextLevel() { currentLevel++; console.log(`--- Start Lvl ${currentLevel} ---`); stopMusic(); const randomIndex = Math.floor(Math.random() * musicTracks.length); const selectedTrack = musicTracks[randomIndex]; console.log("Selected music for next level:", selectedTrack); bgMusic.src = selectedTrack; bgMusic.load(); startMusic(); hasFireball = (currentLevel >= FIREBALL_UNLOCK_LEVEL); fireballSelected = false; units = []; unitCounter = 0; selectedUnit = null; validMoves = []; validAttacks = []; currentTurn = 'player'; document.querySelectorAll('#game-board .unit, #game-board .damage-popup').forEach(el => el.remove()); clearHighlights(); updateLevelDisplay(); updateSpellAreaVisibility(); updateSpellUI(); updateUnitInfo(null); endTurnButton.disabled = false; endTurnButton.classList.remove('disabled'); feedbackArea.textContent = `Lvl ${currentLevel} Start!`; feedbackArea.className = 'feedback-levelup'; setTimeout(() => { if (!isGameOver()) { feedbackArea.textContent = ''; feedbackArea.className = ''; } }, 2000); requestAnimationFrame(() => { calculateCellSize(); spawnInitialUnits(); updateTurnDisplay(); renderAllUnits(); isProcessing = false; console.log(`Lvl ${currentLevel} ready.`); }); }
        function isGameOver() { return gameOverScreen.style.display !== 'none'; }
        function gameOver(playerWon) { if (playerWon || isGameOver()) return; console.log(`--- Game Over Lvl ${currentLevel} ---`); stopMusic(); playSfx(sfxGameOver); isProcessing = true; deselectUnit(); updateUnitInfo(null); endTurnButton.disabled = true; endTurnButton.classList.add('disabled'); gameOverTitle.textContent = "Defeat!"; gameOverMessage.textContent = `Fallen on Level ${currentLevel}!`; gameOverScreen.style.display = 'flex'; window.removeEventListener('resize', handleResize); document.removeEventListener('fullscreenchange', updateFullscreenButton); document.removeEventListener('webkitfullscreenchange', updateFullscreenButton); document.removeEventListener('mozfullscreenchange', updateFullscreenButton); document.removeEventListener('MSFullscreenChange', updateFullscreenButton); if (winCheckTimeout) clearTimeout(winCheckTimeout); if (resizeTimeout) clearTimeout(resizeTimeout); }

        // --- Global Event Listeners (Unchanged) ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded Fired.");
            if (muteButton) {
                muteButton.addEventListener('click', () => {
                    initializeAudio(); // Initialize on interaction
                    isMuted = !isMuted;
                    bgMusic.muted = isMuted; sfxSuccess.muted = isMuted; sfxError.muted = isMuted; sfxGameOver.muted = isMuted; sfxHit.muted = isMuted; sfxDefeat.muted = isMuted; sfxMove.muted = isMuted; sfxSelect.muted = isMuted; sfxFireballCast.muted = isMuted; sfxFireballHit.muted = isMuted;
                    updateMuteButtonVisual();
                    if (!isMuted && audioInitialized && !isGameOver() && startScreen.style.display === 'none') { startMusic(); } else if (isMuted) { bgMusic.pause(); }
                });
            } else { console.error("Mute button not found!"); }

            const fbElement = document.getElementById('fireball-spell'); if(fbElement){fbElement.addEventListener('click', handleFireballClick);} else {console.error("FB Spell not found!");}
            if(fullscreenButton){fullscreenButton.addEventListener('click', toggleFullscreen);} else {console.error("Fullscreen button not found!");}
            if(startButton){startButton.addEventListener('click', () => { initGame(); });} else {console.error("Start Button not found!");}
            if(restartButton){restartButton.addEventListener('click', () => { initGame(); });} else {console.error("Restart Button not found!");}

            startScreen.style.display = 'flex'; gameOverScreen.style.display = 'none'; endTurnButton.classList.add('disabled'); endTurnButton.disabled = true; updateUnitInfo(null); updateLevelDisplay(); updateSpellAreaVisibility(); updateSpellUI(); updateTurnDisplay(); updateMuteButtonVisual(); setupBoard(); // Setup board structure initially
            requestAnimationFrame(() => { calculateCellSize(); updateFullscreenButton(); }); // Calculate initial size after layout
            console.log("Initial setup complete. Waiting for user interaction.");
        });
        function updateMuteButtonVisual() { if (muteButton) { muteButton.innerHTML = isMuted ? '🔇' : '🔊'; muteButton.title = isMuted ? 'Unmute' : 'Mute Sound'; } }
        window.addEventListener('keydown', function(event) { if (event.shiftKey && event.code === 'KeyT') { if (isGameOver() || startScreen.style.display !== 'none' || isProcessing || currentTurn === 'enemy') return; console.warn("CHEAT: Skip Level!"); isProcessing = true; setTimeout(startNextLevel, 50); } });

    </script>
</body>
</html>